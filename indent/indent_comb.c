/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 58 "sys.h"
struct file_buffer {
   char *name ;
   unsigned long size ;
   char *data ;
};
#line 22 "indent.h"
enum codes {
    code_eof = 0,
    newline = 1,
    lparen = 2,
    rparen = 3,
    unary_op = 4,
    binary_op = 5,
    postop = 6,
    question = 7,
    casestmt = 8,
    colon = 9,
    semicolon = 10,
    lbrace = 11,
    rbrace = 12,
    ident = 13,
    comma = 14,
    comment = 15,
    cplus_comment = 16,
    swstmt = 17,
    preesc = 18,
    form_feed = 19,
    decl = 20,
    sp_paren = 21,
    sp_nparen = 22,
    ifstmt = 23,
    whilestmt = 24,
    forstmt = 25,
    stmt = 26,
    stmtl = 27,
    elselit = 28,
    dolit = 29,
    dohead = 30,
    dostmt = 31,
    ifhead = 32,
    elsehead = 33,
    period = 34
} ;
#line 46
enum rwcodes {
    rw_none = 0,
    rw_break = 1,
    rw_switch = 2,
    rw_case = 3,
    rw_struct_like = 4,
    rw_decl = 5,
    rw_sp_paren = 6,
    rw_sp_nparen = 7,
    rw_sizeof = 8,
    rw_return = 9
} ;
#line 108 "indent.h"
struct buf {
   char *ptr ;
   char *end ;
   int size ;
};
#line 273 "indent.h"
struct fstate {
   char font[4] ;
   char size ;
   int allcaps : 1 ;
};
#line 292 "indent.h"
struct parser_state {
   struct parser_state *next ;
   enum codes last_token ;
   struct fstate cfont ;
   enum codes *p_stack ;
   int p_stack_size ;
   int *il ;
   enum rwcodes last_rw ;
   int *cstk ;
   int tos ;
   int box_com ;
   int cast_mask ;
   int noncast_mask ;
   int sizeof_mask ;
   int block_init ;
   int block_init_level ;
   int last_nl ;
   int in_or_st ;
   int bl_line ;
   int col_1 ;
   int com_col ;
   int dec_nest ;
   int decl_on_line ;
   int i_l_follow ;
   int in_decl ;
   int in_stmt ;
   int ind_level ;
   int ind_stmt ;
   int last_u_d ;
   int p_l_follow ;
   int paren_level ;
   int paren_depth ;
   short *paren_indents ;
   int paren_indents_size ;
   int pcase ;
   int search_brace ;
   int use_ff ;
   int want_blank ;
   int its_a_keyword ;
   int sizeof_keyword ;
   int dumped_decl_indent ;
   int in_parameter_declaration ;
   char *procname ;
   char *procname_end ;
   int just_saw_decl ;
};
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 39 "lexi.c"
struct templ {
   char *rwd ;
   enum rwcodes rwcode ;
};
#line 39 "args.c"
enum profile {
    PRO_BOOL = 0,
    PRO_INT = 1,
    PRO_FONT = 2,
    PRO_IGN = 3,
    PRO_KEY = 4,
    PRO_SETTINGS = 5,
    PRO_PRSTRING = 6,
    PRO_FUNCTION = 7
} ;
#line 52
enum on_or_off {
    ONOFF_NA = 0,
    OFF = 1,
    ON = 2
} ;
#line 168 "args.c"
struct pro {
   char *p_name ;
   enum profile p_type ;
   int p_default ;
   enum on_or_off p_special ;
   int *p_obj ;
   int *p_explicit ;
};
#line 398 "args.c"
struct long_option_conversion {
   char *long_name ;
   char *short_name ;
};
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 17 "backup.h"
enum backup_mode {
    unknown = 0,
    none = 1,
    simple = 2,
    numbered_existing = 3,
    numbered = 4
} ;
#line 36 "backup.h"
struct version_control_values {
   enum backup_mode value ;
   char *name ;
};
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 1 "indent.o"
#pragma merger(0,"/tmp/cil-DATCpzzc.i","-O")
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 216
extern int fclose(FILE *__stream ) ;
#line 221
extern int fflush(FILE *__stream ) ;
#line 251
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 65 "sys.h"
struct file_buffer *read_file(char *filename ) ;
#line 65
struct file_buffer *read_stdin(void) ;
#line 72
char *xmalloc(unsigned int size ) ;
#line 73
char *xrealloc(char *ptr , unsigned int size ) ;
#line 64 "indent.h"
char *in_name ;
#line 66
char *in_prog ;
#line 71
char *in_prog_pos ;
#line 74
char *cur_line ;
#line 77
unsigned long in_prog_size ;
#line 79
FILE *output ;
#line 81 "indent.h"
char *labbuf  ;
#line 82 "indent.h"
char *s_lab  ;
#line 83 "indent.h"
char *e_lab  ;
#line 84 "indent.h"
char *l_lab  ;
#line 86 "indent.h"
char *codebuf  ;
#line 87 "indent.h"
char *s_code  ;
#line 88 "indent.h"
char *e_code  ;
#line 89 "indent.h"
char *l_code  ;
#line 91 "indent.h"
char *combuf  ;
#line 92 "indent.h"
char *s_com  ;
#line 93 "indent.h"
char *e_com  ;
#line 94 "indent.h"
char *l_com  ;
#line 96
char *buf_ptr ;
#line 98
char *buf_end ;
#line 101
char *token ;
#line 103
char *token_end ;
#line 105
enum codes lexi(void) ;
#line 125 "indent.h"
struct buf save_com  ;
#line 127 "indent.h"
char *bp_save  ;
#line 129 "indent.h"
char *be_save  ;
#line 132
int use_stdout ;
#line 135
int blanklines_after_procs ;
#line 136
int blanklines_around_conditional_compilation ;
#line 138
int n_real_blanklines ;
#line 139
int prefix_blankline_requested ;
#line 140
int postfix_blankline_requested ;
#line 141 "indent.h"
int break_comma  ;
#line 144
int found_err ;
#line 148 "indent.h"
int embedded_comment_on_line  ;
#line 150 "indent.h"
int else_or_endif  ;
#line 151 "indent.h"
int di_stack_alloc  ;
#line 152 "indent.h"
int *di_stack  ;
#line 159
int btype_2 ;
#line 163
int space_sp_semicolon ;
#line 171 "indent.h"
int code_lines  ;
#line 173
int out_coms ;
#line 174
int out_lines ;
#line 176
int com_lines ;
#line 180
int had_eof ;
#line 181 "indent.h"
int line_no  ;
#line 183
int max_col ;
#line 184
int verbose ;
#line 186
int cuddle_else ;
#line 190
int troff ;
#line 191
int procnames_start_line ;
#line 195
int expect_output_file ;
#line 196
int proc_calls_space ;
#line 198
int cast_space ;
#line 208
int continuation_indent ;
#line 212
int leave_preproc_space ;
#line 217
int paren_target ;
#line 220
int blank_after_sizeof ;
#line 235
int comment_max_col ;
#line 236
int extra_expression_indent ;
#line 245
int leave_comma ;
#line 247
int decl_com_ind ;
#line 251
int com_ind ;
#line 253
int decl_indent ;
#line 254
int ljust_decl ;
#line 259
int else_if ;
#line 262
int indent_parameters ;
#line 264
int ind_size ;
#line 266
int tabsize ;
#line 279
char *chfont(struct fstate *of , struct fstate *nf , char *s ) ;
#line 281 "indent.h"
struct fstate keywordf  ;
#line 281 "indent.h"
struct fstate stringf  ;
#line 281 "indent.h"
struct fstate boxcomf  ;
#line 281 "indent.h"
struct fstate blkcomf  ;
#line 281 "indent.h"
struct fstate scomf  ;
#line 281 "indent.h"
struct fstate bodyf  ;
#line 399
struct parser_state *parser_state_tos ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 31 "indent.c"
extern int ( /* missing proto */  exit)() ;
#line 26 "indent.c"
void usage(void) 
{ 

  {
#line 29
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: indent file [-o outfile ] [ options ]\n");
#line 30
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"       indent file1 file2 ... fileN [ options ]\n");
#line 31
  exit(1);
}
}
#line 86 "indent.c"
int squest  ;
#line 160
void parsefont(struct fstate *f , char *s0 ) ;
#line 171
int writefdef(struct fstate *f , unsigned int nm ) ;
#line 185
void fill_buffer(void) ;
#line 321
int diag(int level , char *msg , unsigned int a , unsigned int b ) ;
#line 407
void dump_line(void) ;
#line 497
int compute_code_target(void) ;
#line 564
extern int ( /* missing proto */  strlen)() ;
#line 596
void parse_lparen_in_decl(void) ;
#line 682
void parse(enum codes tk ) ;
#line 726
static void indent(struct file_buffer *this_file ) ;
#line 726 "indent.c"
static char resval[5]  = {      (char )'\\',      (char )'(',      (char )'-',      (char )'>', 
        (char )'\000'};
#line 760 "indent.c"
static char resval___0[5]  = {      (char )'\\',      (char )'(',      (char )'<',      (char )'=', 
        (char )'\000'};
#line 764 "indent.c"
static char resval___1[5]  = {      (char )'\\',      (char )'(',      (char )'>',      (char )'=', 
        (char )'\000'};
#line 768 "indent.c"
static char resval___2[5]  = {      (char )'\\',      (char )'(',      (char )'!',      (char )'=', 
        (char )'\000'};
#line 773 "indent.c"
static char resval___3[9]  = 
#line 773
  {      (char )'\\',      (char )'(',      (char )'b',      (char )'r', 
        (char )'\\',      (char )'(',      (char )'b',      (char )'r', 
        (char )'\000'};
#line 776 "indent.c"
static char resval___4[5]  = {      (char )'\\',      (char )'(',      (char )'b',      (char )'r', 
        (char )'\000'};
#line 1272
extern int ( /* missing proto */  strncmp)() ;
#line 1422
extern int ( /* missing proto */  strncpy)() ;
#line 1461
extern int ( /* missing proto */  bcopy)() ;
#line 1559
extern int ( /* missing proto */  free)() ;
#line 1598
void print_comment(void) ;
#line 106 "indent.c"
static void indent(struct file_buffer *this_file ) 
{ register int i ;
  enum codes hd_type ;
  register char *t_ptr ;
  enum codes type_code ;
  int dec_ind ;
  int flushed_nl ;
  int force_nl ;
  int scase ;
  int sp_sw ;
  int last_token_ends_sp ;
  int last_else ;
  register char *p ;
  register int col ;
  register char *p___0 ;
  register char *beg ;
  char *tmp___0 ;
  int is_procname ;
  char *tmp___1 ;
  char *tmp___2 ;
  int cur_chars ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int cur_chars___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int cur_chars___1 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int cur_chars___2 ;
  char *tmp___12 ;
  int cur_chars___3 ;
  char *tmp___13 ;
  char *tmp___14 ;
  register int nsize ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  register int nsize___0 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  register int nsize___1 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int level ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *res ;
  char *res_end ;
  register int nsize___2 ;
  char *tmp___31 ;
  char *tmp___32 ;
  register int nsize___3 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *res___0 ;
  char *res_end___0 ;
  register int nsize___4 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  register int nsize___5 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  int tmp___57 ;
  char *tmp___59 ;
  int tmp___60 ;
  register int nsize___6 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  register int nsize___7 ;
  char *tmp___64 ;
  char *tmp___65 ;
  int __res___0 ;
  __int32_t const   **tmp___72 ;
  unsigned short const   **tmp___73 ;
  char qchar ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  register int nsize___8 ;
  char *tmp___79 ;
  char *tmp___80 ;
  int tmp___81 ;
  char *tmp___82 ;
  register int nsize___9 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  int tmp___86 ;
  int in_comment ;
  int in_cplus_comment ;
  int com_start ;
  char quote ;
  int com_end ;
  char *p___1 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  register int nsize___10 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  int cur_chars___4 ;
  char *tmp___104 ;
  char *tmp___105 ;
  int cur_chars___5 ;
  int cur_chars___6 ;
  register int c ;
  char *tmp___106 ;
  struct parser_state *new ;
  char *tmp___107 ;
  char *tmp___108 ;
  char *tmp___109 ;
  char *tmp___110 ;
  char *tmp___111 ;
  enum codes *tos_p_stack ;
  int *tos_il ;
  int *tos_cstk ;
  short *tos_paren_indents ;
  struct parser_state *second ;
  struct parser_state *second___0 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;

  {
#line 116
  dec_ind = 0;
#line 120
  flushed_nl = 0;
#line 121
  force_nl = 0;
#line 125
  scase = 0;
#line 128
  sp_sw = 0;
#line 135
  last_token_ends_sp = 0;
#line 138
  last_else = 0;
#line 141
  in_prog_pos = this_file->data;
#line 141
  in_prog = in_prog_pos;
#line 142
  in_prog_size = this_file->size;
#line 144
  hd_type = 0;
#line 145
  dec_ind = 0;
#line 146
  last_token_ends_sp = 0;
#line 147
  last_else = 0;
#line 148
  force_nl = 0;
#line 148
  sp_sw = force_nl;
#line 149
  scase = 0;
#line 150
  squest = 0;
#line 157
  if (troff) {
#line 159
    if ((int )bodyf.font[0] == 0) {
#line 160
      parsefont(& bodyf, "R");
    }
#line 161
    if ((int )scomf.font[0] == 0) {
#line 162
      parsefont(& scomf, "I");
    }
#line 163
    if ((int )blkcomf.font[0] == 0) {
#line 164
      blkcomf = scomf;
#line 164
      blkcomf.size = (char )((int )blkcomf.size + 2);
    }
#line 165
    if ((int )boxcomf.font[0] == 0) {
#line 166
      boxcomf = blkcomf;
    }
#line 167
    if ((int )stringf.font[0] == 0) {
#line 168
      parsefont(& stringf, "L");
    }
#line 169
    if ((int )keywordf.font[0] == 0) {
#line 170
      parsefont(& keywordf, "B");
    }
#line 171
    writefdef(& bodyf, 'B');
#line 172
    writefdef(& scomf, 'C');
#line 173
    writefdef(& blkcomf, 'L');
#line 174
    writefdef(& boxcomf, 'X');
#line 175
    writefdef(& stringf, 'S');
#line 176
    writefdef(& keywordf, 'K');
  }
#line 178
  if (comment_max_col <= 0) {
#line 179
    comment_max_col = max_col;
  }
#line 180
  if (decl_com_ind <= 0) {
#line 181
    if (ljust_decl) {
#line 181
      if (com_ind <= 10) {
#line 181
        decl_com_ind = 2;
      } else {
#line 181
        decl_com_ind = com_ind - 8;
      }
    } else {
#line 181
      decl_com_ind = com_ind;
    }
  }
#line 183
  if (continuation_indent == 0) {
#line 184
    continuation_indent = ind_size;
  }
#line 185
  fill_buffer();
#line 192
  p = buf_ptr;
#line 193
  col = 1;
#line 195
  while (1) {
#line 197
    if ((int )*p == 32) {
#line 198
      col ++;
    } else {
#line 199
      if ((int )*p == 9) {
#line 200
        col = (tabsize - col % tabsize) + 1;
      } else {
#line 201
        if ((int )*p == 10) {
#line 202
          col = 1;
        } else {
#line 204
          break;
        }
      }
    }
#line 206
    p ++;
  }
#line 215
  if (troff) {
#line 217
    p___0 = in_name;
#line 217
    beg = in_name;
#line 219
    while (*p___0) {
#line 220
      tmp___0 = p___0;
#line 220
      p___0 ++;
#line 220
      if ((int )*tmp___0 == 47) {
#line 221
        beg = p___0;
      }
    }
#line 222
    fprintf((FILE * __restrict  )output, (char const   * __restrict  )".Fn \"%s\"\n",
            beg);
  }
#line 226
  while (1) {
#line 231
    type_code = lexi();
#line 235
    if (last_token_ends_sp > 0) {
#line 236
      last_token_ends_sp --;
    }
#line 237
    is_procname = (int )*(parser_state_tos->procname + 0);
#line 243
    flushed_nl = 0;
#line 244
    while (parser_state_tos->search_brace) {
#line 250
      switch ((int )type_code) {
      case 1: 
#line 253
      line_no ++;
#line 254
      flushed_nl = 1;
      case 19: 
#line 256
      break;
      case 11: 
#line 261
      if ((unsigned int )save_com.end == (unsigned int )save_com.ptr) {
#line 264
        parser_state_tos->search_brace = 0;
        goto check_type;
      }
#line 268
      if (btype_2) {
#line 272
        *(save_com.ptr + 0) = (char )'{';
      } else {
#line 280
        tmp___1 = save_com.end;
#line 280
        (save_com.end) ++;
#line 280
        *tmp___1 = (char )'\n';
#line 281
        tmp___2 = save_com.end;
#line 281
        (save_com.end) ++;
#line 281
        *tmp___2 = (char )'{';
      }
      goto sw_buffer;
      case 15: 
#line 289
      if (! flushed_nl) {
        goto _L;
      } else {
#line 289
        if ((unsigned int )save_com.end != (unsigned int )save_com.ptr) {
          _L: /* CIL Label */ 
#line 291
          if ((save_com.end - save_com.ptr) + 10 >= save_com.size) {
#line 291
            cur_chars = save_com.end - save_com.ptr;
#line 291
            save_com.size *= 2;
#line 291
            save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 291
            save_com.end = save_com.ptr + cur_chars;
          }
#line 292
          if ((unsigned int )save_com.end == (unsigned int )save_com.ptr) {
#line 295
            *(save_com.ptr + 1) = (char )' ';
#line 295
            *(save_com.ptr + 0) = *(save_com.ptr + 1);
#line 296
            save_com.end = save_com.ptr + 2;
          } else {
#line 300
            tmp___3 = save_com.end;
#line 300
            (save_com.end) ++;
#line 300
            *tmp___3 = (char )'\n';
#line 302
            tmp___4 = save_com.end;
#line 302
            (save_com.end) ++;
#line 302
            *tmp___4 = (char )' ';
#line 303
            line_no --;
          }
#line 305
          tmp___5 = save_com.end;
#line 305
          (save_com.end) ++;
#line 305
          *tmp___5 = (char )'/';
#line 306
          tmp___6 = save_com.end;
#line 306
          (save_com.end) ++;
#line 306
          *tmp___6 = (char )'*';
#line 308
          while (1) {
#line 314
            if ((save_com.end - save_com.ptr) + 2 >= save_com.size) {
#line 314
              cur_chars___0 = save_com.end - save_com.ptr;
#line 314
              save_com.size *= 2;
#line 314
              save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 314
              save_com.end = save_com.ptr + cur_chars___0;
            }
#line 315
            tmp___7 = buf_ptr;
#line 315
            buf_ptr ++;
#line 315
            *(save_com.end) = *tmp___7;
#line 316
            if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 318
              fill_buffer();
#line 319
              if (had_eof) {
#line 321
                diag(1, "Unclosed comment", 0, 0);
#line 322
                exit(1);
              }
            }
#line 326
            tmp___8 = save_com.end;
#line 326
            (save_com.end) ++;
#line 326
            if ((int )*tmp___8 == 42) {
#line 326
              if ((int )*buf_ptr == 47) {
#line 327
                break;
              }
            }
          }
#line 330
          tmp___9 = save_com.end;
#line 330
          (save_com.end) ++;
#line 330
          *tmp___9 = (char )'/';
#line 331
          buf_ptr ++;
#line 331
          if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 332
            fill_buffer();
          }
#line 333
          break;
        }
      }
      default: ;
#line 336
      if (flushed_nl) {
#line 338
        force_nl = 1;
      }
#line 339
      if ((int )type_code == 21) {
#line 339
        if ((int )*token == 105) {
#line 339
          if (last_else) {
#line 339
            if (else_if) {
#line 344
              force_nl = 0;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 339
        if ((int )type_code == 22) {
#line 339
          if ((int )*token == 101) {
#line 339
            if ((unsigned int )e_code != (unsigned int )s_code) {
#line 339
              if ((int )*(e_code + -1) == 125) {
#line 344
                force_nl = 0;
              }
            }
          }
        }
      }
#line 346
      if ((unsigned int )save_com.end == (unsigned int )save_com.ptr) {
#line 349
        parser_state_tos->search_brace = 0;
        goto check_type;
      }
#line 352
      if (force_nl) {
#line 355
        force_nl = 0;
#line 356
        line_no --;
#line 358
        if ((save_com.end - save_com.ptr) + 2 >= save_com.size) {
#line 358
          cur_chars___1 = save_com.end - save_com.ptr;
#line 358
          save_com.size *= 2;
#line 358
          save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 358
          save_com.end = save_com.ptr + cur_chars___1;
        }
#line 359
        tmp___10 = save_com.end;
#line 359
        (save_com.end) ++;
#line 359
        *tmp___10 = (char )'\n';
#line 360
        tmp___11 = save_com.end;
#line 360
        (save_com.end) ++;
#line 360
        *tmp___11 = (char )' ';
#line 361
        if (verbose) {
#line 361
          if (! flushed_nl) {
#line 364
            diag(0, "Line broken", 0, 0);
          }
        }
#line 365
        flushed_nl = 0;
      }
#line 367
      t_ptr = token;
#line 367
      while ((unsigned int )t_ptr < (unsigned int )token_end) {
#line 369
        if ((save_com.end - save_com.ptr) + 1 >= save_com.size) {
#line 369
          cur_chars___2 = save_com.end - save_com.ptr;
#line 369
          save_com.size *= 2;
#line 369
          save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 369
          save_com.end = save_com.ptr + cur_chars___2;
        }
#line 370
        tmp___12 = save_com.end;
#line 370
        (save_com.end) ++;
#line 370
        *tmp___12 = *t_ptr;
#line 367
        t_ptr ++;
      }
#line 373
      parser_state_tos->procname = (char *)"\000";
      sw_buffer: 
#line 376
      parser_state_tos->search_brace = 0;
#line 378
      bp_save = buf_ptr;
#line 379
      be_save = buf_end;
#line 380
      buf_ptr = save_com.ptr;
#line 383
      if ((save_com.end - save_com.ptr) + 1 >= save_com.size) {
#line 383
        cur_chars___3 = save_com.end - save_com.ptr;
#line 383
        save_com.size *= 2;
#line 383
        save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 383
        save_com.end = save_com.ptr + cur_chars___3;
      }
#line 384
      tmp___13 = save_com.end;
#line 384
      (save_com.end) ++;
#line 384
      *tmp___13 = (char )' ';
#line 385
      buf_end = save_com.end;
#line 386
      save_com.end = save_com.ptr;
#line 387
      break;
      }
#line 391
      if ((int )type_code != 0) {
#line 392
        type_code = lexi();
      }
#line 395
      is_procname = (int )*(parser_state_tos->procname + 0);
#line 395
      if (is_procname) {
#line 395
        if (flushed_nl) {
#line 395
          if (! procnames_start_line) {
#line 395
            if (parser_state_tos->in_decl) {
#line 395
              if ((int )type_code == 13) {
#line 398
                flushed_nl = 0;
              }
            }
          }
        }
      }
    }
#line 400
    last_else = 0;
    check_type: 
#line 403
    if ((int )type_code == 0) {
#line 405
      if ((unsigned int )s_lab != (unsigned int )e_lab) {
#line 407
        dump_line();
      } else {
#line 405
        if ((unsigned int )s_code != (unsigned int )e_code) {
#line 407
          dump_line();
        } else {
#line 405
          if ((unsigned int )s_com != (unsigned int )e_com) {
#line 407
            dump_line();
          }
        }
      }
#line 408
      if (parser_state_tos->tos > 1) {
#line 409
        diag(1, "Stuff missing from end of file.", 0, 0);
      }
#line 411
      if (verbose) {
#line 413
        printf((char const   * __restrict  )"There were %d output lines and %d comments\n",
               out_lines, out_coms);
#line 415
        if (com_lines > 0) {
#line 415
          if (code_lines > 0) {
#line 416
            printf((char const   * __restrict  )"(Lines with comments)/(Lines with code): %6.3f\n",
                   (1.0 * (double )com_lines) / (double )code_lines);
          }
        }
      }
#line 419
      fflush(output);
#line 420
      if (found_err) {
#line 421
        exit(found_err);
      }
#line 423
      return;
    }
#line 426
    if ((int )type_code != 15) {
#line 426
      if ((int )type_code != 16) {
#line 426
        if ((int )type_code != 1) {
#line 426
          if ((int )type_code != 18) {
#line 426
            if ((int )type_code != 19) {
#line 432
              if (force_nl) {
#line 432
                if ((int )type_code != 10) {
#line 432
                  if ((int )type_code != 11) {
                    goto _L___3;
                  } else {
#line 432
                    if (! btype_2) {
                      _L___3: /* CIL Label */ 
#line 437
                      if (verbose) {
#line 437
                        if (! flushed_nl) {
#line 438
                          diag(0, "Line broken", 0, 0);
                        }
                      }
#line 439
                      flushed_nl = 0;
#line 440
                      dump_line();
#line 441
                      parser_state_tos->want_blank = 0;
#line 443
                      force_nl = 0;
                    }
                  }
                }
              }
#line 445
              parser_state_tos->in_stmt = 1;
#line 449
              if ((unsigned int )s_com != (unsigned int )e_com) {
#line 455
                if ((unsigned int )e_code != (unsigned int )s_code) {
#line 457
                  tmp___14 = e_code;
#line 457
                  e_code ++;
#line 457
                  *tmp___14 = (char )' ';
#line 458
                  embedded_comment_on_line = 2;
                } else {
#line 461
                  embedded_comment_on_line = 1;
                }
#line 463
                t_ptr = s_com;
#line 463
                while (*t_ptr) {
#line 465
                  if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 465
                    nsize = (l_code - s_code) + 400;
#line 465
                    tmp___15 = xrealloc(codebuf, nsize);
#line 465
                    codebuf = tmp___15;
#line 465
                    e_code = (codebuf + (e_code - s_code)) + 1;
#line 465
                    l_code = (codebuf + nsize) - 5;
#line 465
                    s_code = codebuf + 1;
                  }
#line 466
                  tmp___16 = e_code;
#line 466
                  e_code ++;
#line 466
                  *tmp___16 = *t_ptr;
#line 463
                  t_ptr ++;
                }
#line 468
                tmp___17 = e_code;
#line 468
                e_code ++;
#line 468
                *tmp___17 = (char )' ';
#line 469
                *e_code = (char )'\000';
#line 470
                parser_state_tos->want_blank = 0;
#line 471
                e_com = s_com;
              }
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      _L___7: /* CIL Label */ 
#line 474
      if ((int )type_code != 15) {
#line 474
        if ((int )type_code != 16) {
#line 478
          force_nl = 0;
        }
      }
    }
#line 485
    if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 485
      nsize___0 = (l_code - s_code) + 400;
#line 485
      tmp___18 = xrealloc(codebuf, nsize___0);
#line 485
      codebuf = tmp___18;
#line 485
      e_code = (codebuf + (e_code - s_code)) + 1;
#line 485
      l_code = (codebuf + nsize___0) - 5;
#line 485
      s_code = codebuf + 1;
    }
#line 486
    switch ((int )type_code) {
    case 19: 
#line 490
    parser_state_tos->use_ff = 1;
#line 492
    dump_line();
#line 493
    parser_state_tos->want_blank = 0;
#line 494
    break;
    case 1: 
#line 497
    if ((int )parser_state_tos->last_token != 14) {
      goto _L___9;
    } else {
#line 497
      if (! leave_comma) {
        goto _L___9;
      } else {
#line 497
        if (! break_comma) {
          goto _L___9;
        } else {
#line 497
          if (parser_state_tos->p_l_follow > 0) {
            goto _L___9;
          } else {
#line 497
            if (parser_state_tos->block_init) {
              goto _L___9;
            } else {
#line 497
              if ((unsigned int )s_com != (unsigned int )e_com) {
                _L___9: /* CIL Label */ 
#line 497
                if ((int )parser_state_tos->last_token != 12) {
#line 507
                  dump_line();
#line 508
                  parser_state_tos->want_blank = 0;
                } else {
#line 497
                  if (! btype_2) {
#line 507
                    dump_line();
#line 508
                    parser_state_tos->want_blank = 0;
                  } else {
#line 497
                    if (! parser_state_tos->in_decl) {
#line 507
                      dump_line();
#line 508
                      parser_state_tos->want_blank = 0;
                    } else {
                      goto _L___8;
                    }
                  }
                }
              } else {
                _L___8: /* CIL Label */ 
#line 497
                tmp___19 = compute_code_target();
#line 497
                if (tmp___19 + (e_code - s_code) > max_col - tabsize) {
#line 507
                  dump_line();
#line 508
                  parser_state_tos->want_blank = 0;
                }
              }
            }
          }
        }
      }
    }
#line 512
    else_or_endif = 0;
#line 513
    line_no ++;
#line 514
    break;
    case 2: 
#line 527
    if ((int )*(token + 0) == 123) {
#line 527
      if ((unsigned int )s_code != (unsigned int )e_code) {
#line 530
        dump_line();
#line 532
        parser_state_tos->want_blank = 0;
      } else {
#line 527
        if ((unsigned int )s_com != (unsigned int )e_com) {
#line 530
          dump_line();
#line 532
          parser_state_tos->want_blank = 0;
        } else {
#line 527
          if ((unsigned int )s_lab != (unsigned int )e_lab) {
#line 530
            dump_line();
#line 532
            parser_state_tos->want_blank = 0;
          }
        }
      }
    }
#line 536
    (parser_state_tos->p_l_follow) ++;
#line 536
    if (parser_state_tos->p_l_follow >= parser_state_tos->paren_indents_size) {
#line 539
      parser_state_tos->paren_indents_size *= 2;
#line 540
      tmp___20 = xrealloc((char *)parser_state_tos->paren_indents, (unsigned int )parser_state_tos->paren_indents_size * sizeof(short ));
#line 540
      parser_state_tos->paren_indents = (short *)tmp___20;
    }
#line 545
    (parser_state_tos->paren_depth) ++;
#line 546
    if (parser_state_tos->want_blank) {
#line 546
      if ((int )*token != 91) {
#line 546
        if ((int )parser_state_tos->last_token != 13) {
#line 551
          tmp___21 = e_code;
#line 551
          e_code ++;
#line 551
          *tmp___21 = (char )' ';
        } else {
#line 546
          if (proc_calls_space) {
#line 551
            tmp___21 = e_code;
#line 551
            e_code ++;
#line 551
            *tmp___21 = (char )' ';
          } else {
#line 546
            if (parser_state_tos->its_a_keyword) {
#line 546
              if (! parser_state_tos->sizeof_keyword) {
#line 551
                tmp___21 = e_code;
#line 551
                e_code ++;
#line 551
                *tmp___21 = (char )' ';
              } else {
#line 546
                if (blank_after_sizeof) {
#line 551
                  tmp___21 = e_code;
#line 551
                  e_code ++;
#line 551
                  *tmp___21 = (char )' ';
                }
              }
            }
          }
        }
      }
    }
#line 553
    if (parser_state_tos->in_decl) {
#line 553
      if (! parser_state_tos->block_init) {
#line 555
        if (troff) {
#line 555
          if (! parser_state_tos->dumped_decl_indent) {
#line 555
            if (! is_procname) {
#line 555
              if ((int )parser_state_tos->last_token == 20) {
#line 560
                parser_state_tos->dumped_decl_indent = 1;
#line 561
                sprintf((char * __restrict  )e_code, (char const   * __restrict  )"\n.Du %dp+\200p \"%.*s\"\n",
                        dec_ind * 7, token_end - token, token);
#line 564
                tmp___22 = strlen(e_code);
#line 564
                e_code += tmp___22;
              } else {
                goto _L___12;
              }
            } else {
              goto _L___12;
            }
          } else {
            goto _L___12;
          }
        } else {
          _L___12: /* CIL Label */ 
#line 566
          if ((int )*token != 91) {
#line 568
            while (e_code - s_code < dec_ind) {
#line 570
              if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 570
                nsize___1 = (l_code - s_code) + 400;
#line 570
                tmp___23 = xrealloc(codebuf, nsize___1);
#line 570
                codebuf = tmp___23;
#line 570
                e_code = (codebuf + (e_code - s_code)) + 1;
#line 570
                l_code = (codebuf + nsize___1) - 5;
#line 570
                s_code = codebuf + 1;
              }
#line 571
              tmp___24 = e_code;
#line 571
              e_code ++;
#line 571
              *tmp___24 = (char )' ';
            }
#line 573
            tmp___25 = e_code;
#line 573
            e_code ++;
#line 573
            *tmp___25 = *(token + 0);
          } else {
#line 576
            tmp___26 = e_code;
#line 576
            e_code ++;
#line 576
            *tmp___26 = *(token + 0);
          }
        }
      } else {
#line 579
        tmp___27 = e_code;
#line 579
        e_code ++;
#line 579
        *tmp___27 = *(token + 0);
      }
    } else {
#line 579
      tmp___27 = e_code;
#line 579
      e_code ++;
#line 579
      *tmp___27 = *(token + 0);
    }
#line 581
    *(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) = (short )(e_code - s_code);
#line 583
    if (sp_sw) {
#line 583
      if (parser_state_tos->p_l_follow == 1) {
#line 583
        if (extra_expression_indent) {
#line 583
          if ((int )*(parser_state_tos->paren_indents + 0) < 2 * ind_size) {
#line 586
            *(parser_state_tos->paren_indents + 0) = (short )(2 * ind_size);
          }
        }
      }
    }
#line 587
    parser_state_tos->want_blank = 0;
#line 589
    if (parser_state_tos->in_or_st) {
#line 589
      if ((int )*token == 40) {
#line 589
        if (parser_state_tos->tos <= 2) {
#line 596
          parse_lparen_in_decl();
#line 599
          parser_state_tos->in_or_st = 0;
        }
      }
    }
#line 601
    if (parser_state_tos->sizeof_keyword) {
#line 602
      parser_state_tos->sizeof_mask |= 1 << parser_state_tos->p_l_follow;
    }
#line 606
    if ((int )parser_state_tos->last_token == 20) {
#line 609
      parser_state_tos->noncast_mask |= 1 << parser_state_tos->p_l_follow;
    } else {
#line 606
      if ((int )parser_state_tos->last_token == 13) {
#line 606
        if ((int )parser_state_tos->last_rw != 9) {
#line 609
          parser_state_tos->noncast_mask |= 1 << parser_state_tos->p_l_follow;
        } else {
#line 612
          parser_state_tos->noncast_mask &= ~ (1 << parser_state_tos->p_l_follow);
        }
      } else {
#line 612
        parser_state_tos->noncast_mask &= ~ (1 << parser_state_tos->p_l_follow);
      }
    }
#line 615
    break;
    case 3: 
#line 618
    (parser_state_tos->paren_depth) --;
#line 619
    if ((parser_state_tos->cast_mask & (1 << parser_state_tos->p_l_follow)) & ~ parser_state_tos->sizeof_mask) {
#line 623
      parser_state_tos->last_u_d = 1;
#line 624
      parser_state_tos->cast_mask &= (1 << parser_state_tos->p_l_follow) - 1;
#line 626
      if (! parser_state_tos->cast_mask) {
#line 626
        if (cast_space) {
#line 627
          parser_state_tos->want_blank = 1;
        } else {
#line 629
          parser_state_tos->want_blank = 0;
        }
      } else {
#line 629
        parser_state_tos->want_blank = 0;
      }
    } else {
#line 631
      if (parser_state_tos->in_decl) {
#line 631
        if (! parser_state_tos->block_init) {
#line 631
          if (parser_state_tos->paren_depth == 0) {
#line 634
            parser_state_tos->want_blank = 1;
          }
        }
      }
    }
#line 636
    parser_state_tos->sizeof_mask &= (1 << parser_state_tos->p_l_follow) - 1;
#line 638
    (parser_state_tos->p_l_follow) --;
#line 638
    if (parser_state_tos->p_l_follow < 0) {
#line 640
      parser_state_tos->p_l_follow = 0;
#line 641
      diag(0, "Extra %c", (int )*token, 0);
    }
#line 645
    if ((unsigned int )e_code == (unsigned int )s_code) {
#line 647
      level = parser_state_tos->p_l_follow;
#line 648
      parser_state_tos->paren_level = level;
#line 649
      if (level > 0) {
#line 650
        paren_target = - ((int )*(parser_state_tos->paren_indents + (level - 1)));
      } else {
#line 652
        paren_target = 0;
      }
    }
#line 654
    tmp___28 = e_code;
#line 654
    e_code ++;
#line 654
    *tmp___28 = *(token + 0);
#line 662
    if (sp_sw) {
#line 662
      if (parser_state_tos->p_l_follow == 0) {
#line 670
        if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) != 30) {
#line 672
          last_token_ends_sp = 2;
        }
#line 673
        sp_sw = 0;
#line 674
        force_nl = 1;
#line 675
        parser_state_tos->last_u_d = 1;
#line 678
        parser_state_tos->in_stmt = 0;
#line 682
        parse(hd_type);
      }
    }
#line 684
    parser_state_tos->search_brace = btype_2;
#line 690
    break;
    case 4: 
#line 693
    if (parser_state_tos->want_blank) {
#line 694
      tmp___29 = e_code;
#line 694
      e_code ++;
#line 694
      *tmp___29 = (char )' ';
    }
#line 696
    if (troff) {
#line 696
      if (! parser_state_tos->dumped_decl_indent) {
#line 696
        if (parser_state_tos->in_decl) {
#line 696
          if (! is_procname) {
#line 700
            sprintf((char * __restrict  )e_code, (char const   * __restrict  )"\n.Du %dp+\200p \"%.*s\"\n",
                    dec_ind * 7, token_end - token, token);
#line 703
            parser_state_tos->dumped_decl_indent = 1;
#line 704
            tmp___30 = strlen(e_code);
#line 704
            e_code += tmp___30;
          } else {
            goto _L___15;
          }
        } else {
          goto _L___15;
        }
      } else {
        goto _L___15;
      }
    } else {
      _L___15: /* CIL Label */ 
#line 708
      res = token;
#line 709
      res_end = token_end;
#line 713
      if (parser_state_tos->paren_depth == 0) {
#line 713
        if (parser_state_tos->in_decl) {
#line 713
          if (! parser_state_tos->block_init) {
#line 717
            while (e_code - s_code < dec_ind - (token_end - token)) {
#line 719
              if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 719
                nsize___2 = (l_code - s_code) + 400;
#line 719
                tmp___31 = xrealloc(codebuf, nsize___2);
#line 719
                codebuf = tmp___31;
#line 719
                e_code = (codebuf + (e_code - s_code)) + 1;
#line 719
                l_code = (codebuf + nsize___2) - 5;
#line 719
                s_code = codebuf + 1;
              }
#line 720
              tmp___32 = e_code;
#line 720
              e_code ++;
#line 720
              *tmp___32 = (char )' ';
            }
          }
        }
      }
#line 724
      if (troff) {
#line 724
        if ((int )*(token + 0) == 45) {
#line 724
          if ((int )*(token + 1) == 62) {
#line 727
            res = resval;
#line 728
            res_end = res + sizeof(resval);
          }
        }
      }
#line 731
      t_ptr = res;
#line 731
      while ((unsigned int )t_ptr < (unsigned int )res_end) {
#line 733
        if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 733
          nsize___3 = (l_code - s_code) + 400;
#line 733
          tmp___33 = xrealloc(codebuf, nsize___3);
#line 733
          codebuf = tmp___33;
#line 733
          e_code = (codebuf + (e_code - s_code)) + 1;
#line 733
          l_code = (codebuf + nsize___3) - 5;
#line 733
          s_code = codebuf + 1;
        }
#line 734
        tmp___34 = e_code;
#line 734
        e_code ++;
#line 734
        *tmp___34 = *t_ptr;
#line 731
        t_ptr ++;
      }
    }
#line 737
    parser_state_tos->want_blank = 0;
#line 738
    break;
    case 5: 
#line 741
    if (parser_state_tos->want_blank) {
#line 743
      tmp___35 = e_code;
#line 743
      e_code ++;
#line 743
      *tmp___35 = (char )' ';
    } else {
#line 741
      if ((unsigned int )e_code > (unsigned int )s_code) {
#line 741
        if ((int )*e_code != 32) {
#line 743
          tmp___35 = e_code;
#line 743
          e_code ++;
#line 743
          *tmp___35 = (char )' ';
        }
      }
    }
#line 746
    res___0 = token;
#line 747
    res_end___0 = token_end;
#line 755
    if (troff) {
#line 756
      switch ((int )*(token + 0)) {
      case 60: 
#line 759
      if ((int )*(token + 1) == 61) {
#line 760
        res___0 = resval___0;
#line 760
        res_end___0 = res___0 + sizeof(resval___0);
      }
#line 761
      break;
      case 62: 
#line 763
      if ((int )*(token + 1) == 61) {
#line 764
        res___0 = resval___1;
#line 764
        res_end___0 = res___0 + sizeof(resval___1);
      }
#line 765
      break;
      case 33: 
#line 767
      if ((int )*(token + 1) == 61) {
#line 768
        res___0 = resval___2;
#line 768
        res_end___0 = res___0 + sizeof(resval___2);
      }
#line 769
      break;
      case 124: 
#line 771
      if ((int )*(token + 1) == 124) {
#line 773
        res___0 = resval___3;
#line 773
        res_end___0 = res___0 + sizeof(resval___3);
      } else {
#line 775
        if ((int )*(token + 1) == 0) {
#line 776
          res___0 = resval___4;
#line 776
          res_end___0 = res___0 + sizeof(resval___4);
        }
      }
#line 777
      break;
      }
    }
#line 780
    t_ptr = res___0;
#line 780
    while ((unsigned int )t_ptr < (unsigned int )res_end___0) {
#line 782
      if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 782
        nsize___4 = (l_code - s_code) + 400;
#line 782
        tmp___36 = xrealloc(codebuf, nsize___4);
#line 782
        codebuf = tmp___36;
#line 782
        e_code = (codebuf + (e_code - s_code)) + 1;
#line 782
        l_code = (codebuf + nsize___4) - 5;
#line 782
        s_code = codebuf + 1;
      }
#line 783
      tmp___37 = e_code;
#line 783
      e_code ++;
#line 783
      *tmp___37 = *t_ptr;
#line 780
      t_ptr ++;
    }
#line 786
    parser_state_tos->want_blank = 1;
#line 787
    break;
    case 6: 
#line 790
    tmp___38 = e_code;
#line 790
    e_code ++;
#line 790
    *tmp___38 = *(token + 0);
#line 791
    tmp___39 = e_code;
#line 791
    e_code ++;
#line 791
    *tmp___39 = *(token + 1);
#line 792
    parser_state_tos->want_blank = 1;
#line 793
    break;
    case 7: 
#line 796
    squest ++;
#line 799
    if (parser_state_tos->want_blank) {
#line 800
      tmp___40 = e_code;
#line 800
      e_code ++;
#line 800
      *tmp___40 = (char )' ';
    }
#line 801
    tmp___41 = e_code;
#line 801
    e_code ++;
#line 801
    *tmp___41 = (char )'?';
#line 802
    parser_state_tos->want_blank = 1;
#line 803
    break;
    case 8: 
#line 806
    scase = 1;
    goto copy_id;
    case 9: 
#line 811
    if (squest > 0) {
#line 813
      squest --;
#line 814
      if (parser_state_tos->want_blank) {
#line 815
        tmp___42 = e_code;
#line 815
        e_code ++;
#line 815
        *tmp___42 = (char )' ';
      }
#line 816
      tmp___43 = e_code;
#line 816
      e_code ++;
#line 816
      *tmp___43 = (char )':';
#line 817
      parser_state_tos->want_blank = 1;
#line 818
      break;
    }
#line 820
    if (parser_state_tos->in_decl) {
#line 822
      tmp___44 = e_code;
#line 822
      e_code ++;
#line 822
      *tmp___44 = (char )':';
#line 823
      parser_state_tos->want_blank = 0;
#line 824
      break;
    }
#line 826
    parser_state_tos->in_stmt = 0;
#line 828
    t_ptr = s_code;
#line 828
    while (*t_ptr) {
#line 829
      tmp___45 = e_lab;
#line 829
      e_lab ++;
#line 829
      *tmp___45 = *t_ptr;
#line 828
      t_ptr ++;
    }
#line 830
    e_code = s_code;
#line 831
    tmp___46 = e_lab;
#line 831
    e_lab ++;
#line 831
    *tmp___46 = (char )':';
#line 832
    tmp___47 = e_lab;
#line 832
    e_lab ++;
#line 832
    *tmp___47 = (char )' ';
#line 833
    *e_lab = (char )'\000';
#line 837
    parser_state_tos->pcase = scase;
#line 837
    force_nl = parser_state_tos->pcase;
#line 838
    scase = 0;
#line 839
    parser_state_tos->want_blank = 0;
#line 840
    break;
    case 10: 
#line 844
    parser_state_tos->in_or_st = 0;
#line 845
    scase = 0;
#line 846
    squest = 0;
#line 853
    parser_state_tos->cast_mask = 0;
#line 854
    parser_state_tos->sizeof_mask = 0;
#line 855
    parser_state_tos->block_init = 0;
#line 856
    parser_state_tos->block_init_level = 0;
#line 857
    (parser_state_tos->just_saw_decl) --;
#line 859
    if (parser_state_tos->in_decl) {
#line 859
      if ((unsigned int )s_code == (unsigned int )e_code) {
#line 859
        if (! parser_state_tos->block_init) {
#line 862
          while (e_code - s_code < dec_ind - 1) {
#line 864
            if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 864
              nsize___5 = (l_code - s_code) + 400;
#line 864
              tmp___48 = xrealloc(codebuf, nsize___5);
#line 864
              codebuf = tmp___48;
#line 864
              e_code = (codebuf + (e_code - s_code)) + 1;
#line 864
              l_code = (codebuf + nsize___5) - 5;
#line 864
              s_code = codebuf + 1;
            }
#line 865
            tmp___49 = e_code;
#line 865
            e_code ++;
#line 865
            *tmp___49 = (char )' ';
          }
        }
      }
    }
#line 870
    parser_state_tos->in_decl = parser_state_tos->dec_nest > 0;
#line 895
    if (last_token_ends_sp) {
#line 895
      if (space_sp_semicolon) {
#line 897
        tmp___50 = e_code;
#line 897
        e_code ++;
#line 897
        *tmp___50 = (char )' ';
      }
    }
#line 899
    tmp___51 = e_code;
#line 899
    e_code ++;
#line 899
    *tmp___51 = (char )';';
#line 900
    parser_state_tos->want_blank = 1;
#line 902
    parser_state_tos->in_stmt = parser_state_tos->p_l_follow > 0;
#line 904
    if (! sp_sw) {
#line 906
      parse(10);
#line 907
      force_nl = 1;
    }
#line 909
    break;
    case 11: 
#line 912
    parser_state_tos->in_stmt = 0;
#line 913
    if (! parser_state_tos->block_init) {
#line 914
      force_nl = 1;
    } else {
#line 916
      if (parser_state_tos->block_init_level <= 0) {
#line 917
        parser_state_tos->block_init_level = 1;
      } else {
#line 919
        (parser_state_tos->block_init_level) ++;
      }
    }
#line 921
    if ((unsigned int )s_code != (unsigned int )e_code) {
#line 921
      if (! parser_state_tos->block_init) {
#line 923
        if (! btype_2) {
#line 925
          dump_line();
#line 926
          parser_state_tos->want_blank = 0;
        } else {
#line 930
          if (parser_state_tos->in_parameter_declaration) {
#line 930
            if (! parser_state_tos->in_or_st) {
#line 933
              parser_state_tos->i_l_follow = 0;
#line 934
              dump_line();
#line 935
              parser_state_tos->want_blank = 0;
            } else {
#line 938
              parser_state_tos->want_blank = 1;
            }
          } else {
#line 938
            parser_state_tos->want_blank = 1;
          }
        }
      }
    }
#line 941
    if (parser_state_tos->in_parameter_declaration) {
#line 942
      prefix_blankline_requested = 0;
    }
#line 958
    if ((unsigned int )s_code == (unsigned int )e_code) {
#line 959
      parser_state_tos->ind_stmt = 0;
    }
#line 961
    if (parser_state_tos->in_decl) {
#line 961
      if (parser_state_tos->in_or_st) {
#line 964
        if (parser_state_tos->dec_nest >= di_stack_alloc) {
#line 966
          di_stack_alloc *= 2;
#line 967
          tmp___52 = xrealloc((char *)di_stack, (unsigned int )di_stack_alloc * sizeof(*di_stack));
#line 967
          di_stack = (int *)tmp___52;
        }
#line 971
        tmp___53 = parser_state_tos->dec_nest;
#line 971
        (parser_state_tos->dec_nest) ++;
#line 971
        *(di_stack + tmp___53) = dec_ind;
      } else {
#line 976
        parser_state_tos->in_decl = 0;
#line 977
        parser_state_tos->decl_on_line = 0;
#line 989
        parser_state_tos->in_parameter_declaration = 0;
      }
    } else {
#line 976
      parser_state_tos->in_decl = 0;
#line 977
      parser_state_tos->decl_on_line = 0;
#line 989
      parser_state_tos->in_parameter_declaration = 0;
    }
#line 991
    dec_ind = 0;
#line 996
    parser_state_tos->in_or_st = 0;
#line 998
    parse(11);
#line 999
    if (parser_state_tos->want_blank) {
#line 1002
      tmp___54 = e_code;
#line 1002
      e_code ++;
#line 1002
      *tmp___54 = (char )' ';
    }
#line 1003
    parser_state_tos->want_blank = 0;
#line 1004
    tmp___55 = e_code;
#line 1004
    e_code ++;
#line 1004
    *tmp___55 = (char )'{';
#line 1005
    parser_state_tos->just_saw_decl = 0;
#line 1006
    break;
    case 12: 
#line 1010
    if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 20) {
#line 1010
      if (! parser_state_tos->block_init) {
#line 1012
        parse(10);
      }
    }
#line 1023
    parser_state_tos->just_saw_decl = 0;
#line 1024
    (parser_state_tos->block_init_level) --;
#line 1025
    if ((unsigned int )s_code != (unsigned int )e_code) {
#line 1025
      if (! parser_state_tos->block_init) {
#line 1027
        if (verbose) {
#line 1028
          diag(0, "Line broken", 0, 0);
        }
#line 1029
        dump_line();
      }
    }
#line 1031
    tmp___56 = e_code;
#line 1031
    e_code ++;
#line 1031
    *tmp___56 = (char )'}';
#line 1032
    parser_state_tos->want_blank = 1;
#line 1033
    parser_state_tos->ind_stmt = 0;
#line 1033
    parser_state_tos->in_stmt = parser_state_tos->ind_stmt;
#line 1034
    if (parser_state_tos->dec_nest > 0) {
#line 1037
      (parser_state_tos->dec_nest) --;
#line 1037
      dec_ind = *(di_stack + parser_state_tos->dec_nest);
#line 1038
      if (parser_state_tos->dec_nest == 0) {
#line 1038
        if (! parser_state_tos->in_parameter_declaration) {
#line 1040
          parser_state_tos->just_saw_decl = 2;
        }
      }
#line 1041
      parser_state_tos->in_decl = 1;
    }
#line 1043
    prefix_blankline_requested = 0;
#line 1044
    parse(12);
#line 1045
    if (cuddle_else) {
#line 1045
      if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 32) {
#line 1045
        tmp___57 = 1;
      } else {
#line 1045
        tmp___57 = 0;
      }
    } else {
#line 1045
      tmp___57 = 0;
    }
#line 1045
    parser_state_tos->search_brace = tmp___57;
#line 1049
    if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 27) {
#line 1049
      if ((int )parser_state_tos->last_rw != 4) {
#line 1049
        if ((int )parser_state_tos->last_rw != 5) {
#line 1056
          force_nl = 1;
        } else {
          goto _L___18;
        }
      } else {
        _L___18: /* CIL Label */ 
#line 1049
        if (! btype_2) {
#line 1056
          force_nl = 1;
        } else {
          goto _L___17;
        }
      }
    } else {
      _L___17: /* CIL Label */ 
#line 1049
      if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 32) {
#line 1056
        force_nl = 1;
      } else {
#line 1049
        if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 30) {
#line 1049
          if (! btype_2) {
#line 1056
            force_nl = 1;
          } else {
            goto _L___16;
          }
        } else {
          _L___16: /* CIL Label */ 
#line 1057
          if (parser_state_tos->tos <= 1) {
#line 1057
            if (blanklines_after_procs) {
#line 1057
              if (parser_state_tos->dec_nest <= 0) {
#line 1060
                postfix_blankline_requested = 1;
              }
            }
          }
        }
      }
    }
#line 1070
    break;
    case 17: 
#line 1073
    sp_sw = 1;
#line 1074
    hd_type = 17;
#line 1076
    parser_state_tos->in_decl = 0;
    goto copy_id;
    case 21: 
#line 1080
    sp_sw = 1;
#line 1082
    if ((int )*token == 105) {
#line 1082
      hd_type = 23;
    } else {
#line 1082
      if ((int )*token == 119) {
#line 1082
        hd_type = 24;
      } else {
#line 1082
        hd_type = 25;
      }
    }
    goto copy_id;
    case 22: 
#line 1089
    parser_state_tos->in_stmt = 0;
#line 1090
    if ((int )*token == 101) {
#line 1092
      if ((unsigned int )e_code != (unsigned int )s_code) {
#line 1092
        if (! cuddle_else) {
          goto _L___19;
        } else {
#line 1092
          if ((int )*(e_code + -1) != 125) {
            _L___19: /* CIL Label */ 
#line 1094
            if (verbose) {
#line 1095
              diag(0, "Line broken", 0, 0);
            }
#line 1096
            dump_line();
#line 1097
            parser_state_tos->want_blank = 0;
          }
        }
      }
#line 1099
      force_nl = 1;
#line 1101
      last_else = 1;
#line 1102
      parse(28);
    } else {
#line 1106
      if ((unsigned int )e_code != (unsigned int )s_code) {
#line 1108
        if (verbose) {
#line 1109
          diag(0, "Line broken", 0, 0);
        }
#line 1110
        dump_line();
#line 1111
        parser_state_tos->want_blank = 0;
      }
#line 1113
      force_nl = 1;
#line 1115
      last_else = 0;
#line 1116
      parse(29);
    }
    goto copy_id;
    case 20: 
#line 1123
    if (! parser_state_tos->sizeof_mask) {
#line 1124
      parse(20);
    }
#line 1126
    if ((int )parser_state_tos->last_token == 3) {
#line 1126
      if (parser_state_tos->tos <= 1) {
#line 1129
        parser_state_tos->in_parameter_declaration = 1;
#line 1130
        if ((unsigned int )s_code != (unsigned int )e_code) {
#line 1132
          dump_line();
#line 1133
          parser_state_tos->want_blank = 0;
        }
      }
    }
#line 1136
    if (parser_state_tos->in_parameter_declaration) {
#line 1136
      if (indent_parameters) {
#line 1136
        if (parser_state_tos->dec_nest == 0) {
#line 1136
          if (parser_state_tos->p_l_follow == 0) {
#line 1141
            parser_state_tos->i_l_follow = indent_parameters;
#line 1141
            parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 1143
            parser_state_tos->ind_stmt = 0;
          }
        }
      }
    }
#line 1148
    if (! parser_state_tos->paren_depth) {
#line 1149
      parser_state_tos->in_or_st = 1;
    }
#line 1151
    parser_state_tos->decl_on_line = 1;
#line 1151
    parser_state_tos->in_decl = parser_state_tos->decl_on_line;
#line 1155
    if (parser_state_tos->dec_nest <= 0) {
#line 1156
      parser_state_tos->just_saw_decl = 2;
    }
#line 1157
    if (prefix_blankline_requested) {
#line 1157
      if (parser_state_tos->block_init != 0) {
#line 1164
        prefix_blankline_requested = 0;
      } else {
#line 1157
        if (parser_state_tos->block_init_level != -1) {
#line 1164
          prefix_blankline_requested = 0;
        } else {
#line 1157
          if ((int )parser_state_tos->last_token != 12) {
#line 1164
            prefix_blankline_requested = 0;
          } else {
#line 1157
            if ((unsigned int )e_code != (unsigned int )s_code) {
#line 1164
              prefix_blankline_requested = 0;
            } else {
#line 1157
              if ((unsigned int )e_lab != (unsigned int )s_lab) {
#line 1164
                prefix_blankline_requested = 0;
              } else {
#line 1157
                if ((unsigned int )e_com != (unsigned int )s_com) {
#line 1164
                  prefix_blankline_requested = 0;
                }
              }
            }
          }
        }
      }
    }
#line 1165
    i = (token_end - token) + 1;
#line 1169
    if (decl_indent > 0) {
#line 1169
      dec_ind = decl_indent;
    } else {
#line 1169
      dec_ind = i;
    }
    goto copy_id;
    case 13: 
#line 1175
    if (parser_state_tos->in_decl) {
#line 1175
      if (parser_state_tos->p_l_follow == 0) {
#line 1175
        if ((int )parser_state_tos->last_token != 12) {
#line 1179
          if (parser_state_tos->want_blank) {
#line 1180
            tmp___59 = e_code;
#line 1180
            e_code ++;
#line 1180
            *tmp___59 = (char )' ';
          }
#line 1181
          parser_state_tos->want_blank = 0;
#line 1182
          if (is_procname == 0) {
            goto _L___21;
          } else {
#line 1182
            if (! procnames_start_line) {
              _L___21: /* CIL Label */ 
#line 1184
              if (! parser_state_tos->block_init) {
#line 1185
                if (troff) {
#line 1185
                  if (! parser_state_tos->dumped_decl_indent) {
#line 1187
                    sprintf((char * __restrict  )e_code, (char const   * __restrict  )"\n.De %dp+\200p\n",
                            dec_ind * 7);
#line 1189
                    parser_state_tos->dumped_decl_indent = 1;
#line 1190
                    tmp___60 = strlen(e_code);
#line 1190
                    e_code += tmp___60;
                  } else {
                    goto _L___20;
                  }
                } else {
                  _L___20: /* CIL Label */ 
#line 1193
                  while (e_code - s_code < dec_ind) {
#line 1195
                    if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 1195
                      nsize___6 = (l_code - s_code) + 400;
#line 1195
                      tmp___61 = xrealloc(codebuf, nsize___6);
#line 1195
                      codebuf = tmp___61;
#line 1195
                      e_code = (codebuf + (e_code - s_code)) + 1;
#line 1195
                      l_code = (codebuf + nsize___6) - 5;
#line 1195
                      s_code = codebuf + 1;
                    }
#line 1196
                    tmp___62 = e_code;
#line 1196
                    e_code ++;
#line 1196
                    *tmp___62 = (char )' ';
                  }
                }
              }
            } else {
#line 1201
              if (dec_ind) {
#line 1201
                if ((unsigned int )s_code != (unsigned int )e_code) {
#line 1202
                  dump_line();
                }
              }
#line 1203
              dec_ind = 0;
#line 1204
              parser_state_tos->want_blank = 0;
            }
          }
        } else {
          goto _L___23;
        }
      } else {
        goto _L___23;
      }
    } else {
      _L___23: /* CIL Label */ 
#line 1207
      if (sp_sw) {
#line 1207
        if (parser_state_tos->p_l_follow == 0) {
#line 1209
          sp_sw = 0;
#line 1210
          force_nl = 1;
#line 1211
          parser_state_tos->last_u_d = 1;
#line 1212
          parser_state_tos->in_stmt = 0;
#line 1213
          parse(hd_type);
        }
      }
    }
    copy_id: 
#line 1216
    if (parser_state_tos->want_blank) {
#line 1217
      tmp___63 = e_code;
#line 1217
      e_code ++;
#line 1217
      *tmp___63 = (char )' ';
    }
#line 1218
    if (troff) {
#line 1218
      if (parser_state_tos->its_a_keyword) {
#line 1220
        e_code = chfont(& bodyf, & keywordf, e_code);
#line 1221
        t_ptr = token;
#line 1221
        while ((unsigned int )t_ptr < (unsigned int )token_end) {
#line 1223
          if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 1223
            nsize___7 = (l_code - s_code) + 400;
#line 1223
            tmp___64 = xrealloc(codebuf, nsize___7);
#line 1223
            codebuf = tmp___64;
#line 1223
            e_code = (codebuf + (e_code - s_code)) + 1;
#line 1223
            l_code = (codebuf + nsize___7) - 5;
#line 1223
            s_code = codebuf + 1;
          }
#line 1224
          tmp___65 = e_code;
#line 1224
          e_code ++;
#line 1225
          if (keywordf.allcaps) {
#line 1225
            tmp___73 = __ctype_b_loc();
#line 1225
            if ((int const   )*(*tmp___73 + (int )*t_ptr) & 512) {
#line 1225
              if (sizeof(*t_ptr) > 1U) {
#line 1225
                __res___0 = toupper((int )*t_ptr);
              } else {
#line 1225
                tmp___72 = __ctype_toupper_loc();
#line 1225
                __res___0 = (int )*(*tmp___72 + (int )*t_ptr);
              }
#line 1225
              *tmp___65 = (char )__res___0;
            } else {
#line 1225
              *tmp___65 = *t_ptr;
            }
          } else {
#line 1225
            *tmp___65 = *t_ptr;
          }
#line 1221
          t_ptr ++;
        }
#line 1227
        e_code = chfont(& keywordf, & bodyf, e_code);
      } else {
        goto _L___26;
      }
    } else {
      _L___26: /* CIL Label */ 
#line 1232
      if (troff) {
#line 1232
        if ((int )*token == 34) {
          goto _L___25;
        } else {
#line 1232
          if ((int )*token == 39) {
            _L___25: /* CIL Label */ 
#line 1236
            qchar = *token;
#line 1237
            tmp___74 = e_code;
#line 1237
            e_code ++;
#line 1237
            *tmp___74 = (char )'`';
#line 1238
            if ((int )qchar == 34) {
#line 1239
              tmp___75 = e_code;
#line 1239
              e_code ++;
#line 1239
              *tmp___75 = (char )'`';
            }
#line 1240
            e_code = chfont(& bodyf, & stringf, e_code);
#line 1242
            t_ptr = token + 1;
#line 1243
            while ((unsigned int )t_ptr < (unsigned int )token_end) {
#line 1245
              tmp___76 = t_ptr;
#line 1245
              t_ptr ++;
#line 1245
              *e_code = *tmp___76;
#line 1246
              if ((int )*e_code == 92) {
#line 1248
                e_code ++;
#line 1248
                *e_code = (char )'\\';
#line 1249
                if ((int )*t_ptr == 92) {
#line 1250
                  e_code ++;
#line 1250
                  *e_code = (char )'\\';
                }
#line 1252
                e_code ++;
#line 1252
                tmp___77 = t_ptr;
#line 1252
                t_ptr ++;
#line 1252
                *e_code = *tmp___77;
#line 1254
                e_code ++;
              }
            }
#line 1257
            e_code = chfont(& stringf, & bodyf, e_code - 1);
#line 1258
            if ((int )qchar == 34) {
#line 1259
              tmp___78 = e_code;
#line 1259
              e_code ++;
#line 1259
              *tmp___78 = (char )'\'';
            }
          } else {
            goto _L___24;
          }
        }
      } else {
        _L___24: /* CIL Label */ 
#line 1262
        t_ptr = token;
#line 1262
        while ((unsigned int )t_ptr < (unsigned int )token_end) {
#line 1264
          if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 1264
            nsize___8 = (l_code - s_code) + 400;
#line 1264
            tmp___79 = xrealloc(codebuf, nsize___8);
#line 1264
            codebuf = tmp___79;
#line 1264
            e_code = (codebuf + (e_code - s_code)) + 1;
#line 1264
            l_code = (codebuf + nsize___8) - 5;
#line 1264
            s_code = codebuf + 1;
          }
#line 1265
          tmp___80 = e_code;
#line 1265
          e_code ++;
#line 1265
          *tmp___80 = *t_ptr;
#line 1262
          t_ptr ++;
        }
      }
    }
#line 1268
    parser_state_tos->want_blank = 1;
#line 1272
    if (token_end - token == 6) {
#line 1272
      tmp___81 = strncmp(token, "va_dcl", 6);
#line 1272
      if (tmp___81 == 0) {
#line 1275
        parser_state_tos->in_or_st = 0;
#line 1276
        (parser_state_tos->just_saw_decl) --;
#line 1277
        parser_state_tos->in_decl = 0;
#line 1278
        parse(10);
#line 1279
        force_nl = 1;
      }
    }
#line 1281
    break;
    case 34: 
#line 1285
    tmp___82 = e_code;
#line 1285
    e_code ++;
#line 1285
    *tmp___82 = (char )'.';
#line 1286
    parser_state_tos->want_blank = 0;
#line 1288
    break;
    case 14: 
#line 1292
    parser_state_tos->want_blank = (unsigned int )s_code != (unsigned int )e_code;
#line 1293
    if (parser_state_tos->paren_depth == 0) {
#line 1293
      if (parser_state_tos->in_decl) {
#line 1293
        if (is_procname == 0) {
#line 1293
          if (! parser_state_tos->block_init) {
#line 1297
            while (e_code - s_code < dec_ind - 1) {
#line 1299
              if ((unsigned int )e_code >= (unsigned int )l_code) {
#line 1299
                nsize___9 = (l_code - s_code) + 400;
#line 1299
                tmp___83 = xrealloc(codebuf, nsize___9);
#line 1299
                codebuf = tmp___83;
#line 1299
                e_code = (codebuf + (e_code - s_code)) + 1;
#line 1299
                l_code = (codebuf + nsize___9) - 5;
#line 1299
                s_code = codebuf + 1;
              }
#line 1300
              tmp___84 = e_code;
#line 1300
              e_code ++;
#line 1300
              *tmp___84 = (char )' ';
            }
          }
        }
      }
    }
#line 1303
    tmp___85 = e_code;
#line 1303
    e_code ++;
#line 1303
    *tmp___85 = (char )',';
#line 1304
    if (parser_state_tos->p_l_follow == 0) {
#line 1306
      if (parser_state_tos->block_init_level <= 0) {
#line 1307
        parser_state_tos->block_init = 0;
      }
#line 1311
      if (break_comma) {
#line 1311
        if (! leave_comma) {
#line 1315
          force_nl = 1;
        } else {
#line 1311
          tmp___86 = compute_code_target();
#line 1311
          if (tmp___86 + (e_code - s_code) > max_col - tabsize) {
#line 1315
            force_nl = 1;
          }
        }
      }
    }
#line 1317
    break;
    case 18: 
#line 1320
    if ((unsigned int )s_com != (unsigned int )e_com) {
#line 1323
      dump_line();
    } else {
#line 1320
      if ((unsigned int )s_lab != (unsigned int )e_lab) {
#line 1323
        dump_line();
      } else {
#line 1320
        if ((unsigned int )s_code != (unsigned int )e_code) {
#line 1323
          dump_line();
        }
      }
    }
#line 1325
    in_comment = 0;
#line 1326
    in_cplus_comment = 0;
#line 1327
    com_start = 0;
#line 1328
    quote = (char)0;
#line 1329
    com_end = 0;
#line 1334
    if (leave_preproc_space) {
#line 1336
      p___1 = cur_line;
#line 1337
      while ((unsigned int )p___1 < (unsigned int )buf_ptr) {
#line 1338
        tmp___87 = e_lab;
#line 1338
        e_lab ++;
#line 1338
        tmp___88 = p___1;
#line 1338
        p___1 ++;
#line 1338
        *tmp___87 = *tmp___88;
      }
#line 1340
      while (1) {
#line 1340
        if (! ((int )*buf_ptr == 32)) {
#line 1340
          if (! ((int )*buf_ptr == 9)) {
#line 1340
            break;
          }
        }
#line 1341
        tmp___89 = e_lab;
#line 1341
        e_lab ++;
#line 1341
        tmp___90 = buf_ptr;
#line 1341
        buf_ptr ++;
#line 1341
        *tmp___89 = *tmp___90;
      }
    } else {
#line 1345
      tmp___91 = e_lab;
#line 1345
      e_lab ++;
#line 1345
      *tmp___91 = (char )'#';
#line 1346
      while (1) {
#line 1346
        if (! ((int )*buf_ptr == 32)) {
#line 1346
          if (! ((int )*buf_ptr == 9)) {
#line 1346
            break;
          }
        }
#line 1347
        buf_ptr ++;
      }
    }
#line 1350
    while (1) {
#line 1350
      if (! ((int )*buf_ptr != 10)) {
#line 1350
        if (in_comment) {
#line 1350
          if (! (! had_eof)) {
#line 1350
            break;
          }
        } else {
#line 1350
          break;
        }
      }
#line 1352
      if ((unsigned int )e_lab >= (unsigned int )l_lab) {
#line 1352
        nsize___10 = (l_lab - s_lab) + 400;
#line 1352
        tmp___92 = xrealloc(labbuf, nsize___10);
#line 1352
        labbuf = tmp___92;
#line 1352
        e_lab = (labbuf + (e_lab - s_lab)) + 1;
#line 1352
        l_lab = (labbuf + nsize___10) - 5;
#line 1352
        s_lab = labbuf + 1;
      }
#line 1353
      tmp___93 = buf_ptr;
#line 1353
      buf_ptr ++;
#line 1353
      *e_lab = *tmp___93;
#line 1354
      if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 1355
        fill_buffer();
      }
#line 1356
      tmp___94 = e_lab;
#line 1356
      e_lab ++;
#line 1356
      switch ((int )*tmp___94) {
      case 92: 
#line 1359
      if (troff) {
#line 1360
        tmp___95 = e_lab;
#line 1360
        e_lab ++;
#line 1360
        *tmp___95 = (char )'\\';
      }
#line 1361
      if (! in_comment) {
#line 1361
        if (! in_cplus_comment) {
#line 1363
          tmp___96 = e_lab;
#line 1363
          e_lab ++;
#line 1363
          tmp___97 = buf_ptr;
#line 1363
          buf_ptr ++;
#line 1363
          *tmp___96 = *tmp___97;
#line 1364
          if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 1365
            fill_buffer();
          }
        }
      }
#line 1367
      break;
      case 47: 
#line 1369
      if ((int )*buf_ptr == 42) {
        goto _L___27;
      } else {
#line 1369
        if ((int )*buf_ptr == 47) {
          _L___27: /* CIL Label */ 
#line 1369
          if (! in_comment) {
#line 1369
            if (! in_cplus_comment) {
#line 1369
              if (! quote) {
#line 1372
                if ((int )*buf_ptr == 47) {
#line 1373
                  in_cplus_comment = 1;
                } else {
#line 1375
                  in_comment = 1;
                }
#line 1376
                tmp___98 = e_lab;
#line 1376
                e_lab ++;
#line 1376
                tmp___99 = buf_ptr;
#line 1376
                buf_ptr ++;
#line 1376
                *tmp___98 = *tmp___99;
#line 1377
                com_start = (e_lab - s_lab) - 2;
              }
            }
          }
        }
      }
#line 1379
      break;
      case 34: 
      case 39: 
#line 1383
      if (! quote) {
#line 1384
        quote = *(e_lab + -1);
      } else {
#line 1386
        if ((int )*(e_lab + -1) == (int )quote) {
#line 1387
          quote = (char)0;
        }
      }
#line 1388
      break;
      case 42: 
#line 1391
      if ((int )*buf_ptr == 47) {
#line 1391
        if (in_comment) {
#line 1393
          in_comment = 0;
#line 1394
          tmp___100 = e_lab;
#line 1394
          e_lab ++;
#line 1394
          tmp___101 = buf_ptr;
#line 1394
          buf_ptr ++;
#line 1394
          *tmp___100 = *tmp___101;
#line 1395
          com_end = e_lab - s_lab;
        }
      }
#line 1397
      break;
      }
    }
#line 1401
    while (1) {
#line 1401
      if ((unsigned int )e_lab > (unsigned int )s_lab) {
#line 1401
        if (! ((int )*(e_lab + -1) == 32)) {
#line 1401
          if (! ((int )*(e_lab + -1) == 9)) {
#line 1401
            break;
          }
        }
      } else {
#line 1401
        break;
      }
#line 1402
      e_lab --;
    }
#line 1404
    if (in_cplus_comment) {
#line 1406
      in_cplus_comment = 0;
#line 1407
      tmp___102 = e_lab;
#line 1407
      e_lab ++;
#line 1407
      tmp___103 = buf_ptr;
#line 1407
      buf_ptr ++;
#line 1407
      *tmp___102 = *tmp___103;
#line 1408
      com_end = e_lab - s_lab;
    }
#line 1411
    if (e_lab - s_lab == com_end) {
#line 1411
      if ((unsigned int )bp_save == (unsigned int )((char *)0)) {
#line 1413
        if ((unsigned int )save_com.end != (unsigned int )save_com.ptr) {
#line 1415
          if ((save_com.end - save_com.ptr) + 2 >= save_com.size) {
#line 1415
            cur_chars___4 = save_com.end - save_com.ptr;
#line 1415
            save_com.size *= 2;
#line 1415
            save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 1415
            save_com.end = save_com.ptr + cur_chars___4;
          }
#line 1416
          tmp___104 = save_com.end;
#line 1416
          (save_com.end) ++;
#line 1416
          *tmp___104 = (char )'\n';
#line 1418
          tmp___105 = save_com.end;
#line 1418
          (save_com.end) ++;
#line 1418
          *tmp___105 = (char )' ';
#line 1419
          line_no --;
        }
#line 1421
        if ((save_com.end - save_com.ptr) + (com_end - com_start) >= save_com.size) {
#line 1421
          cur_chars___5 = save_com.end - save_com.ptr;
#line 1421
          save_com.size *= 2;
#line 1421
          save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 1421
          save_com.end = save_com.ptr + cur_chars___5;
        }
#line 1422
        strncpy(save_com.end, s_lab + com_start, com_end - com_start);
#line 1424
        save_com.end += com_end - com_start;
#line 1426
        e_lab = s_lab + com_start;
#line 1427
        while (1) {
#line 1427
          if ((unsigned int )e_lab > (unsigned int )s_lab) {
#line 1427
            if (! ((int )*(e_lab + -1) == 32)) {
#line 1427
              if (! ((int )*(e_lab + -1) == 9)) {
#line 1427
                break;
              }
            }
          } else {
#line 1427
            break;
          }
#line 1429
          e_lab --;
        }
#line 1430
        bp_save = buf_ptr;
#line 1431
        be_save = buf_end;
#line 1432
        buf_ptr = save_com.ptr;
#line 1435
        if ((save_com.end - save_com.ptr) + 1 >= save_com.size) {
#line 1435
          cur_chars___6 = save_com.end - save_com.ptr;
#line 1435
          save_com.size *= 2;
#line 1435
          save_com.ptr = xrealloc(save_com.ptr, save_com.size);
#line 1435
          save_com.end = save_com.ptr + cur_chars___6;
        }
#line 1436
        buf_end = save_com.end;
#line 1437
        save_com.end = save_com.ptr;
      }
    }
#line 1439
    *e_lab = (char )'\000';
#line 1440
    parser_state_tos->pcase = 0;
#line 1443
    tmp___114 = strncmp(s_lab + 1, "if", 2);
#line 1443
    if (tmp___114 == 0) {
#line 1445
      if (blanklines_around_conditional_compilation) {
#line 1448
        prefix_blankline_requested ++;
#line 1449
        while (1) {
#line 1449
          tmp___106 = in_prog_pos;
#line 1449
          in_prog_pos ++;
#line 1449
          c = (int )*tmp___106;
#line 1449
          if (! (c == 10)) {
#line 1449
            break;
          }
        }
#line 1450
        in_prog_pos --;
      }
#line 1459
      tmp___107 = xmalloc(sizeof(struct parser_state ));
#line 1459
      new = (struct parser_state *)tmp___107;
#line 1461
      bcopy(parser_state_tos, new, sizeof(struct parser_state ));
#line 1465
      tmp___108 = xmalloc((unsigned int )parser_state_tos->p_stack_size * sizeof(enum codes ));
#line 1465
      new->p_stack = (enum codes *)tmp___108;
#line 1468
      bcopy(parser_state_tos->p_stack, new->p_stack, (unsigned int )parser_state_tos->p_stack_size * sizeof(enum codes ));
#line 1471
      tmp___109 = xmalloc((unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 1471
      new->il = (int *)tmp___109;
#line 1473
      bcopy(parser_state_tos->il, new->il, (unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 1476
      tmp___110 = xmalloc((unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 1476
      new->cstk = (int *)tmp___110;
#line 1479
      bcopy(parser_state_tos->cstk, new->cstk, (unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 1482
      tmp___111 = xmalloc((unsigned int )parser_state_tos->paren_indents_size * sizeof(short ));
#line 1482
      new->paren_indents = (short *)tmp___111;
#line 1484
      bcopy(parser_state_tos->paren_indents, new->paren_indents, (unsigned int )parser_state_tos->paren_indents_size * sizeof(short ));
#line 1487
      new->next = parser_state_tos;
#line 1488
      parser_state_tos = new;
    } else {
#line 1491
      tmp___113 = strncmp(s_lab + 1, "else", 4);
#line 1491
      if (tmp___113 == 0) {
#line 1499
        else_or_endif = 1;
#line 1500
        if (parser_state_tos->next) {
#line 1504
          tos_p_stack = parser_state_tos->p_stack;
#line 1505
          tos_il = parser_state_tos->il;
#line 1506
          tos_cstk = parser_state_tos->cstk;
#line 1507
          tos_paren_indents = parser_state_tos->paren_indents;
#line 1509
          second = parser_state_tos->next;
#line 1512
          bcopy(second, parser_state_tos, sizeof(struct parser_state ));
#line 1514
          parser_state_tos->next = second;
#line 1521
          parser_state_tos->p_stack = tos_p_stack;
#line 1522
          bcopy((parser_state_tos->next)->p_stack, parser_state_tos->p_stack, (unsigned int )parser_state_tos->p_stack_size * sizeof(enum codes ));
#line 1527
          parser_state_tos->il = tos_il;
#line 1528
          bcopy((parser_state_tos->next)->il, parser_state_tos->il, (unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 1532
          parser_state_tos->cstk = tos_cstk;
#line 1533
          bcopy((parser_state_tos->next)->cstk, parser_state_tos->cstk, (unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 1537
          parser_state_tos->paren_indents = tos_paren_indents;
#line 1538
          bcopy((parser_state_tos->next)->paren_indents, parser_state_tos->paren_indents,
                (unsigned int )parser_state_tos->paren_indents_size * sizeof(short ));
        } else {
#line 1544
          diag(1, "Unmatched #else", 0, 0);
        }
      } else {
#line 1546
        tmp___112 = strncmp(s_lab + 1, "endif", 5);
#line 1546
        if (tmp___112 == 0) {
#line 1548
          else_or_endif = 1;
#line 1554
          if (parser_state_tos->next) {
#line 1556
            second___0 = parser_state_tos->next;
#line 1558
            parser_state_tos->next = second___0->next;
#line 1559
            free(second___0->p_stack);
#line 1560
            free(second___0->il);
#line 1561
            free(second___0->cstk);
#line 1562
            free(second___0->paren_indents);
#line 1563
            free(second___0);
          } else {
#line 1566
            diag(1, "Unmatched #endif", 0, 0);
          }
#line 1567
          if (blanklines_around_conditional_compilation) {
#line 1569
            postfix_blankline_requested ++;
#line 1570
            n_real_blanklines = 0;
          }
        }
      }
    }
#line 1578
    if ((int )parser_state_tos->last_token == 14) {
#line 1578
      if (parser_state_tos->p_l_follow <= 0) {
#line 1578
        if (leave_comma) {
#line 1578
          if (! parser_state_tos->block_init) {
#line 1578
            if (break_comma) {
#line 1578
              if ((unsigned int )s_com == (unsigned int )e_com) {
#line 1583
                dump_line();
#line 1584
                parser_state_tos->want_blank = 0;
              }
            }
          }
        }
      }
    }
#line 1586
    break;
    case 15: 
    case 16: 
#line 1591
    if (flushed_nl) {
#line 1593
      flushed_nl = 0;
#line 1594
      dump_line();
#line 1595
      parser_state_tos->want_blank = 0;
#line 1596
      force_nl = 0;
    }
#line 1598
    print_comment();
#line 1599
    break;
    }
#line 1602
    *e_code = (char )'\000';
#line 1603
    if ((int )type_code != 15) {
#line 1603
      if ((int )type_code != 16) {
#line 1603
        if ((int )type_code != 1) {
#line 1603
          if ((int )type_code != 18) {
#line 1603
            if ((int )type_code != 19) {
#line 1608
              parser_state_tos->last_token = type_code;
            }
          }
        }
      }
    }
  }
}
}
#line 1615
char *set_profile(void) ;
#line 1616
void set_defaults(void) ;
#line 1617
int set_option(char *option , char *param , int explicit ) ;
#line 1620 "indent.c"
char *in_name  =    (char *)0;
#line 1623 "indent.c"
struct file_buffer *current_input  =    (struct file_buffer *)0;
#line 1626 "indent.c"
char *out_name  =    (char *)0;
#line 1629 "indent.c"
int input_files  ;
#line 1632 "indent.c"
char **in_file_names  ;
#line 1635 "indent.c"
int max_input_files  =    128;
#line 1655
void init_parser(void) ;
#line 1656
void initialize_backups(void) ;
#line 1664
extern int ( /* missing proto */  strcmp)() ;
#line 1766
void make_backup(struct file_buffer *file ) ;
#line 1767
void reset_parser(void) ;
#line 1770
void sys_error(char *offender ) ;
#line 1642 "indent.c"
int main(int argc , char **argv ) 
{ register int i ;
  char *profile_pathname ;
  int using_stdin ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1647
  profile_pathname = (char *)0;
#line 1648
  using_stdin = 0;
#line 1655
  init_parser();
#line 1656
  initialize_backups();
#line 1658
  output = (FILE *)0;
#line 1659
  input_files = 0;
#line 1660
  tmp = xmalloc((unsigned int )max_input_files * sizeof(char *));
#line 1660
  in_file_names = (char **)tmp;
#line 1662
  set_defaults();
#line 1663
  i = 1;
#line 1663
  while (i < argc) {
#line 1664
    tmp___0 = strcmp(*(argv + i), "-npro");
#line 1664
    if (tmp___0 == 0) {
#line 1667
      break;
    } else {
#line 1664
      tmp___1 = strcmp(*(argv + i), "--ignore-profile");
#line 1664
      if (tmp___1 == 0) {
#line 1667
        break;
      } else {
#line 1664
        tmp___2 = strcmp(*(argv + i), "+ignore-profile");
#line 1664
        if (tmp___2 == 0) {
#line 1667
          break;
        }
      }
    }
#line 1663
    i ++;
  }
#line 1668
  if (i >= argc) {
#line 1669
    profile_pathname = set_profile();
  }
#line 1671
  i = 1;
#line 1671
  while (i < argc) {
#line 1673
    if ((int )*(*(argv + i) + 0) != 45) {
#line 1673
      if ((int )*(*(argv + i) + 0) != 43) {
#line 1675
        if (expect_output_file == 1) {
#line 1677
          if ((unsigned int )out_name != (unsigned int )((char *)0)) {
#line 1679
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: only one output file (2nd was %s)\n",
                    *(argv + i));
#line 1680
            exit(1);
          }
#line 1683
          if (input_files > 1) {
#line 1685
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: only one input file when output file is specified\n");
#line 1686
            exit(1);
          }
#line 1689
          out_name = *(argv + i);
#line 1690
          expect_output_file = 0;
          goto __Cont;
        } else {
#line 1695
          if (using_stdin) {
#line 1697
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: can\'t have filenames when specifying standard input\n");
#line 1698
            exit(1);
          }
#line 1701
          input_files ++;
#line 1702
          if (input_files > 1) {
#line 1704
            if ((unsigned int )out_name != (unsigned int )((char *)0)) {
#line 1706
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: only one input file when output file is specified\n");
#line 1707
              exit(1);
            }
#line 1710
            if (use_stdout != 0) {
#line 1712
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: only one input file when stdout is used\n");
#line 1713
              exit(1);
            }
#line 1716
            if (input_files > max_input_files) {
#line 1718
              max_input_files = 2 * max_input_files;
#line 1719
              tmp___3 = xrealloc((char *)in_file_names, (unsigned int )max_input_files * sizeof(char *));
#line 1719
              in_file_names = (char **)tmp___3;
            }
          }
#line 1726
          *(in_file_names + (input_files - 1)) = *(argv + i);
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1732
      if ((int )*(*(argv + i) + 0) == 45) {
#line 1732
        if ((int )*(*(argv + i) + 1) == 0) {
#line 1734
          if (input_files > 0) {
#line 1736
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: can\'t have filenames when specifying standard input\n");
#line 1737
            exit(1);
          }
#line 1740
          using_stdin = 1;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1743
        if (i < argc) {
#line 1743
          tmp___4 = *(argv + (i + 1));
        } else {
#line 1743
          tmp___4 = (char *)0;
        }
#line 1743
        tmp___5 = set_option(*(argv + i), tmp___4, 1);
#line 1743
        i += tmp___5;
      }
    }
    __Cont: /* CIL Label */ 
#line 1671
    i ++;
  }
#line 1747
  if (verbose) {
#line 1747
    if (profile_pathname) {
#line 1748
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Read profile %s\n",
              profile_pathname);
    }
  }
#line 1750
  if (input_files > 1) {
#line 1755
    i = 0;
#line 1755
    while (input_files) {
#line 1757
      current_input = read_file(*(in_file_names + i));
#line 1758
      out_name = *(in_file_names + i);
#line 1758
      in_name = out_name;
#line 1759
      output = fopen((char const   * __restrict  )out_name, (char const   * __restrict  )"w");
#line 1760
      if ((unsigned int )output == (unsigned int )((FILE *)0)) {
#line 1762
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: can\'t create %s\n",
                out_name);
#line 1763
        exit(1);
      }
#line 1766
      make_backup(current_input);
#line 1767
      reset_parser();
#line 1768
      indent(current_input);
#line 1769
      tmp___6 = fclose(output);
#line 1769
      if (tmp___6 != 0) {
#line 1770
        sys_error(out_name);
      }
#line 1755
      i ++;
#line 1755
      input_files --;
    }
  } else {
#line 1777
    if (input_files == 0) {
#line 1779
      input_files = 1;
#line 1780
      *(in_file_names + 0) = (char *)"Standard input";
#line 1781
      current_input = read_stdin();
    } else {
#line 1777
      if (using_stdin) {
#line 1779
        input_files = 1;
#line 1780
        *(in_file_names + 0) = (char *)"Standard input";
#line 1781
        current_input = read_stdin();
      } else {
#line 1786
        current_input = read_file(*(in_file_names + 0));
#line 1787
        if (! out_name) {
#line 1787
          if (! use_stdout) {
#line 1789
            out_name = *(in_file_names + 0);
#line 1790
            make_backup(current_input);
          }
        }
      }
    }
#line 1793
    in_name = *(in_file_names + 0);
#line 1797
    if (use_stdout) {
#line 1798
      output = stdout;
    } else {
#line 1797
      if (! out_name) {
#line 1798
        output = stdout;
      } else {
#line 1797
        if (troff) {
#line 1798
          output = stdout;
        } else {
#line 1801
          output = fopen((char const   * __restrict  )out_name, (char const   * __restrict  )"w");
#line 1802
          if ((unsigned int )output == (unsigned int )((FILE *)0)) {
#line 1804
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: can\'t create %s\n",
                    out_name);
#line 1805
            exit(1);
          }
        }
      }
    }
#line 1809
    reset_parser();
#line 1810
    indent(current_input);
  }
#line 1813
  exit(0);
}
}
#line 1 "io.o"
#pragma merger(0,"/tmp/cil-4AQBjaSm.i","-O")
#line 451 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 452
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 622
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 753
extern void perror(char const   *__s ) ;
#line 66 "indent.h"
char *in_prog  ;
#line 71 "indent.h"
char *in_prog_pos  ;
#line 74 "indent.h"
char *cur_line  ;
#line 77 "indent.h"
unsigned long in_prog_size  ;
#line 79 "indent.h"
FILE *output  ;
#line 96 "indent.h"
char *buf_ptr  ;
#line 98 "indent.h"
char *buf_end  ;
#line 134
int blanklines_after_declarations ;
#line 137
int swallow_optional_blanklines ;
#line 144 "indent.h"
int found_err  ;
#line 168
int case_ind ;
#line 174 "indent.h"
int out_lines  ;
#line 176 "indent.h"
int com_lines  ;
#line 180 "indent.h"
int had_eof  ;
#line 206
int suppress_blanklines ;
#line 210
int lineup_to_parens ;
#line 217 "indent.h"
int paren_target  ;
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 214 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 397
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 464
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 464 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 467
  tmp = __fxstat(3, __fd, __statbuf);
#line 467
  return (tmp);
}
}
#line 58 "io.c"
int suppress_blanklines  =    0;
#line 59 "io.c"
static int comment_open  ;
#line 66 "io.c"
void sys_error(char *offender ) 
{ char *errbuf ;
  int tmp ;
  char *tmp___0 ;

  {
#line 74
  tmp = strlen(offender);
#line 74
  tmp___0 = xmalloc(tmp + 10);
#line 74
  errbuf = tmp___0;
#line 76
  sprintf((char * __restrict  )errbuf, (char const   * __restrict  )"indent: %s",
          offender);
#line 77
  perror((char const   *)errbuf);
#line 78
  exit(1);
}
}
#line 112 "io.c"
__inline int count_columns(int column , char *bp ) 
{ char *tmp ;

  {
#line 117
  while ((int )*bp != 0) {
#line 119
    tmp = bp;
#line 119
    bp ++;
#line 119
    switch ((int )*tmp) {
    case 10: 
    case 12: 
#line 123
    column = 1;
#line 124
    break;
    case 9: 
#line 126
    column += tabsize - (column - 1) % tabsize;
#line 127
    break;
    case 8: 
#line 129
    column --;
#line 130
    break;
    default: 
#line 132
    column ++;
#line 133
    break;
    }
  }
#line 137
  return (column);
}
}
#line 142 "io.c"
__inline int current_column(void) 
{ char *p ;
  int column ;
  char *tmp ;

  {
#line 146
  column = 1;
#line 148
  if ((unsigned int )buf_ptr >= (unsigned int )save_com.ptr) {
#line 148
    if ((unsigned int )buf_ptr <= (unsigned int )save_com.end) {
#line 149
      p = save_com.ptr;
    } else {
#line 151
      p = cur_line;
    }
  } else {
#line 151
    p = cur_line;
  }
#line 160
  column = 1;
#line 161
  while ((unsigned int )p < (unsigned int )buf_ptr) {
#line 162
    tmp = p;
#line 162
    p ++;
#line 162
    switch ((int )*tmp) {
    case 10: 
    case 12: 
#line 166
    column = 1;
#line 167
    break;
    case 9: 
#line 169
    column += tabsize - (column - 1) % tabsize;
#line 170
    break;
    case 8: 
#line 172
    column --;
#line 173
    break;
    default: 
#line 175
    column ++;
#line 176
    break;
    }
  }
#line 179
  return (column);
}
}
#line 191 "io.c"
static int not_first_line  ;
#line 263
__inline int pad_output(int current_column___0 , int target_column ) ;
#line 263
__inline int compute_label_target(void) ;
#line 182 "io.c"
void dump_line(void) 
{ register int cur_col ;
  register int target_col ;
  int tmp ;
  register char *s ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  register char *p ;
  register int i ;
  int all_here ;
  register char *p___0 ;
  int tmp___5 ;
  register char *follow ;
  int tmp___6 ;
  char *tmp___7 ;
  register int target ;
  register char *com_st ;

  {
#line 190
  target_col = 0;
#line 193
  if (*(parser_state_tos->procname + 0)) {
#line 195
    if (troff) {
#line 197
      if (comment_open) {
#line 199
        comment_open = 0;
#line 200
        fprintf((FILE * __restrict  )output, (char const   * __restrict  )".*/\n");
      }
#line 202
      fprintf((FILE * __restrict  )output, (char const   * __restrict  )".Pr \"%.*s\"\n",
              parser_state_tos->procname_end - parser_state_tos->procname, parser_state_tos->procname);
    }
#line 206
    parser_state_tos->ind_level = 0;
#line 207
    parser_state_tos->procname = (char *)"\000";
  }
#line 211
  if ((unsigned int )s_code == (unsigned int )e_code) {
#line 211
    if ((unsigned int )s_lab == (unsigned int )e_lab) {
#line 211
      if ((unsigned int )s_com == (unsigned int )e_com) {
#line 215
        if (parser_state_tos->use_ff) {
#line 217
          _IO_putc('\f', output);
#line 218
          parser_state_tos->use_ff = 0;
        } else {
#line 222
          if (suppress_blanklines > 0) {
#line 223
            suppress_blanklines --;
          } else {
#line 226
            parser_state_tos->bl_line = 1;
#line 227
            n_real_blanklines ++;
          }
        }
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
  } else {
    _L___7: /* CIL Label */ 
#line 233
    suppress_blanklines = 0;
#line 234
    parser_state_tos->bl_line = 0;
#line 235
    if (prefix_blankline_requested) {
#line 235
      if (not_first_line) {
#line 235
        if (n_real_blanklines == 0) {
#line 238
          n_real_blanklines = 1;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 239
      if (swallow_optional_blanklines) {
#line 239
        if (n_real_blanklines > 1) {
#line 240
          n_real_blanklines = 1;
        }
      }
    }
#line 242
    while (1) {
#line 242
      n_real_blanklines --;
#line 242
      if (! (n_real_blanklines >= 0)) {
#line 242
        break;
      }
#line 243
      _IO_putc('\n', output);
    }
#line 244
    n_real_blanklines = 0;
#line 245
    if (parser_state_tos->ind_level == 0) {
#line 246
      parser_state_tos->ind_stmt = 0;
    }
#line 250
    if ((unsigned int )e_lab != (unsigned int )s_lab) {
#line 251
      code_lines ++;
    } else {
#line 250
      if ((unsigned int )e_code != (unsigned int )s_code) {
#line 251
        code_lines ++;
      }
    }
#line 254
    if ((unsigned int )e_lab != (unsigned int )s_lab) {
#line 256
      if (comment_open) {
#line 258
        comment_open = 0;
#line 259
        fprintf((FILE * __restrict  )output, (char const   * __restrict  )".*/\n");
      }
#line 261
      while (1) {
#line 261
        if ((unsigned int )e_lab > (unsigned int )s_lab) {
#line 261
          if (! ((int )*(e_lab + -1) == 32)) {
#line 261
            if (! ((int )*(e_lab + -1) == 9)) {
#line 261
              break;
            }
          }
        } else {
#line 261
          break;
        }
#line 262
        e_lab --;
      }
#line 263
      tmp = compute_label_target();
#line 263
      cur_col = pad_output(1, tmp);
#line 264
      if ((int )*(s_lab + 0) == 35) {
#line 264
        tmp___3 = strncmp(s_lab, "#else", 5);
#line 264
        if (tmp___3 == 0) {
          goto _L___4;
        } else {
#line 264
          tmp___4 = strncmp(s_lab, "#endif", 6);
#line 264
          if (tmp___4 == 0) {
            _L___4: /* CIL Label */ 
#line 269
            s = s_lab;
#line 270
            if ((int )*(e_lab + -1) == 10) {
#line 271
              e_lab --;
            }
#line 272
            while (1) {
#line 273
              tmp___0 = s;
#line 273
              s ++;
#line 273
              _IO_putc((int )*tmp___0, output);
#line 272
              if ((unsigned int )s < (unsigned int )e_lab) {
#line 272
                if (97 <= (int )*s) {
#line 272
                  if (! ((int )*s <= 122)) {
#line 272
                    break;
                  }
                } else {
#line 272
                  break;
                }
              } else {
#line 272
                break;
              }
            }
#line 275
            while (1) {
#line 275
              if ((int )*s == 32) {
                goto _L___1;
              } else {
#line 275
                if ((int )*s == 9) {
                  _L___1: /* CIL Label */ 
#line 275
                  if (! ((unsigned int )s < (unsigned int )e_lab)) {
#line 275
                    break;
                  }
                } else {
#line 275
                  break;
                }
              }
#line 276
              s ++;
            }
#line 277
            if ((unsigned int )s < (unsigned int )e_lab) {
#line 279
              if ((int )*(s + 0) == 47) {
#line 279
                if ((int )*(s + 1) == 42) {
                  goto _L___3;
                } else {
#line 279
                  if ((int )*(s + 1) == 47) {
                    _L___3: /* CIL Label */ 
#line 280
                    if (tabsize > 1) {
#line 280
                      tmp___1 = "\t%.*s";
                    } else {
#line 280
                      tmp___1 = "  %.*s";
                    }
#line 280
                    fprintf((FILE * __restrict  )output, (char const   * __restrict  )tmp___1,
                            e_lab - s, s);
                  } else {
                    goto _L___2;
                  }
                }
              } else {
                _L___2: /* CIL Label */ 
#line 283
                if (tabsize > 1) {
#line 283
                  tmp___2 = "\t/* %.*s */";
                } else {
#line 283
                  tmp___2 = "  /* %.*s */";
                }
#line 283
                fprintf((FILE * __restrict  )output, (char const   * __restrict  )tmp___2,
                        e_lab - s, s);
              }
            }
          } else {
#line 290
            fprintf((FILE * __restrict  )output, (char const   * __restrict  )"%.*s",
                    e_lab - s_lab, s_lab);
          }
        }
      } else {
#line 290
        fprintf((FILE * __restrict  )output, (char const   * __restrict  )"%.*s",
                e_lab - s_lab, s_lab);
      }
#line 291
      cur_col = count_columns(cur_col, s_lab);
    } else {
#line 294
      cur_col = 1;
    }
#line 296
    parser_state_tos->pcase = 0;
#line 298
    if ((unsigned int )s_code != (unsigned int )e_code) {
#line 303
      if (comment_open) {
#line 305
        comment_open = 0;
#line 306
        fprintf((FILE * __restrict  )output, (char const   * __restrict  )".*/\n");
      }
#line 312
      if (embedded_comment_on_line == 1) {
#line 313
        target_col = parser_state_tos->com_col;
      } else {
#line 315
        target_col = compute_code_target();
      }
#line 320
      if ((int )parser_state_tos->last_token == 2) {
#line 322
        *(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) = (short )((int )*(parser_state_tos->paren_indents + (parser_state_tos->p_l_follow - 1)) + (ind_size - 1));
      }
#line 326
      i = 0;
#line 326
      while (i < parser_state_tos->p_l_follow) {
#line 327
        if ((int )*(parser_state_tos->paren_indents + i) >= 0) {
#line 328
          *(parser_state_tos->paren_indents + i) = (short )(- ((int )*(parser_state_tos->paren_indents + i) + target_col));
        }
#line 326
        i ++;
      }
#line 331
      cur_col = pad_output(cur_col, target_col);
#line 332
      p = s_code;
#line 332
      while ((unsigned int )p < (unsigned int )e_code) {
#line 333
        _IO_putc((int )*p, output);
#line 332
        p ++;
      }
#line 334
      cur_col = count_columns(cur_col, s_code);
    }
#line 337
    if ((unsigned int )s_com != (unsigned int )e_com) {
#line 339
      if (troff) {
#line 341
        all_here = 0;
#line 344
        if ((int )*(e_com + -1) == 47) {
#line 344
          if ((int )*(e_com + -2) == 42) {
#line 345
            e_com -= 2;
#line 345
            all_here ++;
          }
        }
#line 346
        while (1) {
#line 346
          if ((unsigned int )e_com > (unsigned int )s_com) {
#line 346
            if (! ((int )*(e_com + -1) == 32)) {
#line 346
              break;
            }
          } else {
#line 346
            break;
          }
#line 347
          e_com --;
        }
#line 348
        *e_com = (char)0;
#line 349
        p___0 = s_com;
#line 350
        while ((int )*p___0 == 32) {
#line 351
          p___0 ++;
        }
#line 352
        if ((int )*(p___0 + 0) == 47) {
#line 352
          if ((int )*(p___0 + 1) == 42) {
#line 353
            p___0 += 2;
#line 353
            all_here ++;
          } else {
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
#line 354
          if ((int )*(p___0 + 0) == 42) {
#line 355
            if ((int )*(p___0 + 1) == 47) {
#line 355
              tmp___5 = 2;
            } else {
#line 355
              tmp___5 = 1;
            }
#line 355
            p___0 += tmp___5;
          }
        }
#line 356
        while ((int )*p___0 == 32) {
#line 357
          p___0 ++;
        }
#line 358
        if ((int )*p___0 == 0) {
          goto inhibit_newline;
        }
#line 360
        if (comment_open < 2) {
#line 360
          if (parser_state_tos->box_com) {
#line 362
            comment_open = 0;
#line 363
            fprintf((FILE * __restrict  )output, (char const   * __restrict  )".*/\n");
          }
        }
#line 365
        if (comment_open == 0) {
#line 367
          if (97 <= (int )*p___0) {
#line 367
            if ((int )*p___0 <= 122) {
#line 368
              *p___0 = (char )(((int )*p___0 + 65) - 97);
            }
          }
#line 369
          if (e_com - p___0 < 50) {
#line 369
            if (all_here == 2) {
#line 371
              follow = p___0;
#line 372
              fprintf((FILE * __restrict  )output, (char const   * __restrict  )"\n.nr C! \\w\001");
#line 373
              while ((unsigned int )follow < (unsigned int )e_com) {
#line 375
                switch ((int )*follow) {
                case 10: 
#line 378
                _IO_putc(' ', output);
                case 1: 
#line 380
                break;
                case 92: 
#line 382
                _IO_putc('\\', output);
                default: 
#line 384
                _IO_putc((int )*follow, output);
                }
#line 386
                follow ++;
              }
#line 388
              _IO_putc(1, output);
            }
          }
#line 390
          if ((unsigned int )s_code != (unsigned int )e_code) {
#line 390
            tmp___6 = 1;
          } else {
#line 390
            if ((unsigned int )s_lab != (unsigned int )e_lab) {
#line 390
              tmp___6 = 1;
            } else {
#line 390
              tmp___6 = 0;
            }
          }
#line 390
          fprintf((FILE * __restrict  )output, (char const   * __restrict  )"\n./* %dp %d %dp\n",
                  parser_state_tos->com_col * 7, tmp___6 - parser_state_tos->box_com,
                  target_col * 7);
        }
#line 396
        comment_open = 1 + parser_state_tos->box_com;
#line 397
        while (*p___0) {
#line 399
          if ((int )*p___0 == 92) {
#line 400
            _IO_putc('\\', output);
          }
#line 401
          tmp___7 = p___0;
#line 401
          p___0 ++;
#line 401
          _IO_putc((int )*tmp___7, output);
        }
      } else {
#line 408
        target = parser_state_tos->com_col;
#line 409
        com_st = s_com;
#line 411
        if (cur_col > target) {
#line 413
          _IO_putc('\n', output);
#line 414
          cur_col = 1;
#line 415
          out_lines ++;
        }
#line 418
        cur_col = pad_output(cur_col, target);
#line 419
        fwrite((void const   * __restrict  )com_st, (unsigned int )(e_com - com_st),
               1U, (FILE * __restrict  )output);
#line 420
        cur_col += e_com - com_st;
#line 421
        com_lines ++;
      }
    } else {
#line 424
      if (embedded_comment_on_line) {
#line 425
        com_lines ++;
      }
    }
#line 426
    embedded_comment_on_line = 0;
#line 428
    if (parser_state_tos->use_ff) {
#line 430
      _IO_putc('\f', output);
#line 431
      parser_state_tos->use_ff = 0;
    } else {
#line 434
      _IO_putc('\n', output);
    }
    inhibit_newline: 
#line 437
    out_lines ++;
#line 438
    if (parser_state_tos->just_saw_decl == 1) {
#line 438
      if (blanklines_after_declarations) {
#line 441
        prefix_blankline_requested = 1;
#line 442
        parser_state_tos->just_saw_decl = 0;
      } else {
#line 445
        prefix_blankline_requested = postfix_blankline_requested;
      }
    } else {
#line 445
      prefix_blankline_requested = postfix_blankline_requested;
    }
#line 446
    postfix_blankline_requested = 0;
  }
#line 451
  parser_state_tos->decl_on_line = parser_state_tos->in_decl;
#line 455
  parser_state_tos->ind_stmt = parser_state_tos->in_stmt & ~ parser_state_tos->in_decl;
#line 458
  parser_state_tos->dumped_decl_indent = 0;
#line 459
  e_lab = s_lab;
#line 459
  *e_lab = (char )'\000';
#line 460
  e_code = s_code;
#line 460
  *e_code = (char )'\000';
#line 461
  e_com = s_com;
#line 461
  *e_com = (char )'\000';
#line 462
  parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 463
  parser_state_tos->paren_level = parser_state_tos->p_l_follow;
#line 464
  if (parser_state_tos->paren_level > 0) {
#line 465
    paren_target = - ((int )*(parser_state_tos->paren_indents + (parser_state_tos->paren_level - 1)));
  } else {
#line 468
    paren_target = 0;
  }
#line 469
  not_first_line = 1;
#line 471
  return;
}
}
#line 476 "io.c"
int compute_code_target(void) 
{ register int target_col ;
  register int w ;
  register int t ;
  int tmp ;
  int tmp___0 ;

  {
#line 479
  target_col = parser_state_tos->ind_level + 1;
#line 482
  if (! parser_state_tos->paren_level) {
#line 484
    if (parser_state_tos->ind_stmt) {
#line 485
      target_col += continuation_indent;
    }
#line 486
    return (target_col);
  }
#line 489
  if (! lineup_to_parens) {
#line 490
    return (target_col + continuation_indent * parser_state_tos->paren_level);
  }
#line 492
  t = paren_target;
#line 493
  tmp = count_columns(t, s_code);
#line 493
  w = tmp - max_col;
#line 493
  if (w > 0) {
#line 493
    tmp___0 = count_columns(target_col, s_code);
#line 493
    if (tmp___0 <= max_col) {
#line 496
      t -= w + 1;
#line 497
      if (t > target_col) {
#line 498
        target_col = t;
      }
    } else {
#line 501
      target_col = t;
    }
  } else {
#line 501
    target_col = t;
  }
#line 503
  return (target_col);
}
}
#line 506 "io.c"
__inline int compute_label_target(void) 
{ int tmp___0 ;

  {
#line 509
  if (parser_state_tos->pcase) {
#line 509
    tmp___0 = case_ind + 1;
  } else {
#line 509
    if ((int )*s_lab == 35) {
#line 509
      tmp___0 = 1;
    } else {
#line 509
      tmp___0 = (parser_state_tos->ind_level - 2) + 1;
    }
  }
#line 509
  return (tmp___0);
}
}
#line 523 "io.c"
static struct file_buffer fileptr  ;
#line 549
extern int ( /* missing proto */  read)() ;
#line 552
extern int close(int __fd ) ;
#line 525 "io.c"
struct file_buffer *read_file(char *filename ) 
{ int fd ;
  int size ;
  struct stat file_stats ;
  int namelen ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 531
  tmp = strlen(filename);
#line 531
  namelen = tmp;
#line 533
  fd = open((char const   *)filename, 0, 511);
#line 534
  if (fd < 0) {
#line 535
    sys_error(filename);
  }
#line 537
  tmp___0 = fstat(fd, & file_stats);
#line 537
  if (tmp___0 < 0) {
#line 538
    sys_error(filename);
  }
#line 540
  if (file_stats.st_size <= 0L) {
#line 541
    diag(1, "Warning: Zero-length file %s", filename, 0);
  }
#line 543
  fileptr.size = (unsigned long )file_stats.st_size;
#line 544
  if ((unsigned int )fileptr.data != (unsigned int )((char *)0)) {
#line 545
    tmp___1 = xrealloc(fileptr.data, file_stats.st_size + 1L);
#line 545
    fileptr.data = tmp___1;
  } else {
#line 547
    tmp___2 = xmalloc(file_stats.st_size + 1L);
#line 547
    fileptr.data = tmp___2;
  }
#line 549
  size = read(fd, fileptr.data, fileptr.size);
#line 550
  if (size < 0) {
#line 551
    sys_error(filename);
  }
#line 552
  tmp___3 = close(fd);
#line 552
  if (tmp___3 < 0) {
#line 553
    sys_error(filename);
  }
#line 558
  if ((unsigned long )size < fileptr.size) {
#line 559
    fileptr.size = (unsigned long )size;
  }
#line 561
  if ((unsigned int )fileptr.name != (unsigned int )((char *)0)) {
#line 562
    tmp___4 = xrealloc(fileptr.name, namelen + 1);
#line 562
    fileptr.name = tmp___4;
  } else {
#line 564
    tmp___5 = xmalloc(namelen + 1);
#line 564
    fileptr.name = tmp___5;
  }
#line 565
  bcopy(filename, fileptr.name, namelen);
#line 566
  *(fileptr.name + namelen) = (char )'\000';
#line 568
  *(fileptr.data + fileptr.size) = (char )'\000';
#line 570
  return (& fileptr);
}
}
#line 581 "io.c"
struct file_buffer stdinptr  ;
#line 583 "io.c"
struct file_buffer *read_stdin(void) 
{ unsigned int size ;
  int ch ;
  register char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 586
  size = 122880U;
#line 590
  if ((unsigned int )stdinptr.data != (unsigned int )((char *)0)) {
#line 591
    free(stdinptr.data);
  }
#line 593
  tmp = xmalloc(size + 1U);
#line 593
  stdinptr.data = tmp;
#line 594
  stdinptr.size = 0UL;
#line 595
  p = stdinptr.data;
#line 596
  while (1) {
#line 598
    while (stdinptr.size < (unsigned long )size) {
#line 600
      ch = _IO_getc(stdin);
#line 601
      if (ch == -1) {
#line 602
        break;
      }
#line 604
      tmp___0 = p;
#line 604
      p ++;
#line 604
      *tmp___0 = (char )ch;
#line 605
      (stdinptr.size) ++;
    }
#line 608
    if (ch != -1) {
#line 610
      size += 16384U;
#line 611
      stdinptr.data = xrealloc(stdinptr.data, size);
#line 612
      p = stdinptr.data + stdinptr.size;
    }
#line 596
    if (! (ch != -1)) {
#line 596
      break;
    }
  }
#line 617
  stdinptr.name = (char *)"Standard Input";
#line 619
  *(stdinptr.data + stdinptr.size) = (char )'\000';
#line 621
  return (& stdinptr);
}
}
#line 641 "io.c"
void fill_buffer(void) 
{ register char *p ;
  int finished_a_line ;
  char *q ;
  int inhibited ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 650
  if ((unsigned int )bp_save != (unsigned int )((char *)0)) {
#line 652
    buf_ptr = bp_save;
#line 653
    buf_end = be_save;
#line 654
    be_save = (char *)0;
#line 654
    bp_save = be_save;
#line 657
    if ((unsigned int )buf_ptr < (unsigned int )buf_end) {
#line 658
      return;
    }
  }
#line 661
  if ((int )*in_prog_pos == 0) {
#line 663
    buf_ptr = in_prog_pos;
#line 663
    cur_line = buf_ptr;
#line 664
    had_eof = 1;
#line 665
    return;
  }
#line 669
  cur_line = in_prog_pos;
#line 669
  p = cur_line;
#line 670
  finished_a_line = 0;
#line 671
  while (1) {
#line 673
    while (1) {
#line 673
      if (! ((int )*p == 32)) {
#line 673
        if (! ((int )*p == 9)) {
#line 673
          break;
        }
      }
#line 674
      p ++;
    }
#line 675
    if ((int )*p == 47) {
#line 675
      if ((int )*(p + 1) == 42) {
        goto _L___1;
      } else {
#line 675
        if ((int )*(p + 1) == 47) {
          _L___1: /* CIL Label */ 
#line 677
          p += 2;
#line 678
          while (1) {
#line 678
            if (! ((int )*p == 32)) {
#line 678
              if (! ((int )*p == 9)) {
#line 678
                break;
              }
            }
#line 679
            p ++;
          }
#line 680
          tmp___9 = strncmp(p, "*INDENT-OFF*", 12);
#line 680
          if (! tmp___9) {
#line 682
            q = cur_line;
#line 683
            inhibited = 1;
#line 685
            if ((unsigned int )s_com != (unsigned int )e_com) {
#line 686
              dump_line();
            } else {
#line 685
              if ((unsigned int )s_lab != (unsigned int )e_lab) {
#line 686
                dump_line();
              } else {
#line 685
                if ((unsigned int )s_code != (unsigned int )e_code) {
#line 686
                  dump_line();
                }
              }
            }
#line 687
            while ((unsigned int )q < (unsigned int )p) {
#line 688
              tmp = q;
#line 688
              q ++;
#line 688
              _IO_putc((int )*tmp, output);
            }
#line 689
            while (1) {
#line 691
              while (1) {
#line 691
                if ((int )*p != 0) {
#line 691
                  if (! ((int )*p != 10)) {
#line 691
                    break;
                  }
                } else {
#line 691
                  break;
                }
#line 692
                tmp___0 = p;
#line 692
                p ++;
#line 692
                _IO_putc((int )*tmp___0, output);
              }
#line 693
              if ((int )*p == 0) {
#line 693
                if ((unsigned long )(p - current_input->data) == current_input->size) {
#line 696
                  in_prog_pos = p;
#line 696
                  buf_end = in_prog_pos;
#line 696
                  buf_ptr = buf_end;
#line 697
                  had_eof = 1;
#line 698
                  return;
                }
              }
#line 701
              if ((int )*p == 10) {
#line 702
                cur_line = p + 1;
              }
#line 703
              tmp___1 = p;
#line 703
              p ++;
#line 703
              _IO_putc((int )*tmp___1, output);
#line 704
              while (1) {
#line 704
                if (! ((int )*p == 32)) {
#line 704
                  if (! ((int )*p == 9)) {
#line 704
                    break;
                  }
                }
#line 705
                tmp___2 = p;
#line 705
                p ++;
#line 705
                _IO_putc((int )*tmp___2, output);
              }
#line 706
              if ((int )*p == 47) {
#line 706
                if ((int )*(p + 1) == 42) {
                  goto _L___0;
                } else {
#line 706
                  if ((int )*(p + 1) == 47) {
                    _L___0: /* CIL Label */ 
#line 710
                    tmp___3 = p;
#line 710
                    p ++;
#line 710
                    _IO_putc((int )*tmp___3, output);
#line 711
                    tmp___4 = p;
#line 711
                    p ++;
#line 711
                    _IO_putc((int )*tmp___4, output);
#line 712
                    while (1) {
#line 712
                      if (! ((int )*p == 32)) {
#line 712
                        if (! ((int )*p == 9)) {
#line 712
                          break;
                        }
                      }
#line 713
                      tmp___5 = p;
#line 713
                      p ++;
#line 713
                      _IO_putc((int )*tmp___5, output);
                    }
#line 714
                    tmp___8 = strncmp(p, "*INDENT-ON*", 11);
#line 714
                    if (! tmp___8) {
#line 716
                      while (1) {
#line 718
                        while (1) {
#line 718
                          if ((int )*p != 0) {
#line 718
                            if (! ((int )*p != 10)) {
#line 718
                              break;
                            }
                          } else {
#line 718
                            break;
                          }
#line 719
                          tmp___6 = p;
#line 719
                          p ++;
#line 719
                          _IO_putc((int )*tmp___6, output);
                        }
#line 720
                        if ((int )*p == 0) {
#line 720
                          if ((unsigned long )(p - current_input->data) == current_input->size) {
#line 723
                            in_prog_pos = p;
#line 723
                            buf_end = in_prog_pos;
#line 723
                            buf_ptr = buf_end;
#line 724
                            had_eof = 1;
#line 725
                            return;
                          } else {
                            goto _L;
                          }
                        } else {
                          _L: /* CIL Label */ 
#line 729
                          if ((int )*p == 10) {
#line 731
                            inhibited = 0;
#line 732
                            cur_line = p + 1;
                          }
#line 734
                          tmp___7 = p;
#line 734
                          p ++;
#line 734
                          _IO_putc((int )*tmp___7, output);
                        }
#line 716
                        if (! inhibited) {
#line 716
                          break;
                        }
                      }
                    }
                  }
                }
              }
#line 689
              if (! inhibited) {
#line 689
                break;
              }
            }
          }
        }
      }
    }
#line 745
    while (1) {
#line 745
      if ((int )*p != 0) {
#line 745
        if (! ((int )*p != 10)) {
#line 745
          break;
        }
      } else {
#line 745
        break;
      }
#line 746
      p ++;
    }
#line 749
    if ((int )*p == 10) {
#line 751
      finished_a_line = 1;
#line 752
      in_prog_pos = p + 1;
    } else {
#line 755
      if ((unsigned long )(p - current_input->data) < current_input->size) {
#line 757
        diag(0, "Warning: File %s contains NULL-characters\n", current_input->name,
             0);
#line 759
        p ++;
      } else {
#line 764
        in_prog_pos = p;
#line 765
        finished_a_line = 1;
      }
    }
#line 671
    if (! (! finished_a_line)) {
#line 671
      break;
    }
  }
#line 770
  buf_ptr = cur_line;
#line 771
  buf_end = in_prog_pos;
#line 772
  return;
}
}
#line 778 "io.c"
__inline int pad_output(int current_column___0 , int target_column ) 
{ register int offset ;

  {
#line 783
  if (troff) {
#line 785
    fprintf((FILE * __restrict  )output, (char const   * __restrict  )"\\h\'|%dp\'",
            (target_column - 1) * 7);
#line 786
    return (0);
  }
#line 789
  if (current_column___0 >= target_column) {
#line 790
    return (current_column___0);
  }
#line 792
  if (tabsize > 1) {
#line 796
    offset = tabsize - (current_column___0 - 1) % tabsize;
#line 797
    while (current_column___0 + offset <= target_column) {
#line 799
      _IO_putc('\t', output);
#line 800
      current_column___0 += offset;
#line 801
      offset = tabsize;
    }
  }
#line 805
  while (current_column___0 < target_column) {
#line 807
    _IO_putc(' ', output);
#line 808
    current_column___0 ++;
  }
#line 811
  return (current_column___0);
}
}
#line 821 "io.c"
int diag(int level , char *msg , unsigned int a , unsigned int b ) 
{ char const   *tmp ;

  {
#line 826
  if (level) {
#line 827
    found_err = 1;
  }
#line 829
  if (level == 0) {
#line 829
    tmp = "Warning";
  } else {
#line 829
    tmp = "Error";
  }
#line 829
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent:%s:%d: %s: ",
          in_name, line_no, tmp);
#line 832
  if (msg) {
#line 833
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )msg, a, b);
  }
#line 835
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 836
  return (0);
}
}
#line 838 "io.c"
int writefdef(struct fstate *f , unsigned int nm ) 
{ 

  {
#line 842
  fprintf((FILE * __restrict  )output, (char const   * __restrict  )".ds f%c %s\n.nr s%c %d\n",
          (int )nm, f->font, nm, (int )f->size);
#line 844
  return (0);
}
}
#line 849 "io.c"
char *chfont(struct fstate *of , struct fstate *nf , char *s ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 854
  if ((int )of->font[0] != (int )nf->font[0]) {
    goto _L;
  } else {
#line 854
    if ((int )of->font[1] != (int )nf->font[1]) {
      _L: /* CIL Label */ 
#line 857
      tmp = s;
#line 857
      s ++;
#line 857
      *tmp = (char )'\\';
#line 858
      tmp___0 = s;
#line 858
      s ++;
#line 858
      *tmp___0 = (char )'f';
#line 859
      if (nf->font[1]) {
#line 861
        tmp___1 = s;
#line 861
        s ++;
#line 861
        *tmp___1 = (char )'(';
#line 862
        tmp___2 = s;
#line 862
        s ++;
#line 862
        *tmp___2 = nf->font[0];
#line 863
        tmp___3 = s;
#line 863
        s ++;
#line 863
        *tmp___3 = nf->font[1];
      } else {
#line 866
        tmp___4 = s;
#line 866
        s ++;
#line 866
        *tmp___4 = nf->font[0];
      }
    }
  }
#line 868
  if ((int )nf->size != (int )of->size) {
#line 870
    tmp___5 = s;
#line 870
    s ++;
#line 870
    *tmp___5 = (char )'\\';
#line 871
    tmp___6 = s;
#line 871
    s ++;
#line 871
    *tmp___6 = (char )'s';
#line 872
    if ((int )nf->size < (int )of->size) {
#line 874
      tmp___7 = s;
#line 874
      s ++;
#line 874
      *tmp___7 = (char )'-';
#line 875
      tmp___8 = s;
#line 875
      s ++;
#line 875
      *tmp___8 = (char )((48 + (int )of->size) - (int )nf->size);
    } else {
#line 879
      tmp___9 = s;
#line 879
      s ++;
#line 879
      *tmp___9 = (char )'+';
#line 880
      tmp___10 = s;
#line 880
      s ++;
#line 880
      *tmp___10 = (char )((48 + (int )nf->size) - (int )of->size);
    }
  }
#line 883
  return (s);
}
}
#line 886 "io.c"
void parsefont(struct fstate *f , char *s0 ) 
{ register char *s ;
  int sizedelta ;
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 891
  s = s0;
#line 892
  sizedelta = 0;
#line 895
  f->size = (char)0;
#line 896
  f->allcaps = 1;
#line 897
  i = 0;
#line 897
  while (i < 4) {
#line 898
    f->font[i] = (char)0;
#line 897
    i ++;
  }
#line 900
  while (*s) {
#line 902
    tmp___0 = __ctype_b_loc();
#line 902
    if ((int const   )*(*tmp___0 + (int )*s) & 2048) {
#line 903
      f->size = (char )(((int )f->size * 10 + (int )*s) - 48);
    } else {
#line 904
      tmp = __ctype_b_loc();
#line 904
      if ((int const   )*(*tmp + (int )*s) & 256) {
#line 905
        if (f->font[0]) {
#line 906
          f->font[1] = *s;
        } else {
#line 908
          f->font[0] = *s;
        }
      } else {
#line 909
        if ((int )*s == 99) {
#line 910
          f->allcaps = 1;
        } else {
#line 911
          if ((int )*s == 43) {
#line 912
            sizedelta ++;
          } else {
#line 913
            if ((int )*s == 45) {
#line 914
              sizedelta --;
            } else {
#line 917
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: bad font specification: %s\n",
                      s0);
#line 918
              exit(1);
            }
          }
        }
      }
    }
#line 920
    s ++;
  }
#line 922
  if ((int )f->font[0] == 0) {
#line 923
    f->font[0] = (char )'R';
  }
#line 924
  if ((int )bodyf.size == 0) {
#line 925
    bodyf.size = (char)11;
  }
#line 926
  if ((int )f->size == 0) {
#line 927
    f->size = (char )((int )bodyf.size + sizedelta);
  } else {
#line 928
    if (sizedelta > 0) {
#line 929
      f->size = (char )((int )f->size + (int )bodyf.size);
    } else {
#line 931
      f->size = (char )((int )bodyf.size - (int )f->size);
    }
  }
#line 932
  return;
}
}
#line 1 "lexi.o"
#pragma merger(0,"/tmp/cil-PV15ZRWC.i","-O")
#line 101 "indent.h"
char *token  ;
#line 103 "indent.h"
char *token_end  ;
#line 133
int pointer_as_binop ;
#line 46 "lexi.c"
static struct templ *user_specials  =    (struct templ *)0;
#line 49 "lexi.c"
static unsigned int user_specials_max  ;
#line 52 "lexi.c"
static unsigned int user_specials_idx  ;
#line 54 "lexi.c"
char chartype[128]  = 
#line 54
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)3,      (char)0,      (char)0, 
        (char)1,      (char)3,      (char)3,      (char)0, 
        (char)0,      (char)0,      (char)3,      (char)3, 
        (char)0,      (char)3,      (char)0,      (char)3, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)0,      (char)0, 
        (char)3,      (char)3,      (char)3,      (char)3, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)0,      (char)0,      (char)3,      (char)1, 
        (char)0,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)1, 
        (char)1,      (char)1,      (char)1,      (char)0, 
        (char)3,      (char)0,      (char)3,      (char)0};
#line 93
__inline static int hash(char *str , unsigned int len ) ;
#line 93 "lexi.c"
static unsigned char hash_table[128]  = 
#line 93
  {      (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)6,      (unsigned char)9, 
        (unsigned char)10,      (unsigned char)0,      (unsigned char)16,      (unsigned char)5, 
        (unsigned char)4,      (unsigned char)24,      (unsigned char)42,      (unsigned char)0, 
        (unsigned char)20,      (unsigned char)4,      (unsigned char)20,      (unsigned char)0, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)6,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)10,      (unsigned char)10,      (unsigned char)2, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42, 
        (unsigned char)42,      (unsigned char)42,      (unsigned char)42,      (unsigned char)42};
#line 87 "lexi.c"
__inline static int hash(char *str , unsigned int len ) 
{ 

  {
#line 109
  return ((int )((len + (unsigned int )hash_table[*(str + (len - 1U))]) + (unsigned int )hash_table[*(str + 0)]));
}
}
#line 120
__inline struct templ *is_reserved(char *str , unsigned int len ) ;
#line 120 "lexi.c"
static struct templ wordlist[43]  = 
#line 120
  {      {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"else", 7}, 
        {(char *)"short", 5}, 
        {(char *)"struct", 4}, 
        {(char *)"while", 6}, 
        {(char *)"enum", 4}, 
        {(char *)"goto", 1}, 
        {(char *)"switch", 2}, 
        {(char *)"break", 1}, 
        {(char *)"do", 7}, 
        {(char *)"case", 3}, 
        {(char *)"const", 5}, 
        {(char *)"static", 5}, 
        {(char *)"double", 5}, 
        {(char *)"default", 3}, 
        {(char *)"volatile", 5}, 
        {(char *)"char", 5}, 
        {(char *)"register", 5}, 
        {(char *)"float", 5}, 
        {(char *)"sizeof", 8}, 
        {(char *)"typedef", 5}, 
        {(char *)"void", 5}, 
        {(char *)"for", 6}, 
        {(char *)"extern", 5}, 
        {(char *)"int", 5}, 
        {(char *)"unsigned", 5}, 
        {(char *)"long", 5}, 
        {(char *)"", 0}, 
        {(char *)"global", 5}, 
        {(char *)"return", 9}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"union", 4}, 
        {(char *)"va_dcl", 5}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"", 0}, 
        {(char *)"if", 6}};
#line 113 "lexi.c"
__inline struct templ *is_reserved(char *str , unsigned int len ) 
{ register int key ;
  int tmp ;
  register char *s ;
  int tmp___0 ;

  {
#line 159
  if (len <= 8U) {
#line 159
    if (len >= 2U) {
#line 161
      tmp = hash(str, len);
#line 161
      key = tmp;
#line 163
      if (key <= 42) {
#line 163
        if (key >= 4) {
#line 165
          s = wordlist[key].rwd;
#line 167
          if ((int )*s == (int )*str) {
#line 167
            tmp___0 = strncmp(str + 1, s + 1, len - 1U);
#line 167
            if (! tmp___0) {
#line 168
              return (& wordlist[key]);
            }
          }
        }
      }
    }
  }
#line 171
  return ((struct templ *)0);
}
}
#line 181 "lexi.c"
static enum codes last_code  ;
#line 182 "lexi.c"
static int l_struct  ;
#line 176 "lexi.c"
enum codes lexi(void) 
{ int unary_delim ;
  enum codes code ;
  char qchar ;
  register struct templ *p ;
  int seendot ;
  int seenexp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *q ;
  char *r ;
  char *tmp___3 ;
  char *tmp___4 ;
  register char *tp ;
  int paren_count ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  char const   *tmp___8 ;

  {
#line 186
  unary_delim = 0;
#line 189
  parser_state_tos->col_1 = parser_state_tos->last_nl;
#line 190
  parser_state_tos->last_nl = 0;
#line 192
  while (1) {
#line 192
    if (! ((int )*buf_ptr == 32)) {
#line 192
      if (! ((int )*buf_ptr == 9)) {
#line 192
        break;
      }
    }
#line 194
    parser_state_tos->col_1 = 0;
#line 196
    buf_ptr ++;
#line 196
    if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 197
      fill_buffer();
    }
  }
#line 200
  token = buf_ptr;
#line 203
  if ((int )chartype[*buf_ptr] == 1) {
    goto _L___6;
  } else {
#line 203
    if ((int )*(buf_ptr + 0) == 46) {
#line 203
      tmp___7 = __ctype_b_loc();
#line 203
      if ((int const   )*(*tmp___7 + (int )*(buf_ptr + 1)) & 2048) {
        _L___6: /* CIL Label */ 
#line 209
        tmp___1 = __ctype_b_loc();
#line 209
        if ((int const   )*(*tmp___1 + (int )*buf_ptr) & 2048) {
          goto _L___2;
        } else {
#line 209
          if ((int )*(buf_ptr + 0) == 46) {
#line 209
            tmp___2 = __ctype_b_loc();
#line 209
            if ((int const   )*(*tmp___2 + (int )*(buf_ptr + 1)) & 2048) {
              _L___2: /* CIL Label */ 
#line 211
              seendot = 0;
#line 211
              seenexp = 0;
#line 212
              if ((int )*buf_ptr == 48) {
#line 212
                if ((int )*(buf_ptr + 1) == 120) {
                  goto _L___1;
                } else {
#line 212
                  if ((int )*(buf_ptr + 1) == 88) {
                    _L___1: /* CIL Label */ 
#line 215
                    buf_ptr += 2;
#line 216
                    while (1) {
#line 216
                      tmp = __ctype_b_loc();
#line 216
                      if (! ((int const   )*(*tmp + (int )*buf_ptr) & 4096)) {
#line 216
                        break;
                      }
#line 217
                      buf_ptr ++;
                    }
                  } else {
                    goto _L___0;
                  }
                }
              } else {
                _L___0: /* CIL Label */ 
#line 220
                while (1) {
#line 222
                  if ((int )*buf_ptr == 46) {
#line 223
                    if (seendot) {
#line 224
                      break;
                    } else {
#line 226
                      seendot ++;
                    }
                  }
#line 227
                  buf_ptr ++;
#line 228
                  tmp___0 = __ctype_b_loc();
#line 228
                  if (! ((int const   )*(*tmp___0 + (int )*buf_ptr) & 2048)) {
#line 228
                    if ((int )*buf_ptr != 46) {
#line 229
                      if ((int )*buf_ptr != 69) {
#line 229
                        if ((int )*buf_ptr != 101) {
#line 230
                          break;
                        } else {
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
#line 229
                        if (seenexp) {
#line 230
                          break;
                        } else {
#line 233
                          seenexp ++;
#line 234
                          seendot ++;
#line 235
                          buf_ptr ++;
#line 236
                          if ((int )*buf_ptr == 43) {
#line 237
                            buf_ptr ++;
                          } else {
#line 236
                            if ((int )*buf_ptr == 45) {
#line 237
                              buf_ptr ++;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
#line 244
              if ((int )*buf_ptr == 70) {
#line 245
                buf_ptr ++;
              } else {
#line 244
                if ((int )*buf_ptr == 102) {
#line 245
                  buf_ptr ++;
                } else {
#line 248
                  if ((int )*buf_ptr == 85) {
#line 249
                    buf_ptr ++;
                  } else {
#line 248
                    if ((int )*buf_ptr == 117) {
#line 249
                      buf_ptr ++;
                    }
                  }
#line 250
                  if ((int )*buf_ptr == 76) {
#line 251
                    buf_ptr ++;
                  } else {
#line 250
                    if ((int )*buf_ptr == 108) {
#line 251
                      buf_ptr ++;
                    }
                  }
#line 252
                  if ((int )*buf_ptr == 76) {
#line 253
                    buf_ptr ++;
                  } else {
#line 252
                    if ((int )*buf_ptr == 108) {
#line 253
                      buf_ptr ++;
                    }
                  }
                }
              }
            } else {
              goto _L___3;
            }
          } else {
            _L___3: /* CIL Label */ 
#line 257
            while ((int )chartype[*buf_ptr] == 1) {
#line 259
              buf_ptr ++;
#line 260
              if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 261
                fill_buffer();
              }
            }
          }
        }
#line 263
        token_end = buf_ptr;
#line 264
        while (1) {
#line 264
          if (! ((int )*buf_ptr == 32)) {
#line 264
            if (! ((int )*buf_ptr == 9)) {
#line 264
              break;
            }
          }
#line 266
          buf_ptr ++;
#line 266
          if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 267
            fill_buffer();
          }
        }
#line 269
        parser_state_tos->its_a_keyword = 0;
#line 270
        parser_state_tos->sizeof_keyword = 0;
#line 274
        if (l_struct) {
#line 276
          l_struct = 0;
#line 277
          last_code = 13;
#line 278
          parser_state_tos->last_u_d = 1;
#line 279
          return (20);
        }
#line 283
        parser_state_tos->last_u_d = 0;
#line 284
        last_code = 13;
#line 287
        p = is_reserved(token, (unsigned int )(token_end - token));
#line 289
        if (! p) {
#line 289
          if ((unsigned int )user_specials != (unsigned int )((struct templ *)0)) {
#line 291
            p = user_specials + 0;
#line 291
            while ((unsigned int )p < (unsigned int )((user_specials + 0) + user_specials_idx)) {
#line 295
              q = token;
#line 296
              r = p->rwd;
#line 301
              while (1) {
#line 305
                if ((unsigned int )q >= (unsigned int )token_end) {
#line 305
                  if (! *r) {
                    goto found_keyword;
                  }
                }
#line 310
                if ((unsigned int )q >= (unsigned int )token_end) {
#line 311
                  break;
                } else {
#line 310
                  if (! *r) {
#line 311
                    break;
                  }
                }
#line 315
                tmp___3 = q;
#line 315
                q ++;
#line 315
                tmp___4 = r;
#line 315
                r ++;
#line 315
                if ((int )*tmp___3 != (int )*tmp___4) {
#line 316
                  break;
                }
              }
#line 291
              p ++;
            }
#line 320
            p = (struct templ *)0;
          }
        }
#line 323
        if (p) {
          found_keyword: 
#line 326
          parser_state_tos->its_a_keyword = 1;
#line 327
          parser_state_tos->last_u_d = 1;
#line 328
          parser_state_tos->last_rw = p->rwcode;
#line 329
          switch ((int )p->rwcode) {
          case 2: 
#line 332
          return (17);
          case 3: 
#line 334
          return (8);
          case 4: 
#line 337
          if (parser_state_tos->p_l_follow) {
#line 337
            if (! (parser_state_tos->noncast_mask & (1 << parser_state_tos->p_l_follow))) {
#line 342
              parser_state_tos->cast_mask |= 1 << parser_state_tos->p_l_follow;
#line 344
              break;
            }
          }
#line 346
          l_struct = 1;
          case 5: 
#line 351
          if (parser_state_tos->p_l_follow) {
#line 351
            if (! (parser_state_tos->noncast_mask & (1 << parser_state_tos->p_l_follow))) {
#line 356
              parser_state_tos->cast_mask |= 1 << parser_state_tos->p_l_follow;
#line 358
              break;
            }
          }
#line 360
          last_code = 20;
#line 361
          return (20);
          case 6: 
#line 364
          return (21);
          case 7: 
#line 367
          return (22);
          case 8: 
#line 370
          parser_state_tos->sizeof_keyword = 1;
#line 371
          return (13);
          case 9: 
          case 1: 
          default: ;
#line 377
          return (13);
          }
        }
#line 381
        if ((int )*buf_ptr == 40) {
#line 381
          if (parser_state_tos->tos <= 1) {
#line 381
            if (parser_state_tos->ind_level == 0) {
#line 381
              if (parser_state_tos->paren_depth == 0) {
#line 389
                paren_count = 1;
#line 392
                tp = buf_ptr + 1;
#line 392
                while (1) {
#line 392
                  if (paren_count > 0) {
#line 392
                    if (! ((unsigned int )tp < (unsigned int )(in_prog + in_prog_size))) {
#line 392
                      break;
                    }
                  } else {
#line 392
                    break;
                  }
#line 396
                  if ((int )*tp == 40) {
#line 397
                    paren_count ++;
                  }
#line 398
                  if ((int )*tp == 41) {
#line 399
                    paren_count --;
                  }
#line 402
                  if ((int )*tp == 59) {
                    goto not_proc;
                  }
#line 392
                  tp ++;
                }
#line 406
                if (paren_count == 0) {
#line 408
                  while (1) {
#line 408
                    tmp___5 = __ctype_b_loc();
#line 408
                    if (! ((int const   )*(*tmp___5 + (int )*tp) & 8192)) {
#line 408
                      break;
                    }
#line 409
                    tp ++;
                  }
#line 415
                  if ((int )*tp != 59) {
#line 415
                    if ((int )*tp != 44) {
#line 415
                      if ((int )*tp != 40) {
#line 415
                        if ((int )*tp != 61) {
#line 417
                          parser_state_tos->procname = token;
#line 418
                          parser_state_tos->procname_end = token_end;
#line 419
                          parser_state_tos->in_parameter_declaration = 1;
                        }
                      }
                    }
                  }
                }
                not_proc: ;
              }
            }
          }
        }
#line 429
        if ((int )*buf_ptr == 42) {
#line 429
          if ((int )*(buf_ptr + 1) != 61) {
            goto _L___4;
          } else {
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
#line 429
          tmp___6 = __ctype_b_loc();
#line 429
          if ((int const   )*(*tmp___6 + (int )*buf_ptr) & 1024) {
            goto _L___4;
          } else {
#line 429
            if ((int )*buf_ptr == 95) {
              _L___4: /* CIL Label */ 
#line 429
              if (! parser_state_tos->p_l_follow) {
#line 429
                if (! parser_state_tos->block_init) {
#line 429
                  if ((int )parser_state_tos->last_token == 3) {
#line 439
                    parser_state_tos->its_a_keyword = 1;
#line 440
                    parser_state_tos->last_u_d = 1;
#line 441
                    last_code = 20;
#line 442
                    return (20);
                  } else {
#line 429
                    if ((int )parser_state_tos->last_token == 10) {
#line 439
                      parser_state_tos->its_a_keyword = 1;
#line 440
                      parser_state_tos->last_u_d = 1;
#line 441
                      last_code = 20;
#line 442
                      return (20);
                    } else {
#line 429
                      if ((int )parser_state_tos->last_token == 20) {
#line 439
                        parser_state_tos->its_a_keyword = 1;
#line 440
                        parser_state_tos->last_u_d = 1;
#line 441
                        last_code = 20;
#line 442
                        return (20);
                      } else {
#line 429
                        if ((int )parser_state_tos->last_token == 11) {
#line 439
                          parser_state_tos->its_a_keyword = 1;
#line 440
                          parser_state_tos->last_u_d = 1;
#line 441
                          last_code = 20;
#line 442
                          return (20);
                        } else {
#line 429
                          if ((int )parser_state_tos->last_token == 12) {
#line 439
                            parser_state_tos->its_a_keyword = 1;
#line 440
                            parser_state_tos->last_u_d = 1;
#line 441
                            last_code = 20;
#line 442
                            return (20);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 445
        if ((int )last_code == 20) {
#line 447
          parser_state_tos->last_u_d = 1;
        }
#line 448
        last_code = 13;
#line 449
        return (13);
      }
    }
  }
#line 454
  token_end = buf_ptr + 1;
#line 456
  buf_ptr ++;
#line 456
  if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 457
    fill_buffer();
  }
#line 459
  switch ((int )*token) {
  case 0: 
#line 462
  code = 0;
#line 463
  break;
  case 10: 
#line 466
  unary_delim = parser_state_tos->last_u_d;
#line 467
  parser_state_tos->last_nl = 1;
#line 468
  code = 1;
#line 469
  break;
  case 39: 
  case 34: 
#line 473
  qchar = *token;
#line 479
  while (1) {
#line 479
    if ((int )*buf_ptr != (int )qchar) {
#line 479
      if ((int )*buf_ptr != 0) {
#line 479
        if (! ((int )*buf_ptr != 10)) {
#line 479
          break;
        }
      } else {
#line 479
        break;
      }
    } else {
#line 479
      break;
    }
#line 481
    if ((int )*buf_ptr == 92) {
#line 483
      buf_ptr ++;
#line 484
      if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 485
        fill_buffer();
      }
#line 486
      if ((int )*buf_ptr == 10) {
#line 487
        line_no ++;
      }
#line 488
      if ((int )*buf_ptr == 0) {
#line 489
        break;
      }
    }
#line 491
    buf_ptr ++;
#line 492
    if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 493
      fill_buffer();
    }
  }
#line 495
  if ((int )*buf_ptr == 10) {
    goto _L___7;
  } else {
#line 495
    if ((int )*buf_ptr == 0) {
      _L___7: /* CIL Label */ 
#line 497
      if ((int )qchar == 39) {
#line 497
        tmp___8 = "Unterminated character constant";
      } else {
#line 497
        tmp___8 = "Unterminated string constant";
      }
#line 497
      diag(1, tmp___8, 0, 0);
    } else {
#line 505
      buf_ptr ++;
#line 506
      if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 507
        fill_buffer();
      }
    }
  }
#line 510
  code = 13;
#line 511
  break;
  case 40: 
  case 91: 
#line 515
  unary_delim = 1;
#line 516
  code = 2;
#line 517
  break;
  case 41: 
  case 93: 
#line 521
  code = 3;
#line 522
  break;
  case 35: 
#line 525
  unary_delim = parser_state_tos->last_u_d;
#line 526
  code = 18;
#line 527
  break;
  case 63: 
#line 530
  unary_delim = 1;
#line 531
  code = 7;
#line 532
  break;
  case 58: 
#line 535
  code = 9;
#line 536
  unary_delim = 1;
#line 537
  if (squest) {
#line 537
    if ((int )*e_com != 32) {
#line 539
      if ((unsigned int )e_code == (unsigned int )s_code) {
#line 540
        parser_state_tos->want_blank = 0;
      } else {
#line 542
        parser_state_tos->want_blank = 1;
      }
    }
  }
#line 544
  break;
  case 59: 
#line 547
  unary_delim = 1;
#line 548
  code = 10;
#line 549
  break;
  case 123: 
#line 552
  unary_delim = 1;
#line 567
  if (parser_state_tos->block_init) {
#line 567
    code = 2;
  } else {
#line 567
    code = 11;
  }
#line 568
  break;
  case 125: 
#line 571
  unary_delim = 1;
#line 573
  if (parser_state_tos->block_init) {
#line 573
    code = 3;
  } else {
#line 573
    code = 12;
  }
#line 575
  break;
  case 12: 
#line 578
  unary_delim = parser_state_tos->last_u_d;
#line 579
  parser_state_tos->last_nl = 1;
#line 581
  code = 19;
#line 582
  break;
  case 44: 
#line 585
  unary_delim = 1;
#line 586
  code = 14;
#line 587
  break;
  case 46: 
#line 590
  unary_delim = 0;
#line 591
  code = 34;
#line 592
  break;
  case 45: 
  case 43: 
#line 596
  if (parser_state_tos->last_u_d) {
#line 596
    code = 4;
  } else {
#line 596
    code = 5;
  }
#line 597
  unary_delim = 1;
#line 599
  if ((int )*buf_ptr == (int )*(token + 0)) {
#line 602
    buf_ptr ++;
#line 604
    if ((int )last_code == 13) {
      goto _L___8;
    } else {
#line 604
      if ((int )last_code == 3) {
        _L___8: /* CIL Label */ 
#line 606
        if (parser_state_tos->last_u_d) {
#line 606
          code = 4;
        } else {
#line 606
          code = 6;
        }
#line 608
        unary_delim = 0;
      }
    }
  } else {
#line 611
    if ((int )*buf_ptr == 61) {
#line 613
      buf_ptr ++;
    } else {
#line 614
      if ((int )*buf_ptr == 62) {
#line 617
        buf_ptr ++;
#line 618
        if (! pointer_as_binop) {
#line 620
          unary_delim = 0;
#line 621
          code = 4;
#line 622
          parser_state_tos->want_blank = 0;
        }
      }
    }
  }
#line 625
  break;
  case 61: 
#line 629
  if (parser_state_tos->in_or_st) {
#line 630
    parser_state_tos->block_init = 1;
  }
#line 632
  if ((int )*buf_ptr == 61) {
#line 633
    buf_ptr ++;
  } else {
#line 634
    if ((int )*buf_ptr == 45) {
#line 646
      diag(0, "old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n", (int )*buf_ptr,
           (int )*buf_ptr);
    } else {
#line 634
      if ((int )*buf_ptr == 43) {
#line 646
        diag(0, "old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n",
             (int )*buf_ptr, (int )*buf_ptr);
      } else {
#line 634
        if ((int )*buf_ptr == 42) {
#line 646
          diag(0, "old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n",
               (int )*buf_ptr, (int )*buf_ptr);
        } else {
#line 634
          if ((int )*buf_ptr == 38) {
#line 646
            diag(0, "old style assignment ambiguity in \"=%c\".  Assuming \"= %c\"\n",
                 (int )*buf_ptr, (int )*buf_ptr);
          }
        }
      }
    }
  }
#line 651
  code = 5;
#line 652
  unary_delim = 1;
#line 653
  break;
  case 62: 
  case 60: 
  case 33: 
#line 662
  while (1) {
#line 662
    if (! ((int )*buf_ptr == 62)) {
#line 662
      if (! ((int )*buf_ptr == 60)) {
#line 662
        if (! ((int )*buf_ptr == 61)) {
#line 662
          break;
        }
      }
    }
#line 664
    buf_ptr ++;
#line 664
    if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 665
      fill_buffer();
    }
#line 666
    if ((int )*buf_ptr == 61) {
#line 668
      buf_ptr ++;
#line 668
      if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 669
        fill_buffer();
      }
    }
  }
#line 673
  if (parser_state_tos->last_u_d) {
#line 673
    code = 4;
  } else {
#line 673
    code = 5;
  }
#line 674
  unary_delim = 1;
#line 675
  break;
  default: ;
#line 678
  if ((int )*(token + 0) == 47) {
#line 678
    if ((int )*buf_ptr == 42) {
      goto _L___9;
    } else {
#line 678
      if ((int )*buf_ptr == 47) {
        _L___9: /* CIL Label */ 
#line 682
        if ((int )*buf_ptr == 42) {
#line 683
          code = 15;
        } else {
#line 685
          code = 16;
        }
#line 687
        buf_ptr ++;
#line 687
        if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 688
          fill_buffer();
        }
#line 690
        unary_delim = parser_state_tos->last_u_d;
#line 691
        break;
      }
    }
  }
#line 694
  while (1) {
#line 694
    if (! ((int )*(buf_ptr - 1) == (int )*buf_ptr)) {
#line 694
      if (! ((int )*buf_ptr == 61)) {
#line 694
        break;
      }
    }
#line 697
    buf_ptr ++;
#line 697
    if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 698
      fill_buffer();
    }
  }
#line 700
  if (parser_state_tos->last_u_d) {
#line 700
    code = 4;
  } else {
#line 700
    code = 5;
  }
#line 701
  unary_delim = 1;
  }
#line 706
  if ((int )code != 1) {
#line 708
    l_struct = 0;
#line 709
    last_code = code;
  }
#line 711
  token_end = buf_ptr;
#line 712
  if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 713
    fill_buffer();
  }
#line 714
  parser_state_tos->last_u_d = unary_delim;
#line 716
  return (code);
}
}
#line 720 "lexi.c"
int addkey(char *key , enum rwcodes val ) 
{ register struct templ *p ;
  int tmp ;
  struct templ *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 727
  tmp = strlen(key);
#line 727
  tmp___0 = is_reserved(key, (unsigned int )tmp);
#line 727
  if ((unsigned int )tmp___0 != (unsigned int )((struct templ *)0)) {
#line 728
    return;
  }
#line 730
  if ((unsigned int )user_specials == (unsigned int )((struct templ *)0)) {
#line 732
    tmp___1 = xmalloc(5U * sizeof(struct templ ));
#line 732
    user_specials = (struct templ *)tmp___1;
#line 733
    user_specials_max = 5U;
#line 734
    user_specials_idx = 0U;
  } else {
#line 736
    if (user_specials_idx == user_specials_max) {
#line 738
      user_specials_max += 5U;
#line 739
      tmp___2 = xrealloc((char *)user_specials, user_specials_max * sizeof(struct templ ));
#line 739
      user_specials = (struct templ *)tmp___2;
    }
  }
#line 744
  tmp___3 = user_specials_idx;
#line 744
  user_specials_idx ++;
#line 744
  p = user_specials + tmp___3;
#line 745
  p->rwd = key;
#line 746
  p->rwcode = val;
#line 747
  return;
}
}
#line 1 "parse.o"
#pragma merger(0,"/tmp/cil-Qs6875qQ.i","-O")
#line 156 "indent.h"
int brace_indent ;
#line 249
int case_indent ;
#line 399 "indent.h"
struct parser_state *parser_state_tos  ;
#line 27 "parse.c"
void init_parser(void) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 30
  tmp = xmalloc(sizeof(struct parser_state ));
#line 30
  parser_state_tos = (struct parser_state *)tmp;
#line 33
  parser_state_tos->p_stack_size = 2;
#line 34
  tmp___0 = xmalloc(2U * sizeof(enum codes ));
#line 34
  parser_state_tos->p_stack = (enum codes *)tmp___0;
#line 36
  tmp___1 = xmalloc(2U * sizeof(int ));
#line 36
  parser_state_tos->il = (int *)tmp___1;
#line 38
  tmp___2 = xmalloc(2U * sizeof(int ));
#line 38
  parser_state_tos->cstk = (int *)tmp___2;
#line 40
  tmp___3 = xmalloc(sizeof(short ));
#line 40
  parser_state_tos->paren_indents = (short *)tmp___3;
#line 44
  tmp___4 = xmalloc(1000);
#line 44
  combuf = tmp___4;
#line 45
  tmp___5 = xmalloc(1000);
#line 45
  labbuf = tmp___5;
#line 46
  tmp___6 = xmalloc(1000);
#line 46
  codebuf = tmp___6;
#line 48
  save_com.size = 1000;
#line 49
  save_com.ptr = xmalloc(save_com.size);
#line 49
  save_com.end = save_com.ptr;
#line 51
  di_stack_alloc = 2;
#line 52
  tmp___7 = xmalloc((unsigned int )di_stack_alloc * sizeof(*di_stack));
#line 52
  di_stack = (int *)tmp___7;
#line 54
  return;
}
}
#line 56 "parse.c"
void reset_parser(void) 
{ 

  {
#line 59
  parser_state_tos->next = (struct parser_state *)0;
#line 60
  parser_state_tos->tos = 0;
#line 61
  parser_state_tos->paren_indents_size = 1;
#line 62
  *(parser_state_tos->p_stack + 0) = 26;
#line 63
  parser_state_tos->last_nl = 1;
#line 65
  parser_state_tos->last_token = 10;
#line 66
  parser_state_tos->box_com = 0;
#line 67
  parser_state_tos->cast_mask = 0;
#line 68
  parser_state_tos->noncast_mask = 0;
#line 69
  parser_state_tos->sizeof_mask = 0;
#line 70
  parser_state_tos->block_init = 0;
#line 71
  parser_state_tos->block_init_level = 0;
#line 72
  parser_state_tos->col_1 = 0;
#line 73
  parser_state_tos->com_col = 0;
#line 74
  parser_state_tos->dec_nest = 0;
#line 75
  parser_state_tos->i_l_follow = 0;
#line 76
  parser_state_tos->ind_level = 0;
#line 77
  parser_state_tos->last_u_d = 0;
#line 78
  parser_state_tos->p_l_follow = 0;
#line 79
  parser_state_tos->paren_level = 0;
#line 80
  parser_state_tos->paren_depth = 0;
#line 81
  parser_state_tos->search_brace = 0;
#line 82
  parser_state_tos->use_ff = 0;
#line 83
  parser_state_tos->its_a_keyword = 0;
#line 84
  parser_state_tos->sizeof_keyword = 0;
#line 85
  parser_state_tos->dumped_decl_indent = 0;
#line 86
  parser_state_tos->in_parameter_declaration = 0;
#line 87
  parser_state_tos->just_saw_decl = 0;
#line 88
  parser_state_tos->in_decl = 0;
#line 89
  parser_state_tos->decl_on_line = 0;
#line 90
  parser_state_tos->in_or_st = 0;
#line 91
  parser_state_tos->bl_line = 1;
#line 92
  parser_state_tos->want_blank = 0;
#line 93
  parser_state_tos->in_stmt = 0;
#line 94
  parser_state_tos->ind_stmt = 0;
#line 95
  parser_state_tos->procname = (char *)"\000";
#line 96
  parser_state_tos->procname_end = (char *)"\000";
#line 97
  parser_state_tos->pcase = 0;
#line 98
  parser_state_tos->dec_nest = 0;
#line 99
  *(di_stack + parser_state_tos->dec_nest) = 0;
#line 101
  l_com = (combuf + 1000) - 5;
#line 102
  l_lab = (labbuf + 1000) - 5;
#line 103
  l_code = (codebuf + 1000) - 5;
#line 104
  *(labbuf + 0) = (char )' ';
#line 104
  *(codebuf + 0) = *(labbuf + 0);
#line 104
  *(combuf + 0) = *(codebuf + 0);
#line 105
  *(labbuf + 1) = (char )'\000';
#line 105
  *(codebuf + 1) = *(labbuf + 1);
#line 105
  *(combuf + 1) = *(codebuf + 1);
#line 107
  else_if = 1;
#line 108
  else_or_endif = 0;
#line 109
  e_lab = labbuf + 1;
#line 109
  s_lab = e_lab;
#line 110
  e_code = codebuf + 1;
#line 110
  s_code = e_code;
#line 111
  e_com = combuf + 1;
#line 111
  s_com = e_com;
#line 113
  line_no = 1;
#line 114
  had_eof = 0;
#line 115
  break_comma = 0;
#line 116
  bp_save = (char *)0;
#line 117
  be_save = (char *)0;
#line 118
  if (tabsize <= 0) {
#line 119
    tabsize = 1;
  }
#line 120
  return;
}
}
#line 125 "parse.c"
int inc_pstack(void) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 128
  (parser_state_tos->tos) ++;
#line 128
  if (parser_state_tos->tos >= parser_state_tos->p_stack_size) {
#line 130
    parser_state_tos->p_stack_size *= 2;
#line 131
    tmp = xrealloc((char *)parser_state_tos->p_stack, (unsigned int )parser_state_tos->p_stack_size * sizeof(enum codes ));
#line 131
    parser_state_tos->p_stack = (enum codes *)tmp;
#line 134
    tmp___0 = xrealloc((char *)parser_state_tos->il, (unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 134
    parser_state_tos->il = (int *)tmp___0;
#line 137
    tmp___1 = xrealloc((char *)parser_state_tos->cstk, (unsigned int )parser_state_tos->p_stack_size * sizeof(int ));
#line 137
    parser_state_tos->cstk = (int *)tmp___1;
  }
#line 141
  return (parser_state_tos->tos);
}
}
#line 216
int reduce(void) ;
#line 192 "parse.c"
void parse(enum codes tk ) 
{ int i ;

  {
#line 209
  while (1) {
#line 209
    if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 32) {
#line 209
      if (! ((int )tk != 28)) {
#line 209
        break;
      }
    } else {
#line 209
      break;
    }
#line 215
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 26;
#line 216
    reduce();
  }
#line 220
  switch ((int )tk) {
  case 20: 
#line 225
  parser_state_tos->search_brace = btype_2;
#line 227
  if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) != 20) {
#line 229
    break_comma = 1;
#line 231
    inc_pstack();
#line 232
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 20;
#line 233
    *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
#line 235
    if (ljust_decl) {
#line 238
      parser_state_tos->ind_level = 0;
#line 239
      i = parser_state_tos->tos - 1;
#line 239
      while (i > 0) {
#line 240
        if ((int )*(parser_state_tos->p_stack + i) == 20) {
#line 243
          parser_state_tos->ind_level += ind_size;
        }
#line 239
        i --;
      }
#line 244
      parser_state_tos->i_l_follow = parser_state_tos->ind_level;
    }
  }
#line 247
  break;
  case 23: 
#line 250
  if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 33) {
#line 250
    if (else_if) {
#line 252
      parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
    }
  }
  case 29: 
  case 25: 
#line 256
  inc_pstack();
#line 257
  *(parser_state_tos->p_stack + parser_state_tos->tos) = tk;
#line 258
  parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 258
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
#line 260
  parser_state_tos->i_l_follow += ind_size;
#line 262
  parser_state_tos->search_brace = btype_2;
#line 263
  break;
  case 11: 
#line 266
  break_comma = 0;
#line 267
  if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 26) {
#line 270
    parser_state_tos->i_l_follow += ind_size;
  } else {
#line 267
    if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 27) {
#line 270
      parser_state_tos->i_l_follow += ind_size;
    } else {
#line 271
      if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 20) {
#line 273
        parser_state_tos->i_l_follow += ind_size;
#line 274
        if ((int )parser_state_tos->last_rw == 4) {
#line 274
          if (parser_state_tos->block_init_level == 0) {
#line 274
            if ((int )parser_state_tos->last_token != 3) {
#line 274
              if (! btype_2) {
#line 282
                parser_state_tos->ind_level += brace_indent;
#line 283
                parser_state_tos->i_l_follow += brace_indent;
              }
            }
          }
        }
      } else {
#line 288
        if ((unsigned int )s_code == (unsigned int )e_code) {
#line 292
          parser_state_tos->ind_level -= ind_size;
#line 298
          if (! btype_2) {
#line 300
            parser_state_tos->ind_level += brace_indent;
#line 301
            parser_state_tos->i_l_follow += brace_indent;
#line 302
            if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 17) {
#line 304
              case_ind += brace_indent;
            }
          }
#line 307
          if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 17) {
#line 307
            if (case_indent >= ind_size) {
#line 310
              parser_state_tos->ind_level -= ind_size;
            }
          }
        }
      }
    }
  }
#line 315
  inc_pstack();
#line 316
  *(parser_state_tos->p_stack + parser_state_tos->tos) = 11;
#line 317
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
#line 318
  inc_pstack();
#line 319
  *(parser_state_tos->p_stack + parser_state_tos->tos) = 26;
#line 321
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
#line 322
  break;
  case 24: 
#line 325
  if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 30) {
#line 328
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 328
    parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 330
    inc_pstack();
#line 331
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 24;
#line 332
    parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 332
    *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
  } else {
#line 337
    inc_pstack();
#line 338
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 24;
#line 339
    *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
#line 340
    parser_state_tos->i_l_follow += ind_size;
#line 341
    parser_state_tos->search_brace = btype_2;
  }
#line 344
  break;
  case 28: 
#line 348
  if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) != 32) {
#line 349
    diag(1, "Unmatched \'else\'", 0, 0);
  } else {
#line 353
    parser_state_tos->ind_level = *(parser_state_tos->il + parser_state_tos->tos);
#line 356
    parser_state_tos->i_l_follow = parser_state_tos->ind_level + ind_size;
#line 359
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 33;
#line 361
    parser_state_tos->search_brace = btype_2 | else_if;
  }
#line 363
  break;
  case 12: 
#line 367
  if ((int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 11) {
#line 369
    (parser_state_tos->tos) --;
#line 369
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 369
    parser_state_tos->ind_level = parser_state_tos->i_l_follow;
#line 371
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 26;
  } else {
#line 374
    diag(1, "Stmt nesting error.", 0, 0);
  }
#line 375
  break;
  case 17: 
#line 378
  inc_pstack();
#line 379
  *(parser_state_tos->p_stack + parser_state_tos->tos) = 17;
#line 380
  *(parser_state_tos->cstk + parser_state_tos->tos) = case_ind;
#line 382
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->i_l_follow;
#line 383
  case_ind = parser_state_tos->i_l_follow + case_indent;
#line 387
  parser_state_tos->i_l_follow += case_indent + ind_size;
#line 389
  parser_state_tos->search_brace = btype_2;
#line 390
  break;
  case 10: 
#line 393
  break_comma = 0;
#line 395
  if ((int )*(parser_state_tos->p_stack + parser_state_tos->tos) == 31) {
#line 397
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 26;
  } else {
#line 401
    inc_pstack();
#line 402
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 26;
#line 403
    *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
  }
#line 406
  break;
  default: 
#line 409
  diag(1, "Unknown code to parser", 0, 0);
#line 410
  return;
  }
#line 415
  reduce();
#line 429
  return;
}
}
#line 467 "parse.c"
int reduce(void) 
{ register int i ;

  {
#line 472
  while (1) {
#line 476
    switch ((int )*(parser_state_tos->p_stack + parser_state_tos->tos)) {
    case 26: 
#line 480
    switch ((int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1))) {
    case 26: 
    case 27: 
#line 486
    (parser_state_tos->tos) --;
#line 486
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 27;
#line 487
    break;
    case 29: 
#line 490
    (parser_state_tos->tos) --;
#line 490
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 30;
#line 491
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 493
    break;
    case 23: 
#line 497
    (parser_state_tos->tos) --;
#line 497
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 32;
#line 498
    i = parser_state_tos->tos - 1;
#line 498
    while (1) {
#line 498
      if ((int )*(parser_state_tos->p_stack + i) != 26) {
#line 498
        if ((int )*(parser_state_tos->p_stack + i) != 27) {
#line 498
          if (! ((int )*(parser_state_tos->p_stack + i) != 11)) {
#line 498
            break;
          }
        } else {
#line 498
          break;
        }
      } else {
#line 498
        break;
      }
#line 498
      i --;
    }
#line 503
    parser_state_tos->i_l_follow = *(parser_state_tos->il + i);
#line 507
    break;
    case 17: 
#line 511
    case_ind = *(parser_state_tos->cstk + (parser_state_tos->tos - 1));
    case 20: 
    case 33: 
    case 25: 
    case 24: 
#line 520
    (parser_state_tos->tos) --;
#line 520
    *(parser_state_tos->p_stack + parser_state_tos->tos) = 26;
#line 521
    parser_state_tos->i_l_follow = *(parser_state_tos->il + parser_state_tos->tos);
#line 522
    break;
    default: ;
#line 525
    return;
    }
#line 528
    break;
    case 24: 
#line 531
    if ((int )*(parser_state_tos->p_stack + (parser_state_tos->tos - 1)) == 30) {
#line 537
      (parser_state_tos->tos) --;
#line 537
      *(parser_state_tos->p_stack + parser_state_tos->tos) = 31;
#line 538
      break;
    } else {
#line 541
      return;
    }
    default: ;
#line 544
    return;
    }
  }
}
}
#line 555 "parse.c"
void parse_lparen_in_decl(void) 
{ 

  {
#line 558
  inc_pstack();
#line 559
  *(parser_state_tos->p_stack + parser_state_tos->tos) = 26;
#line 560
  *(parser_state_tos->il + parser_state_tos->tos) = parser_state_tos->ind_level;
#line 562
  reduce();
#line 563
  return;
}
}
#line 1 "comments.o"
#pragma merger(0,"/tmp/cil-Ey9J5G06.i","-O")
#line 173 "indent.h"
int out_coms  ;
#line 187
int star_comment_cont ;
#line 189
int comment_delimiter_on_blankline ;
#line 202
int format_col1_comments ;
#line 204
int format_comments ;
#line 256
int unindent_displace ;
#line 403
int else_endif_col ;
#line 78 "comments.c"
void print_comment(void) 
{ register int column ;
  register int format ;
  enum codes comment_type ;
  int start_column ;
  int save_length ;
  int found_column ;
  int first_comment_line ;
  int right_margin ;
  int boxed_comment ;
  int stars ;
  int blankline_delims ;
  int paragraph_break ;
  int merge_blank_comment_lines ;
  char *line_break_ptr ;
  char *save_ptr ;
  char *text_on_line ;
  char *start_delim ;
  char *end_delim ;
  char *line_preamble ;
  int line_preamble_length ;
  int visible_preamble ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int target ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *p ;
  char *tmp___12 ;
  register int nsize ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tab_width ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;

  {
#line 88
  line_break_ptr = (char *)0;
#line 89
  save_ptr = (char *)0;
#line 90
  text_on_line = (char *)0;
#line 98
  inc_pstack();
#line 102
  if ((int )*(token + 1) == 47) {
#line 103
    comment_type = 16;
  } else {
#line 105
    comment_type = 15;
  }
#line 111
  if ((int )comment_type == 16) {
#line 113
    start_delim = (char *)"//";
#line 114
    line_preamble = (char *)"// ";
#line 115
    line_preamble_length = 3;
#line 116
    visible_preamble = 1;
#line 117
    boxed_comment = 0;
#line 118
    stars = 0;
#line 119
    blankline_delims = 0;
  } else {
#line 121
    if ((int )*buf_ptr == 42) {
      goto _L;
    } else {
#line 121
      if ((int )*buf_ptr == 45) {
        goto _L;
      } else {
#line 121
        if ((int )*buf_ptr == 61) {
          goto _L;
        } else {
#line 121
          if ((int )*buf_ptr == 95) {
            _L: /* CIL Label */ 
#line 125
            tmp = current_column();
#line 125
            start_column = tmp - 2;
#line 125
            found_column = start_column;
#line 126
            parser_state_tos->com_col = found_column;
#line 127
            parser_state_tos->box_com = boxed_comment;
#line 129
            tmp___0 = e_com;
#line 129
            e_com ++;
#line 129
            *tmp___0 = (char )'/';
#line 130
            tmp___1 = e_com;
#line 130
            e_com ++;
#line 130
            *tmp___1 = (char )'*';
#line 131
            while (1) {
#line 133
              while (1) {
#line 134
                tmp___2 = e_com;
#line 134
                e_com ++;
#line 134
                tmp___3 = buf_ptr;
#line 134
                buf_ptr ++;
#line 134
                *tmp___2 = *tmp___3;
#line 133
                if ((int )*buf_ptr != 42) {
#line 133
                  if (! ((unsigned int )buf_ptr < (unsigned int )buf_end)) {
#line 133
                    break;
                  }
                } else {
#line 133
                  break;
                }
              }
#line 137
              if ((int )*buf_ptr == 42) {
#line 137
                if ((int )*(buf_ptr + 1) == 47) {
#line 139
                  if ((unsigned int )buf_ptr == (unsigned int )buf_end) {
#line 140
                    fill_buffer();
                  }
#line 141
                  buf_ptr += 2;
#line 143
                  tmp___4 = e_com;
#line 143
                  e_com ++;
#line 143
                  *tmp___4 = (char )'*';
#line 144
                  tmp___5 = e_com;
#line 144
                  e_com ++;
#line 144
                  *tmp___5 = (char )'/';
#line 145
                  *e_com = (char )'\000';
#line 146
                  (parser_state_tos->tos) --;
#line 147
                  parser_state_tos->com_col = 1;
#line 148
                  return;
                }
              }
#line 151
              if ((unsigned int )buf_ptr == (unsigned int )buf_end) {
#line 153
                if ((int )*(buf_ptr - 1) == 10) {
#line 155
                  e_com --;
#line 155
                  *e_com = (char )'\000';
#line 156
                  dump_line();
#line 157
                  parser_state_tos->com_col = 1;
                }
#line 160
                fill_buffer();
#line 161
                if (had_eof) {
#line 163
                  tmp___6 = e_com;
#line 163
                  e_com ++;
#line 163
                  *tmp___6 = (char )'\000';
#line 164
                  (parser_state_tos->tos) --;
#line 165
                  parser_state_tos->com_col = start_column;
#line 166
                  return;
                }
              }
            }
          } else {
#line 184
            start_delim = (char *)"/*";
#line 185
            end_delim = (char *)"*/";
#line 186
            line_preamble = (char *)0;
#line 187
            line_preamble_length = 0;
#line 188
            visible_preamble = 0;
#line 189
            boxed_comment = 0;
#line 190
            stars = star_comment_cont;
#line 191
            blankline_delims = comment_delimiter_on_blankline;
          }
        }
      }
    }
  }
#line 194
  paragraph_break = 0;
#line 195
  merge_blank_comment_lines = 0;
#line 196
  first_comment_line = com_lines;
#line 197
  right_margin = comment_max_col;
#line 201
  tmp___7 = current_column();
#line 201
  found_column = tmp___7 - 2;
#line 202
  if (boxed_comment) {
#line 204
    start_column = found_column;
#line 205
    format = 0;
#line 206
    blankline_delims = 0;
  } else {
#line 211
    if ((unsigned int )s_lab == (unsigned int )e_lab) {
#line 211
      if ((unsigned int )s_code == (unsigned int )e_code) {
#line 214
        if (parser_state_tos->ind_level <= 0) {
#line 216
          if (parser_state_tos->col_1) {
#line 218
            format = format_col1_comments;
#line 219
            start_column = 1;
          } else {
#line 223
            format = format_comments;
#line 224
            start_column = found_column;
          }
        } else {
#line 230
          if (parser_state_tos->col_1) {
#line 232
            format = format_col1_comments;
#line 233
            start_column = 1;
          } else {
#line 237
            format = format_comments;
#line 238
            start_column = (parser_state_tos->ind_level - unindent_displace) + 1;
#line 240
            if (start_column < 0) {
#line 241
              start_column = 1;
            }
          }
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 251
      if (parser_state_tos->decl_on_line) {
#line 252
        target = decl_com_ind;
      } else {
#line 253
        if (else_or_endif) {
#line 254
          target = else_endif_col;
        } else {
#line 256
          target = com_ind;
        }
      }
#line 260
      if ((unsigned int )s_code != (unsigned int )e_code) {
#line 261
        tmp___8 = compute_code_target();
#line 261
        start_column = count_columns(tmp___8, s_code);
      } else {
#line 264
        tmp___9 = compute_label_target();
#line 264
        start_column = count_columns(tmp___9, s_lab);
      }
#line 266
      if (start_column < target) {
#line 267
        start_column = target;
      } else {
#line 273
        if (else_or_endif) {
#line 275
          start_column ++;
#line 276
          else_or_endif = 0;
        } else {
#line 279
          start_column += (tabsize - start_column % tabsize) + 1;
        }
      }
#line 282
      format = format_comments;
    }
  }
#line 286
  if (! line_preamble) {
#line 288
    line_preamble_length = 3;
#line 289
    if (stars) {
#line 291
      line_preamble = (char *)" * ";
#line 292
      visible_preamble = 1;
    } else {
#line 296
      line_preamble = (char *)"   ";
#line 297
      visible_preamble = 0;
    }
  }
#line 303
  parser_state_tos->com_col = start_column;
#line 304
  parser_state_tos->box_com = boxed_comment;
#line 305
  if (boxed_comment) {
#line 309
    stars = 0;
#line 310
    blankline_delims = 0;
  }
#line 315
  tmp___10 = e_com;
#line 315
  e_com ++;
#line 315
  *tmp___10 = *start_delim;
#line 316
  tmp___11 = e_com;
#line 316
  e_com ++;
#line 316
  *tmp___11 = *(start_delim + 1);
#line 317
  column = start_column + 2;
#line 320
  if (blankline_delims) {
#line 322
    p = buf_ptr;
#line 324
    *e_com = (char )'\000';
#line 325
    dump_line();
#line 329
    while (1) {
#line 329
      if (! ((int )*p == 32)) {
#line 329
        if (! ((int )*p == 9)) {
#line 329
          break;
        }
      }
#line 330
      p ++;
    }
#line 331
    if ((int )*p == 10) {
#line 332
      buf_ptr = p + 1;
    } else {
#line 333
      if (format) {
#line 334
        buf_ptr = p;
      }
    }
#line 335
    if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 336
      fill_buffer();
    }
#line 338
    column = start_column;
    goto begin_line;
  } else {
#line 341
    if (format) {
#line 343
      tmp___12 = e_com;
#line 343
      e_com ++;
#line 343
      *tmp___12 = (char )' ';
#line 344
      column = start_column + 3;
#line 345
      while (1) {
#line 345
        if (! ((int )*buf_ptr == 32)) {
#line 345
          if (! ((int )*buf_ptr == 9)) {
#line 345
            break;
          }
        }
#line 346
        buf_ptr ++;
#line 346
        if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 347
          fill_buffer();
        }
      }
    }
  }
#line 351
  while (! had_eof) {
#line 354
    while (! had_eof) {
#line 356
      if ((unsigned int )e_com >= (unsigned int )l_com) {
#line 356
        nsize = (l_com - s_com) + 400;
#line 356
        tmp___13 = xrealloc(combuf, nsize);
#line 356
        combuf = tmp___13;
#line 356
        e_com = (combuf + (e_com - s_com)) + 1;
#line 356
        l_com = (combuf + nsize) - 5;
#line 356
        s_com = combuf + 1;
      }
#line 358
      switch ((int )*buf_ptr) {
      case 32: 
      case 9: 
#line 365
      if (format) {
#line 365
        if ((unsigned int )line_break_ptr < (unsigned int )text_on_line) {
#line 366
          line_break_ptr = e_com;
        }
      }
#line 368
      if ((int )*buf_ptr == 32) {
#line 370
        tmp___14 = e_com;
#line 370
        e_com ++;
#line 370
        *tmp___14 = (char )' ';
#line 371
        column ++;
      } else {
#line 378
        tab_width = tabsize - (((column + found_column) - start_column) - 1) % tabsize;
#line 381
        column += tab_width;
#line 382
        while (1) {
#line 382
          tmp___16 = tab_width;
#line 382
          tab_width --;
#line 382
          if (! tmp___16) {
#line 382
            break;
          }
#line 383
          tmp___15 = e_com;
#line 383
          e_com ++;
#line 383
          *tmp___15 = (char )' ';
        }
      }
#line 385
      break;
      case 10: 
#line 390
      if ((int )comment_type == 16) {
#line 392
        dump_line();
#line 393
        buf_ptr ++;
#line 394
        if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 395
          fill_buffer();
        }
#line 397
        (parser_state_tos->tos) --;
#line 398
        parser_state_tos->com_col = start_column;
#line 399
        return;
      }
#line 402
      if (format) {
#line 407
        buf_ptr ++;
#line 408
        if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 409
          fill_buffer();
        }
#line 412
        if ((int )*buf_ptr == 10) {
#line 414
          paragraph_break = 1;
          goto end_line;
        } else {
#line 412
          if (! text_on_line) {
#line 414
            paragraph_break = 1;
            goto end_line;
          }
        }
#line 420
        line_break_ptr = e_com;
#line 421
        tmp___17 = e_com;
#line 421
        e_com ++;
#line 421
        *tmp___17 = (char )' ';
#line 422
        column ++;
#line 423
        while (1) {
#line 423
          if (! ((int )*buf_ptr == 9)) {
#line 423
            if (! ((int )*buf_ptr == 32)) {
#line 423
              break;
            }
          }
#line 424
          tmp___18 = buf_ptr;
#line 424
          buf_ptr ++;
#line 424
          if ((unsigned int )tmp___18 >= (unsigned int )buf_end) {
#line 425
            fill_buffer();
          }
        }
#line 426
        continue;
      } else {
        goto end_line;
      }
#line 432
      break;
      case 42: 
#line 436
      if ((int )comment_type == 15) {
#line 438
        if ((int )*(buf_ptr + 1) == 47) {
#line 443
          if (! boxed_comment) {
#line 445
            if (text_on_line) {
#line 447
              if (blankline_delims) {
#line 449
                *e_com = (char )'\000';
#line 450
                dump_line();
#line 451
                tmp___19 = e_com;
#line 451
                e_com ++;
#line 451
                *tmp___19 = (char )' ';
              } else {
#line 455
                if ((int )*(e_com - 1) != 32) {
#line 455
                  if ((int )*(e_com - 1) != 9) {
#line 456
                    tmp___20 = e_com;
#line 456
                    e_com ++;
#line 456
                    *tmp___20 = (char )' ';
                  }
                }
              }
            } else {
#line 461
              if ((unsigned int )s_com == (unsigned int )e_com) {
#line 464
                e_com = s_com;
#line 465
                tmp___21 = e_com;
#line 465
                e_com ++;
#line 465
                *tmp___21 = (char )' ';
              } else {
#line 461
                if ((int )*s_com != 47) {
#line 464
                  e_com = s_com;
#line 465
                  tmp___21 = e_com;
#line 465
                  e_com ++;
#line 465
                  *tmp___21 = (char )' ';
                } else {
#line 472
                  if ((int )*(e_com - 1) != 32) {
#line 472
                    if ((int )*(e_com - 1) != 9) {
#line 473
                      tmp___22 = e_com;
#line 473
                      e_com ++;
#line 473
                      *tmp___22 = (char )' ';
                    }
                  }
                }
              }
            }
          }
#line 477
          tmp___23 = e_com;
#line 477
          e_com ++;
#line 477
          *tmp___23 = (char )'*';
#line 478
          tmp___24 = e_com;
#line 478
          e_com ++;
#line 478
          *tmp___24 = (char )'/';
#line 479
          *e_com = (char )'\000';
#line 484
          buf_ptr += 2;
#line 485
          while (1) {
#line 485
            if (! ((int )*buf_ptr == 32)) {
#line 485
              if (! ((int )*buf_ptr == 9)) {
#line 485
                break;
              }
            }
#line 486
            buf_ptr ++;
          }
#line 487
          if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 488
            fill_buffer();
          }
#line 490
          (parser_state_tos->tos) --;
#line 491
          parser_state_tos->com_col = start_column;
#line 492
          return;
        }
#line 499
        if (first_comment_line == com_lines - 1) {
#line 499
          if ((unsigned int )e_com == (unsigned int )(s_com + line_preamble_length)) {
#line 499
            tmp___25 = current_column();
#line 499
            if (tmp___25 == found_column + 1) {
#line 503
              line_preamble = (char *)" ";
#line 504
              line_preamble_length = 1;
#line 505
              boxed_comment = 1;
#line 506
              format = 0;
#line 507
              blankline_delims = 0;
#line 508
              *s_com = (char )' ';
#line 509
              *(s_com + 1) = (char )'*';
#line 510
              e_com = s_com + 2;
#line 511
              column ++;
#line 512
              break;
            }
          }
        }
      }
      default: 
#line 520
      text_on_line = e_com;
#line 521
      tmp___26 = e_com;
#line 521
      e_com ++;
#line 521
      *tmp___26 = *buf_ptr;
#line 522
      column ++;
#line 523
      break;
      }
#line 529
      if (format) {
#line 529
        if (column > right_margin) {
#line 529
          if (line_break_ptr) {
#line 531
            if ((unsigned int )line_break_ptr < (unsigned int )(e_com - 1)) {
#line 533
              *line_break_ptr = (char )'\000';
#line 534
              save_ptr = line_break_ptr + 1;
#line 535
              save_length = e_com - save_ptr;
#line 536
              e_com = line_break_ptr;
#line 540
              if (column - save_length > right_margin) {
#line 541
                right_margin = column - save_length;
              }
            } else {
#line 544
              *e_com = (char )'\000';
            }
            goto end_line;
          }
        }
      }
#line 548
      buf_ptr ++;
#line 549
      if ((unsigned int )buf_ptr == (unsigned int )buf_end) {
#line 550
        fill_buffer();
      }
    }
    end_line: 
#line 556
    if (! text_on_line) {
#line 556
      if (! visible_preamble) {
#line 556
        if (! (first_comment_line == com_lines)) {
#line 559
          e_com = s_com;
        }
      }
    }
#line 560
    *e_com = (char )'\000';
#line 561
    dump_line();
#line 566
    if (paragraph_break) {
#line 568
      if (merge_blank_comment_lines) {
#line 569
        while (1) {
#line 569
          if (! ((int )*buf_ptr == 10)) {
#line 569
            if (! ((int )*buf_ptr == 32)) {
#line 569
              if (! ((int )*buf_ptr == 9)) {
#line 569
                break;
              }
            }
          }
#line 570
          buf_ptr ++;
#line 570
          if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 571
            fill_buffer();
          }
        }
      }
#line 572
      paragraph_break = 0;
    } else {
#line 578
      buf_ptr ++;
#line 579
      if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 580
        fill_buffer();
      }
    }
    begin_line: 
#line 584
    if (had_eof) {
#line 585
      break;
    }
#line 591
    if (line_preamble) {
#line 593
      bcopy(line_preamble, e_com, line_preamble_length);
#line 594
      e_com += line_preamble_length;
#line 595
      column = start_column + line_preamble_length;
    } else {
#line 598
      column = start_column;
    }
#line 599
    line_break_ptr = (char *)0;
#line 604
    if (save_ptr) {
#line 606
      while (1) {
#line 606
        if ((int )*save_ptr == 32) {
          goto _L___1;
        } else {
#line 606
          if ((int )*save_ptr == 9) {
            _L___1: /* CIL Label */ 
#line 606
            if (! save_length) {
#line 606
              break;
            }
          } else {
#line 606
            break;
          }
        }
#line 608
        save_ptr ++;
#line 609
        save_length --;
      }
#line 611
      bcopy(save_ptr, e_com, save_length);
#line 612
      text_on_line = e_com;
#line 613
      e_com += save_length;
#line 616
      column += save_length;
#line 617
      save_ptr = (char *)0;
    } else {
#line 621
      while (1) {
#line 621
        if (! ((int )*buf_ptr == 32)) {
#line 621
          if (! ((int )*buf_ptr == 9)) {
#line 621
            break;
          }
        }
#line 622
        buf_ptr ++;
#line 622
        if ((unsigned int )buf_ptr >= (unsigned int )buf_end) {
#line 623
          fill_buffer();
        }
      }
#line 624
      text_on_line = (char *)0;
    }
  }
#line 628
  (parser_state_tos->tos) --;
#line 629
  parser_state_tos->com_col = start_column;
#line 630
  return;
}
}
#line 1 "args.o"
#pragma merger(0,"/tmp/cil-6AD8M7IO.i","-O")
#line 602 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 132 "indent.h"
int use_stdout  ;
#line 133 "indent.h"
int pointer_as_binop  ;
#line 134 "indent.h"
int blanklines_after_declarations  ;
#line 135 "indent.h"
int blanklines_after_procs  ;
#line 136 "indent.h"
int blanklines_around_conditional_compilation  ;
#line 137 "indent.h"
int swallow_optional_blanklines  ;
#line 138 "indent.h"
int n_real_blanklines  ;
#line 139 "indent.h"
int prefix_blankline_requested  ;
#line 140 "indent.h"
int postfix_blankline_requested  ;
#line 156 "indent.h"
int brace_indent  ;
#line 159 "indent.h"
int btype_2  ;
#line 163 "indent.h"
int space_sp_semicolon  ;
#line 168 "indent.h"
int case_ind  ;
#line 183 "indent.h"
int max_col  ;
#line 184 "indent.h"
int verbose  ;
#line 186 "indent.h"
int cuddle_else  ;
#line 187 "indent.h"
int star_comment_cont  ;
#line 189 "indent.h"
int comment_delimiter_on_blankline  ;
#line 190 "indent.h"
int troff  ;
#line 191 "indent.h"
int procnames_start_line  ;
#line 195 "indent.h"
int expect_output_file  ;
#line 196 "indent.h"
int proc_calls_space  ;
#line 198 "indent.h"
int cast_space  ;
#line 202 "indent.h"
int format_col1_comments  ;
#line 204 "indent.h"
int format_comments  ;
#line 208 "indent.h"
int continuation_indent  ;
#line 210 "indent.h"
int lineup_to_parens  ;
#line 212 "indent.h"
int leave_preproc_space  ;
#line 220 "indent.h"
int blank_after_sizeof  ;
#line 222 "indent.h"
int blanklines_after_declarations_at_proctop  ;
#line 235 "indent.h"
int comment_max_col  ;
#line 236 "indent.h"
int extra_expression_indent  ;
#line 245 "indent.h"
int leave_comma  ;
#line 247 "indent.h"
int decl_com_ind  ;
#line 249 "indent.h"
int case_indent  ;
#line 251 "indent.h"
int com_ind  ;
#line 253 "indent.h"
int decl_indent  ;
#line 254 "indent.h"
int ljust_decl  ;
#line 256 "indent.h"
int unindent_displace  ;
#line 259 "indent.h"
int else_if  ;
#line 262 "indent.h"
int indent_parameters  ;
#line 264 "indent.h"
int ind_size  ;
#line 266 "indent.h"
int tabsize  ;
#line 403 "indent.h"
int else_endif_col  ;
#line 35 "args.c"
extern char *getenv() ;
#line 62 "args.c"
static int exp_T  =    0;
#line 63 "args.c"
static int exp_bacc  =    0;
#line 64 "args.c"
static int exp_badp  =    0;
#line 65 "args.c"
static int exp_bad  =    0;
#line 66 "args.c"
static int exp_bap  =    0;
#line 68 "args.c"
static int exp_bc  =    0;
#line 69 "args.c"
static int exp_bli  =    0;
#line 70 "args.c"
static int exp_bl  =    0;
#line 71 "args.c"
static int exp_bs  =    0;
#line 72 "args.c"
static int exp_cdb  =    0;
#line 73 "args.c"
static int exp_cd  =    0;
#line 74 "args.c"
static int exp_ce  =    0;
#line 75 "args.c"
static int exp_ci  =    0;
#line 76 "args.c"
static int exp_cli  =    0;
#line 77 "args.c"
static int exp_cp  =    0;
#line 78 "args.c"
static int exp_cs  =    0;
#line 79 "args.c"
static int exp_c  =    0;
#line 80 "args.c"
static int exp_di  =    0;
#line 81 "args.c"
static int exp_dj  =    0;
#line 82 "args.c"
static int exp_d  =    0;
#line 83 "args.c"
static int exp_eei  =    0;
#line 84 "args.c"
static int exp_ei  =    0;
#line 85 "args.c"
static int exp_fbc  =    0;
#line 86 "args.c"
static int exp_fbx  =    0;
#line 87 "args.c"
static int exp_fb  =    0;
#line 88 "args.c"
static int exp_fc1  =    0;
#line 89 "args.c"
static int exp_fca  =    0;
#line 90 "args.c"
static int exp_fc  =    0;
#line 91 "args.c"
static int exp_fk  =    0;
#line 92 "args.c"
static int exp_fs  =    0;
#line 93 "args.c"
static int exp_gnu  =    0;
#line 94 "args.c"
static int exp_orig  =    0;
#line 95 "args.c"
static int exp_ip  =    0;
#line 96 "args.c"
static int exp_nip  =    0;
#line 97 "args.c"
static int exp_i  =    0;
#line 98 "args.c"
static int exp_lc  =    0;
#line 99 "args.c"
static int exp_lp  =    0;
#line 100 "args.c"
static int exp_l  =    0;
#line 101 "args.c"
static int exp_lps  =    0;
#line 102 "args.c"
static int exp_pcs  =    0;
#line 103 "args.c"
static int exp_psl  =    0;
#line 104 "args.c"
static int exp_pro  =    0;
#line 105 "args.c"
static int exp_ps  =    0;
#line 106 "args.c"
static int exp_kr  =    0;
#line 107 "args.c"
static int exp_sc  =    0;
#line 108 "args.c"
static int exp_sob  =    0;
#line 109 "args.c"
static int exp_ss  =    0;
#line 110 "args.c"
static int exp_st  =    0;
#line 111 "args.c"
static int exp_troff  =    0;
#line 112 "args.c"
static int exp_ts  =    0;
#line 113 "args.c"
static int exp_v  =    0;
#line 114 "args.c"
static int exp_version  =    0;
#line 293 "args.c"
struct pro pro[79]  = 
#line 293
  {      {(char *)"T", 4, 0, 0, (int *)0, & exp_T}, 
        {(char *)"bacc", 0, 0, 2, & blanklines_around_conditional_compilation, & exp_bacc}, 
        {(char *)"badp",
      0, 0, 2, & blanklines_after_declarations_at_proctop, & exp_badp}, 
        {(char *)"bad", 0, 0, 2, & blanklines_after_declarations, & exp_bad}, 
        {(char *)"bap", 0, 1, 2, & blanklines_after_procs, & exp_bap}, 
        {(char *)"bc", 0, 1, 1, & leave_comma, & exp_bc}, 
        {(char *)"bli", 1, 2, 0, & brace_indent, & exp_bli}, 
        {(char *)"bl", 0, 1, 1, & btype_2, & exp_bl}, 
        {(char *)"br", 0, 0, 2, & btype_2, & exp_bl}, 
        {(char *)"bs", 0, 0, 2, & blank_after_sizeof, & exp_bs}, 
        {(char *)"cdb", 0, 0, 2, & comment_delimiter_on_blankline, & exp_cdb}, 
        {(char *)"cd", 1, 33, 0, & decl_com_ind, & exp_cd}, 
        {(char *)"ce", 0, 0, 2, & cuddle_else, & exp_ce}, 
        {(char *)"ci", 1, 0, 0, & continuation_indent, & exp_ci}, 
        {(char *)"cli", 1, 0, 0, & case_indent, & exp_cli}, 
        {(char *)"cp", 1, 1, 0, & else_endif_col, & exp_cp}, 
        {(char *)"cs", 0, 1, 2, & cast_space, & exp_cs}, 
        {(char *)"c", 1, 33, 0, & com_ind, & exp_c}, 
        {(char *)"di", 1, 2, 0, & decl_indent, & exp_di}, 
        {(char *)"dj", 0, 0, 2, & ljust_decl, & exp_dj}, 
        {(char *)"d", 1, 0, 0, & unindent_displace, & exp_d}, 
        {(char *)"eei", 0, 0, 2, & extra_expression_indent, & exp_eei}, 
        {(char *)"ei", 0, 1, 2, & else_if, & exp_ei}, 
        {(char *)"fbc", 2, 0, 0, (int *)(& blkcomf), & exp_fbc}, 
        {(char *)"fbx", 2, 0, 0, (int *)(& boxcomf), & exp_fbx}, 
        {(char *)"fb", 2, 0, 0, (int *)(& bodyf), & exp_fb}, 
        {(char *)"fc1", 0, 0, 2, & format_col1_comments, & exp_fc1}, 
        {(char *)"fca", 0, 0, 2, & format_comments, & exp_fca}, 
        {(char *)"fc", 2, 0, 0, (int *)(& scomf), & exp_fc}, 
        {(char *)"fk", 2, 0, 0, (int *)(& keywordf), & exp_fk}, 
        {(char *)"fs", 2, 0, 0, (int *)(& stringf), & exp_fs}, 
        {(char *)"gnu", 5, 0, 0, (int *)"-nbad\000-bap\000-nbc\000-bl\000-ncdb\000-cs\000-nce\000-di2\000-ndj\000-ei\000-nfc1\000-i2\000-ip5\000-lp\000-pcs\000-nps\000-psl\000-nsc\000-nsob\000-bli2\000-cp1\000-nfca\000",
      & exp_gnu}, 
        {(char *)"h", 7, 0, (enum on_or_off )0, (int *)(& usage), & exp_version}, 
        {(char *)"ip", 1, 5, 2, & indent_parameters, & exp_ip}, 
        {(char *)"i", 1, 2, 0, & ind_size, & exp_i}, 
        {(char *)"kr", 5, 0, 0, (int *)"-nbad\000-bap\000-nbc\000-br\000-c33\000-cd33\000-ncdb\000-ce\000-ci4\000-cli0\000-d0\000-di1\000-nfc1\000-i4\000-ip0\000-l75\000-lp\000-npcs\000-npsl\000-cs\000-nsc\000-nsc\000-nsob\000-nfca\000-cp33\000-nss\000",
      & exp_kr}, 
        {(char *)"lc", 1, 0, 0, & comment_max_col, & exp_lc}, 
        {(char *)"lps", 0, 0, 2, & leave_preproc_space, & exp_lps}, 
        {(char *)"lp", 0, 1, 2, & lineup_to_parens, & exp_lp}, 
        {(char *)"l", 1, 78, 0, & max_col, & exp_l}, 
        {(char *)"nbacc", 0, 0, 1, & blanklines_around_conditional_compilation, & exp_bacc}, 
        {(char *)"nbadp",
      0, 0, 1, & blanklines_after_declarations_at_proctop, & exp_badp}, 
        {(char *)"nbad", 0, 0, 1, & blanklines_after_declarations, & exp_bad}, 
        {(char *)"nbap", 0, 1, 1, & blanklines_after_procs, & exp_bap}, 
        {(char *)"nbc", 0, 1, 2, & leave_comma, & exp_bc}, 
        {(char *)"nbs", 0, 0, 1, & blank_after_sizeof, & exp_bs}, 
        {(char *)"ncdb", 0, 0, 1, & comment_delimiter_on_blankline, & exp_cdb}, 
        {(char *)"nce", 0, 0, 1, & cuddle_else, & exp_ce}, 
        {(char *)"ncs", 0, 1, 1, & cast_space, & exp_cs}, 
        {(char *)"ndj", 0, 0, 1, & ljust_decl, & exp_dj}, 
        {(char *)"neei", 0, 0, 1, & extra_expression_indent, & exp_eei}, 
        {(char *)"nei", 0, 1, 1, & else_if, & exp_ei}, 
        {(char *)"nfc1", 0, 0, 1, & format_col1_comments, & exp_fc1}, 
        {(char *)"nfca", 0, 0, 1, & format_comments, & exp_fca}, 
        {(char *)"nip", 5, 0, 0, (int *)"-ip0\000", & exp_nip}, 
        {(char *)"nlp", 0, 1, 1, & lineup_to_parens, & exp_lp}, 
        {(char *)"nlps", 0, 0, 1, & leave_preproc_space, & exp_lps}, 
        {(char *)"npcs", 0, 1, 1, & proc_calls_space, & exp_pcs}, 
        {(char *)"npro", 3, 0, 0, (int *)0, & exp_pro}, 
        {(char *)"npsl", 0, 1, 1, & procnames_start_line, & exp_psl}, 
        {(char *)"nps", 0, 0, 1, & pointer_as_binop, & exp_ps}, 
        {(char *)"nsc", 0, 0, 1, & star_comment_cont, & exp_sc}, 
        {(char *)"nsob", 0, 0, 1, & swallow_optional_blanklines, & exp_sob}, 
        {(char *)"nss", 0, 0, 1, & space_sp_semicolon, & exp_ss}, 
        {(char *)"nv", 0, 0, 1, & verbose, & exp_v}, 
        {(char *)"orig", 5, 0, 0, (int *)"-nbap\000-nbad\000-bc\000-br\000-c33\000-cd33\000-cdb\000-ce\000-ci4\000-cli0\000-cp33\000-di16\000-fc1\000-fca\000-i4\000-ip4\000-l75\000-lp\000-npcs\000-psl\000-sc\000-nsob\000-nss\000-ts8\000",
      & exp_orig}, 
        {(char *)"o", 0, 0, 2, & expect_output_file, & expect_output_file}, 
        {(char *)"pcs", 0, 1, 2, & proc_calls_space, & exp_pcs}, 
        {(char *)"psl", 0, 1, 2, & procnames_start_line, & exp_psl}, 
        {(char *)"ps", 0, 0, 2, & pointer_as_binop, & exp_ps}, 
        {(char *)"sc", 0, 0, 2, & star_comment_cont, & exp_sc}, 
        {(char *)"sob", 0, 0, 2, & swallow_optional_blanklines, & exp_sob}, 
        {(char *)"ss", 0, 0, 2, & space_sp_semicolon, & exp_ss}, 
        {(char *)"st", 0, 0, 2, & use_stdout, & exp_st}, 
        {(char *)"troff", 0, 0, 2, & troff, & exp_troff}, 
        {(char *)"ts", 1, 8, 0, & tabsize, & exp_ts}, 
        {(char *)"version", 6, 0, 0, (int *)"GNU indent 1.9.1", & exp_version}, 
        {(char *)"v", 0, 0, 2, & verbose, & exp_v}, 
        {(char *)0, 3, 0, 0, (int *)0, (int *)0}};
#line 404 "args.c"
struct long_option_conversion option_conversions[90]  = 
#line 404
  {      {(char *)"blank-lines-after-ifdefs", (char *)"bacc"}, 
        {(char *)"blank-lines-after-procedure-declarations", (char *)"badp"}, 
        {(char *)"blank-lines-after-declarations", (char *)"bad"}, 
        {(char *)"blank-lines-after-procedures", (char *)"bap"}, 
        {(char *)"blank-lines-after-block-comments", (char *)"bbb"}, 
        {(char *)"blank-lines-after-commas", (char *)"bc"}, 
        {(char *)"brace-indent", (char *)"bli"}, 
        {(char *)"braces-after-if-line", (char *)"bl"}, 
        {(char *)"braces-on-if-line", (char *)"br"}, 
        {(char *)"Bill-Shannon", (char *)"bs"}, 
        {(char *)"blank-before-sizeof", (char *)"bs"}, 
        {(char *)"comment-delimiters-on-blank-lines", (char *)"cdb"}, 
        {(char *)"declaration-comment-column", (char *)"cd"}, 
        {(char *)"cuddle-else", (char *)"ce"}, 
        {(char *)"continuation-indentation", (char *)"ci"}, 
        {(char *)"case-indentation", (char *)"cli"}, 
        {(char *)"else-endif-column", (char *)"cp"}, 
        {(char *)"space-after-cast", (char *)"cs"}, 
        {(char *)"comment-indentation", (char *)"c"}, 
        {(char *)"declaration-indentation", (char *)"di"}, 
        {(char *)"left-justify-declarations", (char *)"dj"}, 
        {(char *)"line-comments-indentation", (char *)"d"}, 
        {(char *)"extra-expression-indentation", (char *)"eei"}, 
        {(char *)"else-if", (char *)"ei"}, 
        {(char *)"*", (char *)"fbc"}, 
        {(char *)"*", (char *)"fbx"}, 
        {(char *)"*", (char *)"fb"}, 
        {(char *)"format-first-column-comments", (char *)"fc1"}, 
        {(char *)"format-all-comments", (char *)"fca"}, 
        {(char *)"*", (char *)"fc"}, 
        {(char *)"*", (char *)"fk"}, 
        {(char *)"*", (char *)"fs"}, 
        {(char *)"gnu-style", (char *)"gnu"}, 
        {(char *)"help", (char *)"h"}, 
        {(char *)"usage", (char *)"h"}, 
        {(char *)"parameter-indentation", (char *)"ip"}, 
        {(char *)"indentation-level", (char *)"i"}, 
        {(char *)"indent-level", (char *)"i"}, 
        {(char *)"k-and-r-style", (char *)"kr"}, 
        {(char *)"kernighan-and-ritchie-style", (char *)"kr"}, 
        {(char *)"kernighan-and-ritchie", (char *)"kr"}, 
        {(char *)"comment-line-length", (char *)"lc"}, 
        {(char *)"continue-at-parentheses", (char *)"lp"}, 
        {(char *)"leave-preprocessor-space", (char *)"lps"}, 
        {(char *)"remove-preprocessor-space", (char *)"nlps"}, 
        {(char *)"line-length", (char *)"l"}, 
        {(char *)"no-blank-lines-after-ifdefs", (char *)"nbacc"}, 
        {(char *)"no-blank-lines-after-procedure-declarations", (char *)"nbadp"}, 
        {(char *)"no-blank-lines-after-declarations", (char *)"nbad"}, 
        {(char *)"no-blank-lines-after-procedures", (char *)"nbap"}, 
        {(char *)"no-blank-lines-after-commas", (char *)"nbc"}, 
        {(char *)"no-Bill-Shannon", (char *)"nbs"}, 
        {(char *)"no-blank-before-sizeof", (char *)"nbs"}, 
        {(char *)"no-comment-delimiters-on-blank-lines", (char *)"ncdb"}, 
        {(char *)"dont-cuddle-else", (char *)"nce"}, 
        {(char *)"no-space-after-casts", (char *)"ncs"}, 
        {(char *)"dont-left-justify-declarations", (char *)"ndj"}, 
        {(char *)"no-extra-expression-indentation", (char *)"neei"}, 
        {(char *)"no-else-if", (char *)"nei"}, 
        {(char *)"dont-format-first-column-comments", (char *)"nfc1"}, 
        {(char *)"dont-format-comments", (char *)"nfca"}, 
        {(char *)"no-parameter-indentation", (char *)"nip"}, 
        {(char *)"dont-indent-parameters", (char *)"nip"}, 
        {(char *)"dont-line-up-parentheses", (char *)"nlp"}, 
        {(char *)"no-space-after-function-call-names", (char *)"npcs"}, 
        {(char *)"ignore-profile", (char *)"npro"}, 
        {(char *)"dont-break-procedure-type", (char *)"npsl"}, 
        {(char *)"*", (char *)"nps"}, 
        {(char *)"dont-star-comments", (char *)"nsc"}, 
        {(char *)"leave-optional-blank-lines", (char *)"nsob"}, 
        {(char *)"dont-space-special-semicolon", (char *)"nss"}, 
        {(char *)"no-verbosity", (char *)"nv"}, 
        {(char *)"output", (char *)"o"}, 
        {(char *)"output-file", (char *)"o"}, 
        {(char *)"original", (char *)"orig"}, 
        {(char *)"original-style", (char *)"orig"}, 
        {(char *)"berkeley-style", (char *)"orig"}, 
        {(char *)"berkeley", (char *)"orig"}, 
        {(char *)"space-after-procedure-calls", (char *)"pcs"}, 
        {(char *)"procnames-start-lines", (char *)"psl"}, 
        {(char *)"pointer-as-binary-op", (char *)"ps"}, 
        {(char *)"start-left-side-of-comments", (char *)"sc"}, 
        {(char *)"swallow-optional-blank-lines", (char *)"sob"}, 
        {(char *)"space-special-semicolon", (char *)"ss"}, 
        {(char *)"standard-output", (char *)"st"}, 
        {(char *)"troff-formatting", (char *)"troff"}, 
        {(char *)"tab-size", (char *)"ts"}, 
        {(char *)"version", (char *)"version"}, 
        {(char *)"verbose", (char *)"v"}, 
        {(char *)0, (char *)0}};
#line 502 "args.c"
static int eqin(char *s1 , char *s2 , char **start_param ) 
{ char *tmp ;
  char *tmp___0 ;

  {
#line 508
  while (*s1) {
#line 510
    tmp = s1;
#line 510
    s1 ++;
#line 510
    tmp___0 = s2;
#line 510
    s2 ++;
#line 510
    if ((int )*tmp != (int )*tmp___0) {
#line 511
      return (0);
    }
  }
#line 513
  *start_param = s2;
#line 514
  return (1);
}
}
#line 518 "args.c"
void set_defaults(void) 
{ register struct pro *p ;

  {
#line 523
  p = pro;
#line 523
  while (p->p_name) {
#line 524
    if ((int )p->p_type == 0) {
#line 525
      *(p->p_obj) = p->p_default;
    } else {
#line 524
      if ((int )p->p_type == 1) {
#line 525
        *(p->p_obj) = p->p_default;
      }
    }
#line 523
    p ++;
  }
#line 526
  return;
}
}
#line 529 "args.c"
static char *option_prefixes[4]  = {      (char *)"--",      (char *)"-",      (char *)"+",      (char *)0};
#line 537 "args.c"
static int option_prefix(char *arg ) 
{ register char **prefixes ;
  register char *this_prefix ;
  register char *argp ;

  {
#line 541
  prefixes = option_prefixes;
#line 544
  while (1) {
#line 546
    this_prefix = *prefixes;
#line 547
    argp = arg;
#line 548
    while ((int )*this_prefix == (int )*argp) {
#line 550
      this_prefix ++;
#line 551
      argp ++;
    }
#line 553
    if ((int )*this_prefix == 0) {
#line 554
      return (this_prefix - *prefixes);
    }
#line 544
    prefixes ++;
#line 544
    if (! *prefixes) {
#line 544
      break;
    }
  }
#line 558
  return (0);
}
}
#line 668
extern int ( /* missing proto */  strcpy)() ;
#line 693
extern int ( /* missing proto */  atoi)() ;
#line 568 "args.c"
int set_option(char *option , char *param , int explicit ) 
{ struct pro *p ;
  char *param_start ;
  register int option_length ;
  register int val ;
  int tmp ;
  register struct long_option_conversion *o ;
  int tmp___0 ;
  int tmp___1 ;
  char *t ;
  char *tmp___2 ;
  register char *str ;
  int tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 573
  p = pro;
#line 577
  val = 0;
#line 578
  option_length = option_prefix(option);
#line 579
  if (option_length > 0) {
#line 581
    if (option_length == 1) {
#line 581
      if ((int )*option == 45) {
#line 584
        option ++;
#line 585
        p = pro;
#line 585
        while (p->p_name) {
#line 586
          if ((int )*(p->p_name) == (int )*option) {
#line 586
            tmp = eqin(p->p_name, option, & param_start);
#line 586
            if (tmp) {
              goto found;
            }
          }
#line 585
          p ++;
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 593
      o = option_conversions;
#line 594
      option += option_length;
#line 596
      while (o->short_name) {
#line 598
        tmp___0 = eqin(o->long_name, option, & param_start);
#line 598
        if (tmp___0) {
#line 599
          break;
        }
#line 600
        o ++;
      }
#line 605
      if (o->short_name) {
#line 606
        p = pro;
#line 606
        while (p->p_name) {
#line 607
          tmp___1 = strcmp(p->p_name, o->short_name);
#line 607
          if (! tmp___1) {
            goto found;
          }
#line 606
          p ++;
        }
      }
    }
  }
#line 612
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: unknown option \"%s\"\n",
          option - 1);
#line 613
  exit(1);
  arg_missing: 
#line 616
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: missing argument to parameter %s\n",
          option);
#line 617
  exit(1);
  found: 
#line 623
  if (verbose) {
#line 624
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"option: %s\n",
            p->p_name);
  }
#line 625
  if (explicit) {
    goto _L___0;
  } else {
#line 625
    if (! *(p->p_explicit)) {
      _L___0: /* CIL Label */ 
#line 627
      if (explicit) {
#line 628
        *(p->p_explicit) = 1;
      }
#line 630
      switch ((int )p->p_type) {
      case 6: 
#line 634
      puts((char const   *)((char *)p->p_obj));
#line 635
      exit(0);
      case 7: 
#line 638
      (*((void (*)())p->p_obj))();
#line 639
      break;
      case 5: 
#line 645
      t = (char *)p->p_obj;
#line 646
      while (1) {
#line 648
        set_option(t, (char *)0, 0);
#line 650
        while (1) {
#line 650
          tmp___2 = t;
#line 650
          t ++;
#line 650
          if (! *tmp___2) {
#line 650
            break;
          }
        }
#line 646
        if (! *t) {
#line 646
          break;
        }
      }
      case 3: 
#line 656
      break;
      case 4: 
#line 661
      if ((int )*param_start == 0) {
#line 662
        param_start = param;
#line 662
        if (param_start) {
#line 665
          val = 1;
        } else {
          goto arg_missing;
        }
      }
#line 667
      tmp___3 = strlen(param_start);
#line 667
      tmp___4 = xmalloc(tmp___3 + 1);
#line 667
      str = tmp___4;
#line 668
      strcpy(str, param_start);
#line 669
      addkey(str, 5);
#line 671
      break;
      case 0: 
#line 674
      if ((int )p->p_special == 1) {
#line 675
        *(p->p_obj) = 0;
      } else {
#line 677
        *(p->p_obj) = 1;
      }
#line 678
      break;
      case 1: 
#line 681
      if ((int )*param_start == 0) {
#line 682
        param_start = param;
#line 682
        if (param_start) {
#line 685
          val = 1;
        } else {
          goto arg_missing;
        }
      }
#line 686
      tmp___5 = __ctype_b_loc();
#line 686
      if (! ((int const   )*(*tmp___5 + (int )*param_start) & 2048)) {
#line 688
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: option ``%s\'\' requires a numeric parameter\n",
                option - 1);
#line 691
        exit(1);
      }
#line 693
      *(p->p_obj) = atoi(param_start);
#line 694
      break;
      case 2: 
#line 697
      if ((int )*param_start == 0) {
#line 698
        param_start = param;
#line 698
        if (param_start) {
#line 701
          val = 1;
        } else {
          goto arg_missing;
        }
      }
#line 702
      parsefont((struct fstate *)p->p_obj, param_start);
#line 703
      break;
      default: 
#line 706
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: set_option: internal error: p_type %d\n",
              (int )p->p_type);
#line 708
      exit(1);
      }
    }
  }
#line 712
  return (val);
}
}
#line 718 "args.c"
static void scan_profile(FILE *f ) 
{ register int i ;
  register char *p ;
  register char *this ;
  register char *next ;
  register char *temp ;
  char b0[8192] ;
  char b1[8192] ;
  char *tmp ;
  int tmp___0 ;

  {
#line 727
  next = b0;
#line 728
  this = (char *)0;
#line 729
  while (1) {
#line 731
    p = next;
#line 731
    while (1) {
#line 731
      i = _IO_getc(f);
#line 731
      if (i != -1) {
#line 731
        *p = (char )i;
#line 731
        if (! ((int )*p > 32)) {
#line 731
          break;
        }
      } else {
#line 731
        break;
      }
#line 731
      p ++;
    }
#line 733
    if ((unsigned int )p != (unsigned int )next) {
#line 735
      tmp = p;
#line 735
      p ++;
#line 735
      *tmp = (char)0;
#line 736
      if (! this) {
#line 738
        this = b0;
#line 739
        next = b1;
#line 740
        continue;
      }
#line 743
      tmp___0 = set_option(this, next, 1);
#line 743
      if (tmp___0) {
#line 745
        this = (char *)0;
#line 746
        next = b0;
#line 747
        continue;
      }
#line 750
      temp = this;
#line 751
      this = next;
#line 752
      next = temp;
    } else {
#line 754
      if (i == -1) {
#line 756
        if (this) {
#line 757
          set_option(this, (char *)0, 1);
        }
#line 758
        return;
      }
    }
  }
}
}
#line 787 "args.c"
static char prof[12]  = 
#line 787
  {      (char )'.',      (char )'i',      (char )'n',      (char )'d', 
        (char )'e',      (char )'n',      (char )'t',      (char )'.', 
        (char )'p',      (char )'r',      (char )'o',      (char )'\000'};
#line 782 "args.c"
char *set_profile(void) 
{ register FILE *f ;
  char *fname ;
  char *homedir ;
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 790
  f = fopen((char const   * __restrict  )".indent.pro", (char const   * __restrict  )"r");
#line 790
  if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 792
    tmp = strlen(".indent.pro");
#line 792
    len = tmp + 3;
#line 794
    scan_profile(f);
#line 795
    fclose(f);
#line 796
    fname = xmalloc(len);
#line 797
    *(fname + 0) = (char )'.';
#line 798
    *(fname + 1) = (char )'/';
#line 799
    bcopy(".indent.pro", fname + 2, len - 3);
#line 800
    *(fname + (len - 1)) = (char )'\000';
#line 801
    return (fname);
  }
#line 804
  homedir = getenv("HOME");
#line 805
  if (homedir) {
#line 807
    tmp___0 = strlen(homedir);
#line 807
    fname = xmalloc((unsigned int )(tmp___0 + 10) + sizeof(prof));
#line 808
    sprintf((char * __restrict  )fname, (char const   * __restrict  )"%s/%s", homedir,
            prof);
#line 810
    f = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"r");
#line 810
    if ((unsigned int )f != (unsigned int )((void *)0)) {
#line 812
      scan_profile(f);
#line 813
      fclose(f);
#line 814
      return (fname);
    }
#line 817
    free(fname);
  }
#line 820
  return ((char *)0);
}
}
#line 1 "globs.o"
#pragma merger(0,"/tmp/cil-Zg2crmCk.i","-O")
#line 68 "sys.h"
extern char *malloc() ;
#line 69
extern char *realloc() ;
#line 25 "globs.c"
char *xmalloc(unsigned int size ) 
{ register char *val ;
  char *tmp ;

  {
#line 29
  tmp = malloc(size);
#line 29
  val = tmp;
#line 30
  if (! val) {
#line 32
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: Virtual memory exhausted.\n");
#line 33
    exit(1);
  }
#line 40
  return (val);
}
}
#line 45 "globs.c"
char *xrealloc(char *ptr , unsigned int size ) 
{ register char *val ;
  char *tmp ;

  {
#line 50
  tmp = realloc(ptr, size);
#line 50
  val = tmp;
#line 51
  if (! val) {
#line 53
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: Virtual memory exhausted.\n");
#line 54
    exit(1);
  }
#line 56
  return (val);
}
}
#line 1 "backup.o"
#pragma merger(0,"/tmp/cil-eGDBsBW0.i","-O")
#line 45 "backup.h"
enum backup_mode version_control_value(void) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 333 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 112 "backup.c"
static char *simple_backup_suffix  =    (char *)"~";
#line 116 "backup.c"
enum backup_mode version_control  =    0;
#line 122 "backup.c"
static char *simple_backup_name(char *pathname ) 
{ char *backup_name ;
  int tmp ;
  int tmp___0 ;

  {
#line 128
  tmp = strlen(pathname);
#line 128
  tmp___0 = strlen(simple_backup_suffix);
#line 128
  backup_name = xmalloc((tmp + tmp___0) + 2);
#line 130
  sprintf((char * __restrict  )backup_name, (char const   * __restrict  )"%s%s", pathname,
          simple_backup_suffix);
#line 131
  return (backup_name);
}
}
#line 138 "backup.c"
static int version_number(char *base , char *direntry , int base_length ) 
{ int version ;
  char *p ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 147
  version = 0;
#line 148
  tmp___0 = strncmp(base, direntry, base_length);
#line 148
  if (! tmp___0) {
#line 148
    if (((int )*(direntry + (base_length + 2)) & -128) == 0) {
#line 148
      tmp___1 = __ctype_b_loc();
#line 148
      if ((int const   )*(*tmp___1 + (int )*(direntry + (base_length + 2))) & 2048) {
#line 151
        p = direntry + (base_length + 2);
#line 151
        while (1) {
#line 151
          if (((int )*p & -128) == 0) {
#line 151
            tmp = __ctype_b_loc();
#line 151
            if (! ((int const   )*(*tmp + (int )*p) & 2048)) {
#line 151
              break;
            }
          } else {
#line 151
            break;
          }
#line 152
          version = (version * 10 + (int )*p) - 48;
#line 151
          p ++;
        }
#line 153
        if ((int )*(p + 0) != 126) {
#line 154
          version = 0;
        } else {
#line 153
          if (*(p + 1)) {
#line 154
            version = 0;
          }
        }
      }
    }
  }
#line 157
  return (version);
}
}
#line 164 "backup.c"
static int highest_version(char *filename , char *dirname ) 
{ DIR *dirp ;
  struct dirent *dp ;
  int highest_version___0 ;
  int this_version ;
  int file_name_length ;
  int tmp ;

  {
#line 174
  dirp = opendir((char const   *)dirname);
#line 175
  if (! dirp) {
#line 176
    return (0);
  }
#line 178
  highest_version___0 = 0;
#line 179
  file_name_length = strlen(filename);
#line 181
  while (1) {
#line 181
    dp = readdir(dirp);
#line 181
    if (! ((unsigned int )dp != (unsigned int )((struct dirent *)0))) {
#line 181
      break;
    }
#line 183
    tmp = strlen(dp->d_name);
#line 183
    if (tmp <= file_name_length + 2) {
#line 184
      continue;
    }
#line 186
    this_version = version_number(filename, dp->d_name, file_name_length);
#line 187
    if (this_version > highest_version___0) {
#line 188
      highest_version___0 = this_version;
    }
  }
#line 191
  closedir(dirp);
#line 192
  return (highest_version___0);
}
}
#line 199 "backup.c"
static int max_version(char *pathname ) 
{ register char *p ;
  register char *filename ;
  int pathlen ;
  int tmp ;
  int version ;
  int dirlen ;
  register char *dirname ;

  {
#line 205
  tmp = strlen(pathname);
#line 205
  pathlen = tmp;
#line 208
  p = (pathname + pathlen) - 1;
#line 209
  while (1) {
#line 209
    if ((unsigned int )p > (unsigned int )pathname) {
#line 209
      if (! ((int )*p != 47)) {
#line 209
        break;
      }
    } else {
#line 209
      break;
    }
#line 210
    p --;
  }
#line 212
  if ((int )*p == 47) {
#line 214
    dirlen = p - pathname;
#line 217
    filename = p + 1;
#line 218
    dirname = xmalloc(dirlen + 1);
#line 219
    strncpy(dirname, pathname, dirlen);
#line 220
    *(dirname + dirlen) = (char )'\000';
#line 221
    version = highest_version(filename, dirname);
#line 222
    free(dirname);
#line 223
    return (version);
  }
#line 226
  filename = pathname;
#line 227
  version = highest_version(filename, (char *)".");
#line 228
  return (version);
}
}
#line 235 "backup.c"
static char *generate_backup_filename(enum backup_mode version_control___0 , char *pathname ) 
{ int last_numbered_version ;
  char *backup_name ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 243
  if ((int )version_control___0 == 1) {
#line 244
    return ((char *)0);
  }
#line 246
  if ((int )version_control___0 == 2) {
#line 247
    tmp = simple_backup_name(pathname);
#line 247
    return (tmp);
  }
#line 249
  last_numbered_version = max_version(pathname);
#line 250
  if ((int )version_control___0 == 3) {
#line 250
    if (last_numbered_version == 0) {
#line 252
      tmp___0 = simple_backup_name(pathname);
#line 252
      return (tmp___0);
    }
  }
#line 254
  last_numbered_version ++;
#line 255
  tmp___1 = strlen(pathname);
#line 255
  backup_name = xmalloc(tmp___1 + 16);
#line 256
  if (! backup_name) {
#line 257
    return ((char *)0);
  }
#line 259
  sprintf((char * __restrict  )backup_name, (char const   * __restrict  )"%s.~%d~",
          pathname, last_numbered_version);
#line 261
  return (backup_name);
}
}
#line 266 "backup.c"
static struct version_control_values values[7]  = {      {1, (char *)"never"}, 
        {2, (char *)"simple"}, 
        {3, (char *)"existing"}, 
        {3, (char *)"nil"}, 
        {4, (char *)"numbered"}, 
        {4, (char *)"t"}, 
        {0, (char *)0}};
#line 284 "backup.c"
enum backup_mode version_control_value(void) 
{ char *version ;
  struct version_control_values *v ;
  int tmp ;

  {
#line 290
  version = getenv("VERSION_CONTROL");
#line 291
  if ((unsigned int )version == (unsigned int )((char *)0)) {
#line 292
    return (3);
  } else {
#line 291
    if ((int )*version == 0) {
#line 292
      return (3);
    }
  }
#line 294
  v = values;
#line 295
  while (v->name) {
#line 297
    tmp = strcmp(version, v->name);
#line 297
    if (tmp == 0) {
#line 298
      return (v->value);
    }
#line 299
    v ++;
  }
#line 302
  return (0);
}
}
#line 308 "backup.c"
void initialize_backups(void) 
{ char *v ;
  char *tmp ;

  {
#line 311
  tmp = getenv("SIMPLE_BACKUP_SUFFIX");
#line 311
  v = tmp;
#line 313
  if (v) {
#line 313
    if (*v) {
#line 314
      simple_backup_suffix = v;
    }
  }
#line 318
  version_control = version_control_value();
#line 319
  if ((int )version_control == 0) {
#line 321
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent:  Strange version-control value\n");
#line 322
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent:  Using numbered-existing\n");
#line 323
    version_control = 3;
  }
#line 326
  return;
}
}
#line 350
extern int ( /* missing proto */  creat)() ;
#line 334 "backup.c"
void make_backup(struct file_buffer *file ) 
{ int fd ;
  register char *p ;
  int tmp ;
  char *backup_filename ;
  ssize_t tmp___0 ;

  {
#line 339
  tmp = strlen(file->name);
#line 339
  p = (file->name + tmp) - 1;
#line 343
  backup_filename = generate_backup_filename(version_control, file->name);
#line 344
  if (! backup_filename) {
#line 346
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"indent: Can\'t make backup filename of %s",
            file->name);
#line 347
    exit(1);
  }
#line 350
  fd = creat(backup_filename, 438);
#line 351
  if (fd < 0) {
#line 352
    sys_error(backup_filename);
  }
#line 353
  tmp___0 = write(fd, (void const   *)file->data, (unsigned int )file->size);
#line 353
  if ((unsigned long )tmp___0 != file->size) {
#line 354
    sys_error(backup_filename);
  }
#line 356
  close(fd);
#line 357
  free(backup_filename);
#line 358
  return;
}
}
