/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 86 "/usr/include/SDL/SDL_stdinc.h"
typedef uint8_t Uint8;
#line 87 "/usr/include/SDL/SDL_stdinc.h"
typedef int16_t Sint16;
#line 88 "/usr/include/SDL/SDL_stdinc.h"
typedef uint16_t Uint16;
#line 90 "/usr/include/SDL/SDL_stdinc.h"
typedef uint32_t Uint32;
#line 42 "/usr/include/SDL/SDL_audio.h"
struct SDL_AudioSpec {
   int freq ;
   Uint16 format ;
   Uint8 channels ;
   Uint8 silence ;
   Uint16 samples ;
   Uint16 padding ;
   Uint32 size ;
   void (*callback)(void *userdata , Uint8 *stream , int len ) ;
   void *userdata ;
};
#line 42 "/usr/include/SDL/SDL_audio.h"
typedef struct SDL_AudioSpec SDL_AudioSpec;
#line 32 "/usr/include/SDL/SDL_keysym.h"
enum __anonenum_SDLKey_43 {
    SDLK_UNKNOWN = 0,
    SDLK_FIRST = 0,
    SDLK_BACKSPACE = 8,
    SDLK_TAB = 9,
    SDLK_CLEAR = 12,
    SDLK_RETURN = 13,
    SDLK_PAUSE = 19,
    SDLK_ESCAPE = 27,
    SDLK_SPACE = 32,
    SDLK_EXCLAIM = 33,
    SDLK_QUOTEDBL = 34,
    SDLK_HASH = 35,
    SDLK_DOLLAR = 36,
    SDLK_AMPERSAND = 38,
    SDLK_QUOTE = 39,
    SDLK_LEFTPAREN = 40,
    SDLK_RIGHTPAREN = 41,
    SDLK_ASTERISK = 42,
    SDLK_PLUS = 43,
    SDLK_COMMA = 44,
    SDLK_MINUS = 45,
    SDLK_PERIOD = 46,
    SDLK_SLASH = 47,
    SDLK_0 = 48,
    SDLK_1 = 49,
    SDLK_2 = 50,
    SDLK_3 = 51,
    SDLK_4 = 52,
    SDLK_5 = 53,
    SDLK_6 = 54,
    SDLK_7 = 55,
    SDLK_8 = 56,
    SDLK_9 = 57,
    SDLK_COLON = 58,
    SDLK_SEMICOLON = 59,
    SDLK_LESS = 60,
    SDLK_EQUALS = 61,
    SDLK_GREATER = 62,
    SDLK_QUESTION = 63,
    SDLK_AT = 64,
    SDLK_LEFTBRACKET = 91,
    SDLK_BACKSLASH = 92,
    SDLK_RIGHTBRACKET = 93,
    SDLK_CARET = 94,
    SDLK_UNDERSCORE = 95,
    SDLK_BACKQUOTE = 96,
    SDLK_a = 97,
    SDLK_b = 98,
    SDLK_c = 99,
    SDLK_d = 100,
    SDLK_e = 101,
    SDLK_f = 102,
    SDLK_g = 103,
    SDLK_h = 104,
    SDLK_i = 105,
    SDLK_j = 106,
    SDLK_k = 107,
    SDLK_l = 108,
    SDLK_m = 109,
    SDLK_n = 110,
    SDLK_o = 111,
    SDLK_p = 112,
    SDLK_q = 113,
    SDLK_r = 114,
    SDLK_s = 115,
    SDLK_t = 116,
    SDLK_u = 117,
    SDLK_v = 118,
    SDLK_w = 119,
    SDLK_x = 120,
    SDLK_y = 121,
    SDLK_z = 122,
    SDLK_DELETE = 127,
    SDLK_WORLD_0 = 160,
    SDLK_WORLD_1 = 161,
    SDLK_WORLD_2 = 162,
    SDLK_WORLD_3 = 163,
    SDLK_WORLD_4 = 164,
    SDLK_WORLD_5 = 165,
    SDLK_WORLD_6 = 166,
    SDLK_WORLD_7 = 167,
    SDLK_WORLD_8 = 168,
    SDLK_WORLD_9 = 169,
    SDLK_WORLD_10 = 170,
    SDLK_WORLD_11 = 171,
    SDLK_WORLD_12 = 172,
    SDLK_WORLD_13 = 173,
    SDLK_WORLD_14 = 174,
    SDLK_WORLD_15 = 175,
    SDLK_WORLD_16 = 176,
    SDLK_WORLD_17 = 177,
    SDLK_WORLD_18 = 178,
    SDLK_WORLD_19 = 179,
    SDLK_WORLD_20 = 180,
    SDLK_WORLD_21 = 181,
    SDLK_WORLD_22 = 182,
    SDLK_WORLD_23 = 183,
    SDLK_WORLD_24 = 184,
    SDLK_WORLD_25 = 185,
    SDLK_WORLD_26 = 186,
    SDLK_WORLD_27 = 187,
    SDLK_WORLD_28 = 188,
    SDLK_WORLD_29 = 189,
    SDLK_WORLD_30 = 190,
    SDLK_WORLD_31 = 191,
    SDLK_WORLD_32 = 192,
    SDLK_WORLD_33 = 193,
    SDLK_WORLD_34 = 194,
    SDLK_WORLD_35 = 195,
    SDLK_WORLD_36 = 196,
    SDLK_WORLD_37 = 197,
    SDLK_WORLD_38 = 198,
    SDLK_WORLD_39 = 199,
    SDLK_WORLD_40 = 200,
    SDLK_WORLD_41 = 201,
    SDLK_WORLD_42 = 202,
    SDLK_WORLD_43 = 203,
    SDLK_WORLD_44 = 204,
    SDLK_WORLD_45 = 205,
    SDLK_WORLD_46 = 206,
    SDLK_WORLD_47 = 207,
    SDLK_WORLD_48 = 208,
    SDLK_WORLD_49 = 209,
    SDLK_WORLD_50 = 210,
    SDLK_WORLD_51 = 211,
    SDLK_WORLD_52 = 212,
    SDLK_WORLD_53 = 213,
    SDLK_WORLD_54 = 214,
    SDLK_WORLD_55 = 215,
    SDLK_WORLD_56 = 216,
    SDLK_WORLD_57 = 217,
    SDLK_WORLD_58 = 218,
    SDLK_WORLD_59 = 219,
    SDLK_WORLD_60 = 220,
    SDLK_WORLD_61 = 221,
    SDLK_WORLD_62 = 222,
    SDLK_WORLD_63 = 223,
    SDLK_WORLD_64 = 224,
    SDLK_WORLD_65 = 225,
    SDLK_WORLD_66 = 226,
    SDLK_WORLD_67 = 227,
    SDLK_WORLD_68 = 228,
    SDLK_WORLD_69 = 229,
    SDLK_WORLD_70 = 230,
    SDLK_WORLD_71 = 231,
    SDLK_WORLD_72 = 232,
    SDLK_WORLD_73 = 233,
    SDLK_WORLD_74 = 234,
    SDLK_WORLD_75 = 235,
    SDLK_WORLD_76 = 236,
    SDLK_WORLD_77 = 237,
    SDLK_WORLD_78 = 238,
    SDLK_WORLD_79 = 239,
    SDLK_WORLD_80 = 240,
    SDLK_WORLD_81 = 241,
    SDLK_WORLD_82 = 242,
    SDLK_WORLD_83 = 243,
    SDLK_WORLD_84 = 244,
    SDLK_WORLD_85 = 245,
    SDLK_WORLD_86 = 246,
    SDLK_WORLD_87 = 247,
    SDLK_WORLD_88 = 248,
    SDLK_WORLD_89 = 249,
    SDLK_WORLD_90 = 250,
    SDLK_WORLD_91 = 251,
    SDLK_WORLD_92 = 252,
    SDLK_WORLD_93 = 253,
    SDLK_WORLD_94 = 254,
    SDLK_WORLD_95 = 255,
    SDLK_KP0 = 256,
    SDLK_KP1 = 257,
    SDLK_KP2 = 258,
    SDLK_KP3 = 259,
    SDLK_KP4 = 260,
    SDLK_KP5 = 261,
    SDLK_KP6 = 262,
    SDLK_KP7 = 263,
    SDLK_KP8 = 264,
    SDLK_KP9 = 265,
    SDLK_KP_PERIOD = 266,
    SDLK_KP_DIVIDE = 267,
    SDLK_KP_MULTIPLY = 268,
    SDLK_KP_MINUS = 269,
    SDLK_KP_PLUS = 270,
    SDLK_KP_ENTER = 271,
    SDLK_KP_EQUALS = 272,
    SDLK_UP = 273,
    SDLK_DOWN = 274,
    SDLK_RIGHT = 275,
    SDLK_LEFT = 276,
    SDLK_INSERT = 277,
    SDLK_HOME = 278,
    SDLK_END = 279,
    SDLK_PAGEUP = 280,
    SDLK_PAGEDOWN = 281,
    SDLK_F1 = 282,
    SDLK_F2 = 283,
    SDLK_F3 = 284,
    SDLK_F4 = 285,
    SDLK_F5 = 286,
    SDLK_F6 = 287,
    SDLK_F7 = 288,
    SDLK_F8 = 289,
    SDLK_F9 = 290,
    SDLK_F10 = 291,
    SDLK_F11 = 292,
    SDLK_F12 = 293,
    SDLK_F13 = 294,
    SDLK_F14 = 295,
    SDLK_F15 = 296,
    SDLK_NUMLOCK = 300,
    SDLK_CAPSLOCK = 301,
    SDLK_SCROLLOCK = 302,
    SDLK_RSHIFT = 303,
    SDLK_LSHIFT = 304,
    SDLK_RCTRL = 305,
    SDLK_LCTRL = 306,
    SDLK_RALT = 307,
    SDLK_LALT = 308,
    SDLK_RMETA = 309,
    SDLK_LMETA = 310,
    SDLK_LSUPER = 311,
    SDLK_RSUPER = 312,
    SDLK_MODE = 313,
    SDLK_COMPOSE = 314,
    SDLK_HELP = 315,
    SDLK_PRINT = 316,
    SDLK_SYSREQ = 317,
    SDLK_BREAK = 318,
    SDLK_MENU = 319,
    SDLK_POWER = 320,
    SDLK_EURO = 321,
    SDLK_UNDO = 322,
    SDLK_LAST = 323
} ;
#line 32 "/usr/include/SDL/SDL_keysym.h"
typedef enum __anonenum_SDLKey_43 SDLKey;
#line 290
enum __anonenum_SDLMod_44 {
    KMOD_NONE = 0,
    KMOD_LSHIFT = 1,
    KMOD_RSHIFT = 2,
    KMOD_LCTRL = 64,
    KMOD_RCTRL = 128,
    KMOD_LALT = 256,
    KMOD_RALT = 512,
    KMOD_LMETA = 1024,
    KMOD_RMETA = 2048,
    KMOD_NUM = 4096,
    KMOD_CAPS = 8192,
    KMOD_MODE = 16384,
    KMOD_RESERVED = 32768
} ;
#line 290 "/usr/include/SDL/SDL_keysym.h"
typedef enum __anonenum_SDLMod_44 SDLMod;
#line 54 "/usr/include/SDL/SDL_keyboard.h"
struct SDL_keysym {
   Uint8 scancode ;
   SDLKey sym ;
   SDLMod mod ;
   Uint16 unicode ;
};
#line 54 "/usr/include/SDL/SDL_keyboard.h"
typedef struct SDL_keysym SDL_keysym;
#line 43 "/usr/include/SDL/SDL_video.h"
struct SDL_Rect {
   Sint16 x ;
   Sint16 y ;
   Uint16 w ;
   Uint16 h ;
};
#line 43 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Rect SDL_Rect;
#line 48 "/usr/include/SDL/SDL_video.h"
struct SDL_Color {
   Uint8 r ;
   Uint8 g ;
   Uint8 b ;
   Uint8 unused ;
};
#line 48 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Color SDL_Color;
#line 56 "/usr/include/SDL/SDL_video.h"
struct SDL_Palette {
   int ncolors ;
   SDL_Color *colors ;
};
#line 56 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Palette SDL_Palette;
#line 62 "/usr/include/SDL/SDL_video.h"
struct SDL_PixelFormat {
   SDL_Palette *palette ;
   Uint8 BitsPerPixel ;
   Uint8 BytesPerPixel ;
   Uint8 Rloss ;
   Uint8 Gloss ;
   Uint8 Bloss ;
   Uint8 Aloss ;
   Uint8 Rshift ;
   Uint8 Gshift ;
   Uint8 Bshift ;
   Uint8 Ashift ;
   Uint32 Rmask ;
   Uint32 Gmask ;
   Uint32 Bmask ;
   Uint32 Amask ;
   Uint32 colorkey ;
   Uint8 alpha ;
};
#line 62 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_PixelFormat SDL_PixelFormat;
#line 88
struct private_hwdata;
#line 88
struct SDL_BlitMap;
#line 88 "/usr/include/SDL/SDL_video.h"
struct SDL_Surface {
   Uint32 flags ;
   SDL_PixelFormat *format ;
   int w ;
   int h ;
   Uint16 pitch ;
   void *pixels ;
   int offset ;
   struct private_hwdata *hwdata ;
   SDL_Rect clip_rect ;
   Uint32 unused1 ;
   Uint32 locked ;
   struct SDL_BlitMap *map ;
   unsigned int format_version ;
   int refcount ;
};
#line 88 "/usr/include/SDL/SDL_video.h"
typedef struct SDL_Surface SDL_Surface;
#line 112 "/usr/include/SDL/SDL_events.h"
struct SDL_ActiveEvent {
   Uint8 type ;
   Uint8 gain ;
   Uint8 state ;
};
#line 112 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_ActiveEvent SDL_ActiveEvent;
#line 119 "/usr/include/SDL/SDL_events.h"
struct SDL_KeyboardEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 state ;
   SDL_keysym keysym ;
};
#line 119 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_KeyboardEvent SDL_KeyboardEvent;
#line 127 "/usr/include/SDL/SDL_events.h"
struct SDL_MouseMotionEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 state ;
   Uint16 x ;
   Uint16 y ;
   Sint16 xrel ;
   Sint16 yrel ;
};
#line 127 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_MouseMotionEvent SDL_MouseMotionEvent;
#line 137 "/usr/include/SDL/SDL_events.h"
struct SDL_MouseButtonEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 button ;
   Uint8 state ;
   Uint16 x ;
   Uint16 y ;
};
#line 137 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_MouseButtonEvent SDL_MouseButtonEvent;
#line 146 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyAxisEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 axis ;
   Sint16 value ;
};
#line 146 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyAxisEvent SDL_JoyAxisEvent;
#line 154 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyBallEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 ball ;
   Sint16 xrel ;
   Sint16 yrel ;
};
#line 154 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyBallEvent SDL_JoyBallEvent;
#line 163 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyHatEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 hat ;
   Uint8 value ;
};
#line 163 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyHatEvent SDL_JoyHatEvent;
#line 176 "/usr/include/SDL/SDL_events.h"
struct SDL_JoyButtonEvent {
   Uint8 type ;
   Uint8 which ;
   Uint8 button ;
   Uint8 state ;
};
#line 176 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_JoyButtonEvent SDL_JoyButtonEvent;
#line 187 "/usr/include/SDL/SDL_events.h"
struct SDL_ResizeEvent {
   Uint8 type ;
   int w ;
   int h ;
};
#line 187 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_ResizeEvent SDL_ResizeEvent;
#line 194 "/usr/include/SDL/SDL_events.h"
struct SDL_ExposeEvent {
   Uint8 type ;
};
#line 194 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_ExposeEvent SDL_ExposeEvent;
#line 199 "/usr/include/SDL/SDL_events.h"
struct SDL_QuitEvent {
   Uint8 type ;
};
#line 199 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_QuitEvent SDL_QuitEvent;
#line 204 "/usr/include/SDL/SDL_events.h"
struct SDL_UserEvent {
   Uint8 type ;
   int code ;
   void *data1 ;
   void *data2 ;
};
#line 204 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_UserEvent SDL_UserEvent;
#line 212
struct SDL_SysWMmsg;
#line 213 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_SysWMmsg SDL_SysWMmsg;
#line 214 "/usr/include/SDL/SDL_events.h"
struct SDL_SysWMEvent {
   Uint8 type ;
   SDL_SysWMmsg *msg ;
};
#line 214 "/usr/include/SDL/SDL_events.h"
typedef struct SDL_SysWMEvent SDL_SysWMEvent;
#line 220 "/usr/include/SDL/SDL_events.h"
union SDL_Event {
   Uint8 type ;
   SDL_ActiveEvent active ;
   SDL_KeyboardEvent key ;
   SDL_MouseMotionEvent motion ;
   SDL_MouseButtonEvent button ;
   SDL_JoyAxisEvent jaxis ;
   SDL_JoyBallEvent jball ;
   SDL_JoyHatEvent jhat ;
   SDL_JoyButtonEvent jbutton ;
   SDL_ResizeEvent resize ;
   SDL_ExposeEvent expose ;
   SDL_QuitEvent quit ;
   SDL_UserEvent user ;
   SDL_SysWMEvent syswm ;
};
#line 220 "/usr/include/SDL/SDL_events.h"
typedef union SDL_Event SDL_Event;
#line 60 "atris.h"
enum __anonenum_GT_50 {
    SINGLE = 0,
    MARATHON = 1,
    SINGLE_VS_AI = 2,
    TWO_PLAYERS = 3,
    NETWORK = 4,
    AI_VS_AI = 5,
    QUIT = 6,
    DEMO = 7
} ;
#line 60 "atris.h"
typedef enum __anonenum_GT_50 GT;
#line 80 "/usr/include/SDL/SDL_ttf.h"
struct _TTF_Font;
#line 80 "/usr/include/SDL/SDL_ttf.h"
typedef struct _TTF_Font TTF_Font;
#line 17 "piece.h"
struct piece_struct {
   int dim ;
   int num_color ;
   unsigned char *bitmap[4] ;
};
#line 17 "piece.h"
typedef struct piece_struct piece;
#line 43
enum __anonenum_special_type_51 {
    No_Special = -1,
    Special_Bomb = 0,
    Special_Repaint = 1,
    Special_Pushdown = 2,
    Special_Colorkill = 3
} ;
#line 43 "piece.h"
typedef enum __anonenum_special_type_51 special_type;
#line 53 "piece.h"
struct play_piece_struct {
   piece *base ;
   unsigned char colormap[12] ;
   special_type special ;
};
#line 53 "piece.h"
typedef struct play_piece_struct play_piece;
#line 61 "piece.h"
struct color_style_struct {
   char *name ;
   int num_color ;
   SDL_Surface **color ;
   int w ;
   int h ;
};
#line 61 "piece.h"
typedef struct color_style_struct color_style;
#line 16 "grid.h"
struct __anonstruct_Grid_52 {
   int w ;
   int h ;
   unsigned char *contents ;
   unsigned char *fall ;
   unsigned char *changed ;
   unsigned char *temp ;
   SDL_Rect board ;
};
#line 16 "grid.h"
typedef struct __anonstruct_Grid_52 Grid;
#line 31 "sound.h"
struct WAV_sample_struct {
   SDL_AudioSpec spec ;
   Uint8 *audio_buf ;
   Uint32 audio_len ;
   char *filename ;
};
#line 31 "sound.h"
typedef struct WAV_sample_struct WAV_sample;
#line 47 "sound.h"
struct sound_style_struct {
   WAV_sample WAV[7] ;
   char *name ;
};
#line 47 "sound.h"
typedef struct sound_style_struct sound_style;
#line 16 "ai.h"
enum __anonenum_Command_53 {
    MOVE_NONE = 0,
    MOVE_LEFT = 1,
    MOVE_RIGHT = 2,
    MOVE_ROTATE = 3,
    MOVE_DOWN = 4
} ;
#line 16 "ai.h"
typedef enum __anonenum_Command_53 Command;
#line 25 "ai.h"
struct AI_Player_struct {
   char *name ;
   char *msg ;
   Command (*move)(void *state , Grid * , play_piece * , play_piece * , int  , int  ,
                   int  ) ;
   void (*think)(void *state , Grid * , play_piece * , play_piece * , int  , int  ,
                 int  ) ;
   void *(*reset)(void *state , Grid * ) ;
   int delay_factor ;
};
#line 25 "ai.h"
typedef struct AI_Player_struct AI_Player;
#line 36 "ai.h"
struct AI_Players_struct {
   int n ;
   AI_Player *player ;
};
#line 36 "ai.h"
typedef struct AI_Players_struct AI_Players;
#line 24 "menu.h"
struct _WalkRadio {
   int n ;
   char **label ;
   int x ;
   int y ;
   int defaultchoice ;
   int (*action)(struct _WalkRadio * ) ;
   int *var_to_set ;
   void *data ;
   int inactive ;
   Uint32 face_color[2] ;
   Uint32 text_color[2] ;
   Uint32 border_color[2] ;
   int w ;
   int h ;
   SDL_Rect area ;
   SDL_Surface **bitmap0 ;
   SDL_Surface **bitmap1 ;
};
#line 24 "menu.h"
typedef struct _WalkRadio WalkRadio;
#line 48 "menu.h"
struct _WalkRadioGroup {
   WalkRadio *wr ;
   int n ;
   int cur ;
};
#line 48 "menu.h"
typedef struct _WalkRadioGroup WalkRadioGroup;
#line 26 "ai.c"
struct wessy_struct {
   int know_what_to_do ;
   int desired_column ;
   int desired_rot ;
   int cc ;
   int current_rot ;
   int best_weight ;
   Grid tg ;
};
#line 26 "ai.c"
typedef struct wessy_struct Wessy_State;
#line 36 "ai.c"
struct double_struct {
   int know_what_to_do ;
   int desired_col ;
   int desired_rot ;
   int best_weight ;
   int stage_alpha ;
   int cur_alpha_col ;
   int cur_alpha_rot ;
   Grid ag ;
   int cur_beta_col ;
   int cur_beta_rot ;
   Grid tg ;
};
#line 36 "ai.c"
typedef struct double_struct Double_State;
#line 480 "ai.c"
struct Aliz_State_struct {
   double bestEval ;
   int foundBest ;
   int goalColumn ;
   int goalRotation ;
   int checkColumn ;
   int checkRotation ;
   int goalSides ;
   int checkSides ;
   Grid kg ;
};
#line 480 "ai.c"
typedef struct Aliz_State_struct Aliz_State;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 191 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 26 "piece.h"
struct piece_style_struct {
   char *name ;
   int num_piece ;
   piece *shape ;
};
#line 26 "piece.h"
typedef struct piece_style_struct piece_style;
#line 35 "piece.h"
struct piece_styles_struct {
   int num_style ;
   int choice ;
   piece_style **style ;
};
#line 35 "piece.h"
typedef struct piece_styles_struct piece_styles;
#line 80 "piece.h"
struct color_styles_struct {
   int num_style ;
   int choice ;
   color_style **style ;
};
#line 80 "piece.h"
typedef struct color_styles_struct color_styles;
#line 52 "sound.h"
struct sound_styles_struct {
   int num_style ;
   int choice ;
   sound_style **style ;
};
#line 52 "sound.h"
typedef struct sound_styles_struct sound_styles;
#line 10 "identity.h"
struct person_struct {
   char *name ;
   int level ;
};
#line 10 "identity.h"
typedef struct person_struct person;
#line 15 "identity.h"
struct identity_struct {
   int n ;
   person *p ;
};
#line 15 "identity.h"
typedef struct identity_struct identity;
#line 10 "options.h"
struct option_struct {
   int bpp_wanted ;
   int sound_wanted ;
   int full_screen ;
   int flame_wanted ;
   int special_wanted ;
   int faster_levels ;
   int long_settle_delay ;
   int upward_rotation ;
   int key_repeat_delay ;
   int named_color ;
   int named_sound ;
   int named_piece ;
   int named_game ;
};
#line 10 "button.h"
struct _ATButton {
   SDL_Surface *bitmap[2] ;
   SDL_Rect area ;
   Uint32 face_color[2] ;
   Uint32 text_color[2] ;
};
#line 10 "button.h"
typedef struct _ATButton ATButton;
#line 41 "/usr/include/SDL/SDL_rwops.h"
struct __anonstruct_stdio_41 {
   int autoclose ;
   FILE *fp ;
};
#line 41 "/usr/include/SDL/SDL_rwops.h"
struct __anonstruct_mem_42 {
   Uint8 *base ;
   Uint8 *here ;
   Uint8 *stop ;
};
#line 41 "/usr/include/SDL/SDL_rwops.h"
struct __anonstruct_unknown_43 {
   void *data1 ;
};
#line 41 "/usr/include/SDL/SDL_rwops.h"
union __anonunion_hidden_40 {
   struct __anonstruct_stdio_41 stdio ;
   struct __anonstruct_mem_42 mem ;
   struct __anonstruct_unknown_43 unknown ;
};
#line 41 "/usr/include/SDL/SDL_rwops.h"
struct SDL_RWops {
   int (*seek)(struct SDL_RWops *context , int offset , int whence ) ;
   int (*read)(struct SDL_RWops *context , void *ptr , int size , int maxnum ) ;
   int (*write)(struct SDL_RWops *context , void const   *ptr , int size , int num ) ;
   int (*close)(struct SDL_RWops *context ) ;
   Uint32 type ;
   union __anonunion_hidden_40 hidden ;
};
#line 41 "/usr/include/SDL/SDL_rwops.h"
typedef struct SDL_RWops SDL_RWops;
#line 17 "display.c"
struct adjust_struct {
   SDL_Rect symbol[3] ;
};
#line 17 "display.c"
struct layout_struct {
   SDL_Rect grid_border[2] ;
   SDL_Rect grid[2] ;
   SDL_Rect score[2] ;
   SDL_Rect name[2] ;
   struct adjust_struct adjust[2] ;
   SDL_Rect time ;
   SDL_Rect time_border ;
   SDL_Rect next_piece_border[2] ;
   SDL_Rect next_piece[2] ;
   SDL_Rect pause ;
};
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_6 {
   __fd_mask fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_6 fd_set;
#line 35 "event.c"
struct state_struct {
   int ai ;
   int falling ;
   int fall_speed ;
   int accept_input ;
   int tetris_handling ;
   int limbo ;
   int other_in_limbo ;
   int limbo_sent ;
   int draw ;
   Uint32 collide_time ;
   Uint32 next_draw ;
   Uint32 draw_timeout ;
   Uint32 tv_next_fall ;
   int fall_event_interval ;
   Uint32 tv_next_tetris ;
   int tetris_event_interval ;
   Uint32 tv_next_ai_think ;
   Uint32 tv_next_ai_move ;
   int ai_interval ;
   int ready_for_fast ;
   int ready_for_rotate ;
   int seed ;
   play_piece cp ;
   play_piece np ;
   void *ai_state ;
   int check_result ;
   int num_lines_cleared ;
};
#line 66 "event.c"
struct pos_struct {
   int x ;
   int y ;
   int rot ;
   int old_x ;
   int old_y ;
   int old_rot ;
   Command move ;
};
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 14 "menu.h"
struct _ATMenu {
   int nButtons ;
   ATButton **buttons ;
   char *clicked ;
   int x ;
   int y ;
   int w ;
   int h ;
   int defaultchoice ;
};
#line 14 "menu.h"
typedef struct _ATMenu ATMenu;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 245 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 146 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 315 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 87 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 17 "sound.h"
struct playing_sample_struct {
   int in_use ;
   int delay ;
   Uint32 len ;
   Uint32 pos ;
   Uint8 *audio_data ;
   char *filename ;
};
#line 17 "sound.h"
typedef struct playing_sample_struct playing_sample;
#line 27 "sound.h"
struct samples_to_be_played_struct {
   playing_sample sample[32] ;
};
#line 27 "sound.h"
typedef struct samples_to_be_played_struct samples_to_be_played;
#line 58 "xflame.c"
struct globaldata {
   Uint32 flags ;
   SDL_Surface *screen ;
   int nrects ;
   SDL_Rect *rects ;
};
#line 1 "ai.o"
#pragma merger(0,"/tmp/cil-3jaQLdD4.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 221
extern int fflush(FILE *__stream ) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 413
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 591 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 1304 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/SDL/SDL_timer.h"
extern Uint32 __attribute__((__visibility__("default")))  SDL_GetTicks(void) ;
#line 70 "atris.h"
GT gametype  ;
#line 83
 __attribute__((__noreturn__)) void Panic(char const   *func , char const   *file ,
                                          char *fmt  , ...) ;
#line 12 "display.h"
SDL_Color color_white  ;
#line 13 "display.h"
SDL_Color color_black  ;
#line 14 "display.h"
SDL_Color color_red  ;
#line 15 "display.h"
SDL_Color color_blue  ;
#line 16 "display.h"
SDL_Color color_purple  ;
#line 18 "display.h"
Uint32 int_black  ;
#line 19 "display.h"
Uint32 int_white  ;
#line 20 "display.h"
Uint32 int_grey  ;
#line 21 "display.h"
Uint32 int_blue  ;
#line 22 "display.h"
Uint32 int_med_blue  ;
#line 23 "display.h"
Uint32 int_dark_blue  ;
#line 24 "display.h"
Uint32 int_purple  ;
#line 25 "display.h"
Uint32 int_dark_purple  ;
#line 26 "display.h"
Uint32 int_solid_black  ;
#line 28 "display.h"
SDL_Surface *screen  ;
#line 28 "display.h"
SDL_Surface *widget_layer  ;
#line 28 "display.h"
SDL_Surface *flame_layer  ;
#line 29 "display.h"
TTF_Font *font  ;
#line 29 "display.h"
TTF_Font *sfont  ;
#line 29 "display.h"
TTF_Font *lfont  ;
#line 29 "display.h"
TTF_Font *hfont  ;
#line 70 "piece.h"
color_style special_style  ;
#line 76 "piece.h"
SDL_Surface *edge[4]  ;
#line 2 ".protos/grid.pro"
void cleanup_grid(Grid *g___0 ) ;
#line 4
Grid generate_board(int w___1 , int h___1 , int level ) ;
#line 12
void fall_down(Grid *g___0 ) ;
#line 14
int determine_falling(Grid *g___0 ) ;
#line 16
int run_gravity(Grid *g___0 ) ;
#line 18
int check_tetris(Grid *g___0 ) ;
#line 8 ".protos/menu.pro"
void setup_radio(WalkRadio *wr ) ;
#line 14
void draw_radio(WalkRadio *wr , int state ) ;
#line 16
WalkRadioGroup *create_single_wrg(int n ) ;
#line 18
int handle_radio_event(WalkRadioGroup *wrg___1 , SDL_Event const   *ev ) ;
#line 2 ".protos/event.pro"
void paste_on_board(play_piece *pp , int col , int row , int rot , Grid *g___0 ) ;
#line 4
int valid_position(play_piece *pp , int col , int row , int rot , Grid *g___0 ) ;
#line 9
void handle_special(play_piece *pp , int row , int col , int rot , Grid *g___0 , sound_style *ss ) ;
#line 2 ".protos/identity.pro"
char *input_string(SDL_Surface *screen___0 , int x , int y , int opaque ) ;
#line 2 ".protos/display.pro"
void poll_and_flame(SDL_Event *ev ) ;
#line 4
void clear_screen_to_flame(void) ;
#line 16
int draw_string(char *text , SDL_Color sc , int x , int y , int flags___0 ) ;
#line 53 "ai.c"
static int weight_board(Grid *g___0 ) ;
#line 63 "ai.c"
int drop_piece_on_grid(Grid *g___0 , play_piece *pp , int col , int row , int rot ) 
{ int should_we_loop ;
  int lines_cleared ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int x ;
  int y ;
  int l ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 66
  should_we_loop = 0;
#line 67
  lines_cleared = 0;
#line 69
  tmp = valid_position(pp, col, row, rot, g___0);
#line 69
  if (! tmp) {
#line 70
    return (-1);
  }
#line 72
  while (1) {
#line 72
    tmp___0 = valid_position(pp, col, row, rot, g___0);
#line 72
    if (! tmp___0) {
#line 72
      break;
    }
#line 73
    row ++;
  }
#line 74
  row --;
#line 78
  tmp___1 = valid_position(pp, col, row, rot, g___0);
#line 78
  if (! tmp___1) {
#line 79
    return (-1);
  }
#line 81
  if ((int )pp->special != -1) {
#line 82
    handle_special(pp, row, col, rot, g___0, (sound_style *)((void *)0));
#line 83
    cleanup_grid(g___0);
  } else {
#line 85
    paste_on_board(pp, col, row, rot, g___0);
  }
#line 86
  while (1) {
#line 88
    should_we_loop = 0;
#line 89
    l = check_tetris(g___0);
#line 89
    if (l) {
#line 90
      cleanup_grid(g___0);
    }
#line 92
    lines_cleared += l;
#line 93
    y = g___0->h - 1;
#line 93
    while (y >= 0) {
#line 94
      x = g___0->w - 1;
#line 94
      while (x >= 0) {
#line 95
        *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->fall + (x + y * g___0->w)) != 254));
#line 95
        *(g___0->fall + (x + y * g___0->w)) = (unsigned char)254;
#line 94
        x --;
      }
#line 93
      y --;
    }
#line 96
    run_gravity(g___0);
#line 98
    tmp___3 = determine_falling(g___0);
#line 98
    if (tmp___3) {
#line 99
      while (1) {
#line 100
        fall_down(g___0);
#line 101
        cleanup_grid(g___0);
#line 102
        run_gravity(g___0);
#line 99
        tmp___2 = determine_falling(g___0);
#line 99
        if (! tmp___2) {
#line 99
          break;
        }
      }
#line 104
      should_we_loop = 1;
    }
#line 86
    if (! should_we_loop) {
#line 86
      break;
    }
  }
#line 111
  return (lines_cleared);
}
}
#line 117 "ai.c"
static void *double_ai_reset(void *state , Grid *g___0 ) 
{ Double_State *retval ;
  void *tmp ;

  {
#line 123
  if ((unsigned int )state == (unsigned int )((void *)0)) {
#line 125
    tmp = calloc(sizeof(Double_State ), 1U);
#line 125
    retval = (Double_State *)tmp;
#line 125
    if (! retval) {
#line 125
      Panic("double_ai_reset", "ai.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
            sizeof(Double_State ));
    }
  } else {
#line 127
    retval = (Double_State *)state;
  }
#line 128
  if (! retval) {
#line 128
    Panic("double_ai_reset", "ai.c", (char *)"Failed assertion \"%s\" on line %d",
          "retval", 128);
  }
#line 129
  retval->know_what_to_do = 0;
#line 130
  retval->desired_col = g___0->w / 2;
#line 131
  retval->desired_rot = 0;
#line 132
  retval->best_weight = 1 << 30;
#line 133
  retval->stage_alpha = 1;
#line 134
  retval->cur_alpha_col = -4;
#line 135
  retval->cur_alpha_rot = 0;
#line 136
  retval->cur_beta_col = -4;
#line 137
  retval->cur_beta_rot = 0;
#line 139
  if ((unsigned int )retval->tg.contents == (unsigned int )((void *)0)) {
#line 140
    retval->tg = generate_board(g___0->w, g___0->h, 0);
  }
#line 141
  if ((unsigned int )retval->ag.contents == (unsigned int )((void *)0)) {
#line 142
    retval->ag = generate_board(g___0->w, g___0->h, 0);
  }
#line 144
  return ((void *)retval);
}
}
#line 150 "ai.c"
static void double_ai_think(void *data , Grid *g___0 , play_piece *pp , play_piece *np ,
                            int col , int row , int rot ) 
{ Double_State *ds ;
  Uint32 incoming_time ;
  Uint32 __attribute__((__visibility__("default")))  tmp ;
  int weight ;
  int tmp___0 ;
  int weight___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___3 ;

  {
#line 154
  ds = (Double_State *)data;
#line 155
  tmp = SDL_GetTicks();
#line 155
  incoming_time = (Uint32 )tmp;
#line 157
  if (! ds) {
#line 157
    Panic("double_ai_think", "ai.c", (char *)"Failed assertion \"%s\" on line %d",
          "ds", 157);
  }
#line 159
  while (1) {
#line 159
    tmp___3 = SDL_GetTicks();
#line 159
    if (! (tmp___3 == (Uint32 __attribute__((__visibility__("default")))  )incoming_time)) {
#line 159
      break;
    }
#line 160
    if (ds->know_what_to_do) {
#line 161
      return;
    }
#line 163
    if (ds->stage_alpha) {
#line 164
      memcpy((void * __restrict  )ds->ag.contents, (void const   * __restrict  )g___0->contents,
             (unsigned int )(g___0->w * g___0->h) * sizeof(*(ds->ag.contents + 0)));
#line 165
      memcpy((void * __restrict  )ds->ag.fall, (void const   * __restrict  )g___0->fall,
             (unsigned int )(g___0->w * g___0->h) * sizeof(*(ds->ag.fall + 0)));
#line 167
      tmp___0 = drop_piece_on_grid(& ds->ag, pp, ds->cur_alpha_col, row, ds->cur_alpha_rot);
#line 167
      if (tmp___0 != -1) {
#line 171
        ds->cur_beta_col = -4;
#line 172
        ds->cur_beta_rot = 0;
#line 174
        ds->stage_alpha = 0;
#line 176
        weight = weight_board(& ds->ag);
#line 177
        if (weight <= 0) {
#line 178
          ds->best_weight = weight;
#line 179
          ds->desired_col = ds->cur_alpha_col;
#line 180
          ds->desired_rot = ds->cur_alpha_rot;
#line 181
          ds->know_what_to_do = 1;
        }
      } else {
#line 185
        (ds->cur_alpha_col) ++;
#line 185
        if (ds->cur_alpha_col == g___0->w) {
#line 186
          ds->cur_alpha_col = -4;
#line 187
          (ds->cur_alpha_rot) ++;
#line 187
          if (ds->cur_alpha_rot == 4) {
#line 188
            ds->cur_alpha_rot = 0;
#line 189
            ds->know_what_to_do = 1;
          }
        }
      }
    } else {
#line 197
      memcpy((void * __restrict  )ds->tg.contents, (void const   * __restrict  )ds->ag.contents,
             (unsigned int )(ds->ag.w * ds->ag.h) * sizeof(*(ds->ag.contents + 0)));
#line 198
      memcpy((void * __restrict  )ds->tg.fall, (void const   * __restrict  )ds->ag.fall,
             (unsigned int )(ds->ag.w * ds->ag.h) * sizeof(*(ds->ag.fall + 0)));
#line 200
      tmp___2 = drop_piece_on_grid(& ds->tg, np, ds->cur_beta_col, row, ds->cur_beta_rot);
#line 200
      if (tmp___2 != -1) {
#line 203
        tmp___1 = weight_board(& ds->tg);
#line 203
        weight___0 = 1 + tmp___1;
#line 204
        if (weight___0 < ds->best_weight) {
#line 205
          ds->best_weight = weight___0;
#line 206
          ds->desired_col = ds->cur_alpha_col;
#line 207
          ds->desired_rot = ds->cur_alpha_rot;
        }
      }
#line 211
      (ds->cur_beta_col) ++;
#line 211
      if (ds->cur_beta_col == g___0->w) {
#line 212
        ds->cur_beta_col = -4;
#line 213
        (ds->cur_beta_rot) ++;
#line 213
        if (ds->cur_beta_rot == 2) {
#line 214
          ds->cur_beta_rot = 0;
#line 216
          ds->stage_alpha = 1;
#line 217
          (ds->cur_alpha_col) ++;
#line 217
          if (ds->cur_alpha_col == g___0->w) {
#line 218
            ds->cur_alpha_col = -4;
#line 219
            (ds->cur_alpha_rot) ++;
#line 219
            if (ds->cur_alpha_rot == 4) {
#line 220
              ds->cur_alpha_rot = 0;
#line 221
              ds->know_what_to_do = 1;
            }
          }
        }
      }
    }
  }
#line 228
  return;
}
}
#line 233 "ai.c"
static Command double_ai_move(void *state , Grid *g___0 , play_piece *pp , play_piece *np ,
                              int col , int row , int rot ) 
{ Double_State *ws___0 ;

  {
#line 239
  ws___0 = (Double_State *)state;
#line 241
  if (rot != ws___0->desired_rot) {
#line 242
    return (3);
  } else {
#line 243
    if (col > ws___0->desired_col) {
#line 244
      return (1);
    } else {
#line 245
      if (col < ws___0->desired_col) {
#line 246
        return (2);
      } else {
#line 247
        if (ws___0->know_what_to_do) {
#line 248
          return (4);
        } else {
#line 250
          return (0);
        }
      }
    }
  }
}
}
#line 260 "ai.c"
static int weight_board(Grid *g___0 ) 
{ int x ;
  int y ;
  int w___1 ;
  int holes ;
  int same_color ;
  int garbage ;
  int badness[10] ;
  int possible_holes ;
  int what ;

  {
#line 264
  w___1 = 0;
#line 265
  holes = 0;
#line 266
  same_color = 0;
#line 267
  garbage = 0;
#line 270
  badness[0] = 7;
#line 270
  badness[1] = 9;
#line 270
  badness[2] = 9;
#line 270
  badness[3] = 9;
#line 270
  badness[4] = 9;
#line 270
  badness[5] = 9;
#line 270
  badness[6] = 9;
#line 270
  badness[7] = 9;
#line 270
  badness[8] = 9;
#line 270
  badness[9] = 7;
#line 276
  x = 0;
#line 276
  while (x < g___0->w) {
#line 277
    possible_holes = 0;
#line 278
    y = g___0->h - 1;
#line 278
    while (y >= 0) {
#line 280
      what = (int )*(g___0->contents + (x + y * g___0->w));
#line 280
      if (what) {
#line 281
        w___1 += ((2 * (g___0->h - y)) * badness[x]) / 3;
#line 282
        if (possible_holes) {
#line 283
          if (what != 1) {
#line 284
            holes += ((3 * (g___0->h - y)) * g___0->w) * possible_holes;
          }
#line 285
          possible_holes = 0;
        }
#line 288
        if (x > 1) {
#line 288
          if (what) {
#line 289
            if ((int )*(g___0->contents + ((x - 1) + y * g___0->w)) == what) {
#line 290
              same_color ++;
            }
          }
        }
#line 291
        if (what == 1) {
#line 292
          garbage ++;
        }
      } else {
#line 294
        possible_holes ++;
      }
#line 278
      y --;
    }
#line 276
    x ++;
  }
#line 298
  w___1 += holes * 2;
#line 299
  w___1 += same_color * 4;
#line 300
  if (garbage == 0) {
#line 300
    w___1 = 0;
  }
#line 302
  return (w___1);
}
}
#line 331 "ai.c"
static void wes_ai_think(void *data , Grid *g___0 , play_piece *pp , play_piece *np ,
                         int col , int row , int rot ) 
{ int weight ;
  Wessy_State *ws___0 ;
  Uint32 incoming_time ;
  Uint32 __attribute__((__visibility__("default")))  tmp ;
  int tmp___0 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___1 ;

  {
#line 336
  ws___0 = (Wessy_State *)data;
#line 337
  tmp = SDL_GetTicks();
#line 337
  incoming_time = (Uint32 )tmp;
#line 339
  if (! ws___0) {
#line 339
    Panic("wes_ai_think", "ai.c", (char *)"Failed assertion \"%s\" on line %d", "ws",
          339);
  }
#line 341
  while (1) {
#line 341
    tmp___1 = SDL_GetTicks();
#line 341
    if (! (tmp___1 == (Uint32 __attribute__((__visibility__("default")))  )incoming_time)) {
#line 341
      break;
    }
#line 343
    if (ws___0->know_what_to_do) {
#line 344
      return;
    }
#line 346
    memcpy((void * __restrict  )ws___0->tg.contents, (void const   * __restrict  )g___0->contents,
           (unsigned int )(g___0->w * g___0->h) * sizeof(*(ws___0->tg.contents + 0)));
#line 347
    memcpy((void * __restrict  )ws___0->tg.fall, (void const   * __restrict  )g___0->fall,
           (unsigned int )(g___0->w * g___0->h) * sizeof(*(ws___0->tg.fall + 0)));
#line 349
    tmp___0 = drop_piece_on_grid(& ws___0->tg, pp, ws___0->cc, row, ws___0->current_rot);
#line 349
    if (tmp___0 != -1) {
#line 350
      weight = weight_board(& ws___0->tg);
#line 352
      if (weight < ws___0->best_weight) {
#line 353
        ws___0->best_weight = weight;
#line 354
        ws___0->desired_column = ws___0->cc;
#line 355
        ws___0->desired_rot = ws___0->current_rot;
#line 356
        if (weight == 0) {
#line 357
          ws___0->know_what_to_do = 1;
        }
      }
    }
#line 360
    (ws___0->cc) ++;
#line 360
    if (ws___0->cc == g___0->w) {
#line 361
      ws___0->cc = 0;
#line 362
      (ws___0->current_rot) ++;
#line 362
      if (ws___0->current_rot == 4) {
#line 363
        ws___0->know_what_to_do = 1;
      }
    }
  }
#line 366
  return;
}
}
#line 370 "ai.c"
static void beginner_ai_think(void *data , Grid *g___0 , play_piece *pp , play_piece *np ,
                              int col , int row , int rot ) 
{ int weight ;
  Wessy_State *ws___0 ;
  Uint32 __attribute__((__visibility__("default")))  tmp ;
  int tmp___0 ;

  {
#line 375
  ws___0 = (Wessy_State *)data;
#line 377
  if (! ws___0) {
#line 377
    Panic("beginner_ai_think", "ai.c", (char *)"Failed assertion \"%s\" on line %d",
          "ws", 377);
  }
#line 379
  if (ws___0->know_what_to_do) {
#line 380
    return;
  } else {
#line 379
    tmp = SDL_GetTicks();
#line 379
    if (tmp & (unsigned int __attribute__((__visibility__("default")))  )3) {
#line 380
      return;
    }
  }
#line 382
  memcpy((void * __restrict  )ws___0->tg.contents, (void const   * __restrict  )g___0->contents,
         (unsigned int )(g___0->w * g___0->h) * sizeof(*(ws___0->tg.contents + 0)));
#line 383
  memcpy((void * __restrict  )ws___0->tg.fall, (void const   * __restrict  )g___0->fall,
         (unsigned int )(g___0->w * g___0->h) * sizeof(*(ws___0->tg.fall + 0)));
#line 386
  tmp___0 = drop_piece_on_grid(& ws___0->tg, pp, ws___0->cc, row, ws___0->current_rot);
#line 386
  if (tmp___0 != -1) {
#line 388
    weight = weight_board(& ws___0->tg);
#line 390
    if (weight < ws___0->best_weight) {
#line 391
      ws___0->best_weight = weight;
#line 392
      ws___0->desired_column = ws___0->cc;
#line 393
      ws___0->desired_rot = ws___0->current_rot;
#line 394
      if (weight == 0) {
#line 395
        ws___0->know_what_to_do = 1;
      }
    }
  }
#line 398
  (ws___0->cc) ++;
#line 398
  if (ws___0->cc == g___0->w) {
#line 399
    ws___0->cc = 0;
#line 400
    (ws___0->current_rot) ++;
#line 400
    if (ws___0->current_rot == 4) {
#line 401
      ws___0->know_what_to_do = 1;
    }
  }
#line 403
  return;
}
}
#line 412 "ai.c"
static void *wes_ai_reset(void *state , Grid *g___0 ) 
{ Wessy_State *retval ;
  void *tmp ;

  {
#line 418
  if ((unsigned int )state == (unsigned int )((void *)0)) {
#line 420
    tmp = calloc(sizeof(Wessy_State ), 1U);
#line 420
    retval = (Wessy_State *)tmp;
#line 420
    if (! retval) {
#line 420
      Panic("wes_ai_reset", "ai.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
            sizeof(Wessy_State ));
    }
  } else {
#line 422
    retval = (Wessy_State *)state;
  }
#line 423
  if (! retval) {
#line 423
    Panic("wes_ai_reset", "ai.c", (char *)"Failed assertion \"%s\" on line %d", "retval",
          423);
  }
#line 425
  retval->know_what_to_do = 0;
#line 426
  retval->cc = -4;
#line 427
  retval->current_rot = 0;
#line 428
  retval->best_weight = 1 << 30;
#line 429
  retval->desired_column = g___0->w / 2;
#line 430
  retval->desired_rot = 0;
#line 432
  if ((unsigned int )retval->tg.contents == (unsigned int )((void *)0)) {
#line 433
    retval->tg = generate_board(g___0->w, g___0->h, 0);
  }
#line 435
  return ((void *)retval);
}
}
#line 453 "ai.c"
static Command wes_ai_move(void *state , Grid *g___0 , play_piece *pp , play_piece *np ,
                           int col , int row , int rot ) 
{ Wessy_State *ws___0 ;

  {
#line 459
  ws___0 = (Wessy_State *)state;
#line 461
  if (rot != ws___0->desired_rot) {
#line 462
    return (3);
  } else {
#line 463
    if (col > ws___0->desired_column) {
#line 464
      return (1);
    } else {
#line 465
      if (col < ws___0->desired_column) {
#line 466
        return (2);
      } else {
#line 467
        if (ws___0->know_what_to_do) {
#line 468
          return (4);
        } else {
#line 470
          return (0);
        }
      }
    }
  }
}
}
#line 498 "ai.c"
static double evalBoard(Grid *g___0 , int nLines , int row ) 
{ int x ;
  int y ;
  int z ;
  int maxHeight ;
  int minHeight ;
  int nHoles ;
  int nGarbage ;
  int nCanyons ;
  double avgHeight ;
  int nColumns ;
  int height ;
  char gc ;
  char gc2 ;

  {
#line 503
  maxHeight = 0;
#line 503
  minHeight = g___0->h;
#line 504
  nHoles = 0;
#line 504
  nGarbage = 0;
#line 504
  nCanyons = 0;
#line 505
  avgHeight = (double )0;
#line 506
  nColumns = g___0->w;
#line 509
  x = 0;
#line 509
  while (x < g___0->w) {
#line 510
    height = g___0->h;
#line 512
    y = 0;
#line 512
    while (y < g___0->h) {
#line 513
      gc = (char )*(g___0->contents + (x + y * g___0->w));
#line 514
      if ((int )gc == 0) {
#line 514
        height --;
      } else {
#line 517
        if ((int )gc == 1) {
#line 517
          nGarbage ++;
        }
#line 519
        z = y + 1;
#line 519
        while (z < g___0->h) {
#line 520
          gc2 = (char )*(g___0->contents + (x + z * g___0->w));
#line 522
          if ((int )gc2 == 0) {
#line 523
            nHoles += 2;
          } else {
#line 525
            if ((int )gc2 == 1) {
#line 525
              nGarbage ++;
            }
          }
#line 519
          z ++;
        }
#line 527
        break;
      }
#line 512
      y ++;
    }
#line 530
    avgHeight += (double )height;
#line 531
    if (height > maxHeight) {
#line 531
      maxHeight = height;
    }
#line 532
    if (height < minHeight) {
#line 532
      minHeight = height;
    }
#line 509
    x ++;
  }
#line 534
  avgHeight /= (double )nColumns;
#line 536
  nHoles *= g___0->h;
#line 539
  x = 0;
#line 539
  while (x < g___0->w) {
#line 540
    y = g___0->h - maxHeight;
#line 540
    while (y < g___0->h) {
#line 542
      if ((int )*(g___0->contents + (x + y * g___0->w)) == 0) {
#line 542
        if (x == 0) {
          goto _L;
        } else {
#line 542
          if (*(g___0->contents + ((x - 1) + y * g___0->w))) {
            _L: /* CIL Label */ 
#line 542
            if (x == g___0->w - 1) {
#line 545
              nCanyons += y;
            } else {
#line 542
              if (*(g___0->contents + ((x + 1) + y * g___0->w))) {
#line 545
                nCanyons += y;
              }
            }
          }
        }
      }
#line 540
      y ++;
    }
#line 539
    x ++;
  }
#line 553
  return ((((((((double )(maxHeight * g___0->h) + avgHeight) + (double )(maxHeight - minHeight)) + (double )nHoles) + (double )nCanyons) + (double )nGarbage) + (double )(g___0->h - row)) - (double )(nLines * nLines));
}
}
#line 563 "ai.c"
static void alizCogitate(void *state , Grid *g___0 , play_piece *pp , play_piece *np ,
                         int col , int row , int rot ) 
{ Aliz_State *as ;
  double eval ;
  double evalLeft ;
  double evalRight ;
  int nLines ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int y ;
  int tmp___3 ;
  int y___0 ;
  int tmp___4 ;

  {
#line 567
  as = (Aliz_State *)state;
#line 568
  evalLeft = (double )-1;
#line 568
  evalRight = (double )-1;
#line 571
  if (! as) {
#line 571
    Panic("alizCogitate", "ai.c", (char *)"Failed assertion \"%s\" on line %d", "as",
          571);
  }
#line 573
  if (as->foundBest) {
#line 573
    return;
  }
#line 575
  memcpy((void * __restrict  )as->kg.contents, (void const   * __restrict  )g___0->contents,
         (unsigned int )(g___0->w * g___0->h) * sizeof(*(as->kg.contents + 0)));
#line 576
  memcpy((void * __restrict  )as->kg.fall, (void const   * __restrict  )g___0->fall,
         (unsigned int )(g___0->w * g___0->h) * sizeof(*(as->kg.fall)));
#line 578
  if (as->bestEval == (double )-1) {
#line 580
    as->checkColumn = col;
#line 581
    as->checkRotation = 0;
#line 582
    as->checkSides = 0;
  } else {
#line 586
    as->checkRotation = (as->checkRotation + 1) % 4;
#line 587
    if (as->checkRotation == 0) {
#line 590
      if (as->checkColumn == col) {
        goto _L;
      } else {
#line 590
        if (as->checkColumn < col) {
          _L: /* CIL Label */ 
#line 591
          (as->checkColumn) --;
#line 592
          tmp___0 = valid_position(pp, as->checkColumn, row, as->checkRotation, & as->kg);
#line 592
          if (! tmp___0) {
#line 594
            as->checkColumn = col + 1;
#line 595
            tmp = valid_position(pp, as->checkColumn, row, as->checkRotation, & as->kg);
#line 595
            if (! tmp) {
#line 598
              return;
            }
          }
        } else {
#line 604
          (as->checkColumn) ++;
#line 605
          tmp___1 = valid_position(pp, as->checkColumn, row, as->checkRotation, & as->kg);
#line 605
          if (! tmp___1) {
#line 608
            return;
          }
        }
      }
    } else {
#line 611
      tmp___2 = valid_position(pp, as->checkColumn, row, as->checkRotation, & as->kg);
#line 611
      if (! tmp___2) {
#line 614
        if (as->checkColumn >= g___0->w) {
#line 614
          if (as->checkRotation == 3) {
#line 616
            as->foundBest = 1;
#line 621
            return;
          } else {
#line 624
            return;
          }
        } else {
#line 624
          return;
        }
      }
    }
  }
#line 632
  if (*(g___0->contents + (col + (row + 1) * g___0->w))) {
#line 638
    if (col > g___0->w - col) {
#line 640
      as->goalColumn = col / 2;
#line 645
      as->goalRotation = as->checkRotation;
    } else {
#line 652
      as->goalColumn = col + (g___0->w - col) / 2;
#line 653
      as->goalRotation = as->checkRotation;
    }
#line 661
    return;
  }
#line 665
  nLines = drop_piece_on_grid(& as->kg, pp, as->checkColumn, row, as->checkRotation);
#line 667
  if (nLines != -1) {
#line 668
    eval = evalBoard(& as->kg, nLines, row);
#line 672
    if (as->bestEval == (double )-1) {
      goto _L___4;
    } else {
#line 672
      if (eval < as->bestEval) {
        _L___4: /* CIL Label */ 
#line 673
        as->bestEval = eval;
#line 674
        as->goalColumn = as->checkColumn;
#line 675
        as->goalRotation = as->checkRotation;
#line 681
        if (as->checkColumn > 0) {
#line 681
          if (! *(g___0->contents + ((as->checkColumn - 1) + row * g___0->w))) {
#line 683
            y = row;
#line 683
            while (y >= 0) {
#line 685
              if (*(g___0->contents + ((as->checkColumn - 1) + y * g___0->w))) {
#line 685
                break;
              }
#line 683
              y --;
            }
#line 686
            if (y >= 0) {
#line 686
              tmp___3 = valid_position(pp, as->checkColumn - 1, row, as->checkRotation,
                                       & as->kg);
#line 686
              if (tmp___3) {
#line 688
                printf((char const   * __restrict  )"Aliz: Trying to slip left.\n");
#line 690
                memcpy((void * __restrict  )as->kg.contents, (void const   * __restrict  )g___0->contents,
                       (unsigned int )(g___0->w * g___0->h) * sizeof(*(as->kg.contents + 0)));
#line 691
                memcpy((void * __restrict  )as->kg.fall, (void const   * __restrict  )g___0->fall,
                       (unsigned int )(g___0->w * g___0->h) * sizeof(*(as->kg.fall)));
#line 692
                paste_on_board(pp, as->checkColumn - 1, row, as->checkRotation, & as->kg);
#line 695
                evalLeft = evalBoard(& as->kg, nLines, row);
              }
            }
          }
        }
#line 700
        if (as->checkColumn < g___0->w - 1) {
#line 700
          if (! *(g___0->contents + ((as->checkColumn + 1) + row * g___0->w))) {
#line 702
            y___0 = row;
#line 702
            while (y___0 >= 0) {
#line 704
              if (*(g___0->contents + ((as->checkColumn + 1) + y___0 * g___0->w))) {
#line 704
                break;
              }
#line 702
              y___0 --;
            }
#line 705
            if (y___0 >= 0) {
#line 705
              tmp___4 = valid_position(pp, as->checkColumn + 1, row, as->checkRotation,
                                       & as->kg);
#line 705
              if (tmp___4) {
#line 707
                printf((char const   * __restrict  )"Aliz: Trying to slip right.\n");
#line 709
                memcpy((void * __restrict  )as->kg.contents, (void const   * __restrict  )g___0->contents,
                       (unsigned int )(g___0->w * g___0->h) * sizeof(*(as->kg.contents + 0)));
#line 710
                memcpy((void * __restrict  )as->kg.fall, (void const   * __restrict  )g___0->fall,
                       (unsigned int )(g___0->w * g___0->h) * sizeof(*(as->kg.fall)));
#line 711
                paste_on_board(pp, as->checkColumn + 1, row, as->checkRotation, & as->kg);
#line 714
                evalRight = evalBoard(& as->kg, nLines, row);
              }
            }
          }
        }
#line 718
        if (evalLeft >= (double )0) {
#line 718
          if (evalLeft < as->bestEval) {
#line 718
            if (evalLeft <= evalRight) {
#line 719
              as->goalColumn = as->checkColumn;
#line 720
              as->goalSides = -1;
#line 721
              printf((char const   * __restrict  )": eval = %.3f left **", eval);
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 722
          if (evalRight >= (double )0) {
#line 722
            if (evalRight < as->bestEval) {
#line 722
              if (evalRight < evalLeft) {
#line 723
                as->goalColumn = as->checkColumn;
#line 724
                as->goalSides = 1;
#line 725
                printf((char const   * __restrict  )": eval = %.3f right **", eval);
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 731
            if (as->bestEval == (double )-1) {
#line 732
              as->bestEval = eval;
#line 733
              as->goalColumn = as->checkColumn;
#line 734
              as->goalRotation = as->checkRotation;
#line 735
              as->goalSides = as->checkSides;
            } else {
#line 731
              if (eval < as->bestEval) {
#line 732
                as->bestEval = eval;
#line 733
                as->goalColumn = as->checkColumn;
#line 734
                as->goalRotation = as->checkRotation;
#line 735
                as->goalSides = as->checkSides;
              }
            }
          }
        }
      }
    }
  }
#line 744
  return;
}
}
#line 750 "ai.c"
static void *alizReset(void *state , Grid *g___0 ) 
{ Aliz_State *as ;
  void *tmp ;

  {
#line 755
  if ((unsigned int )state == (unsigned int )((void *)0)) {
#line 757
    tmp = calloc(sizeof(Aliz_State ), 1U);
#line 757
    as = (Aliz_State *)tmp;
#line 757
    if (! as) {
#line 757
      Panic("alizReset", "ai.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for as",
            sizeof(Aliz_State ));
    }
  } else {
#line 759
    as = (Aliz_State *)state;
  }
#line 760
  if (! as) {
#line 760
    Panic("alizReset", "ai.c", (char *)"Failed assertion \"%s\" on line %d", "as",
          760);
  }
#line 765
  as->bestEval = (double )-1;
#line 766
  as->foundBest = 0;
#line 767
  if ((unsigned int )as->kg.contents == (unsigned int )((void *)0)) {
#line 767
    as->kg = generate_board(g___0->w, g___0->h, 0);
  }
#line 768
  return ((void *)as);
}
}
#line 780 "ai.c"
static Command alizMove(void *state , Grid *g___0 , play_piece *pp , play_piece *np ,
                        int col , int row , int rot ) 
{ Aliz_State *as ;

  {
#line 783
  as = (Aliz_State *)state;
#line 784
  if (! as) {
#line 784
    Panic("alizMove", "ai.c", (char *)"Failed assertion \"%s\" on line %d", "as",
          784);
  }
#line 785
  if (rot == as->goalRotation) {
#line 786
    if (col == as->goalColumn) {
#line 787
      if (as->foundBest) {
#line 788
        if (*(g___0->contents + (col + (row + 1) * g___0->w))) {
#line 789
          if (as->goalSides == -1) {
#line 789
            return (1);
          } else {
#line 790
            if (as->goalSides == 1) {
#line 790
              return (2);
            }
          }
        }
#line 792
        return (4);
      } else {
#line 794
        return (0);
      }
    } else {
#line 795
      if (col < as->goalColumn) {
#line 795
        return (2);
      } else {
#line 796
        return (1);
      }
    }
  } else {
#line 797
    return (3);
  }
}
}
#line 807 "ai.c"
AI_Players *AI_Players_Setup(void) 
{ int i ;
  AI_Players *retval ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 813
  tmp = calloc(sizeof(AI_Players ), 1U);
#line 813
  retval = (AI_Players *)tmp;
#line 813
  if (! retval) {
#line 813
    Panic("AI_Players_Setup", "ai.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
          sizeof(AI_Players ));
  }
#line 815
  retval->n = 4;
#line 816
  tmp___0 = calloc(sizeof(AI_Player ) * (unsigned int )retval->n, 1U);
#line 816
  retval->player = (AI_Player *)tmp___0;
#line 816
  if (! retval->player) {
#line 816
    Panic("AI_Players_Setup", "ai.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval->player",
          sizeof(AI_Player ) * (unsigned int )retval->n);
  }
#line 817
  i = 0;
#line 819
  (retval->player + i)->name = (char *)"Simple Robot";
#line 820
  (retval->player + i)->msg = (char *)"An introductory opponent.";
#line 821
  (retval->player + i)->move = & wes_ai_move;
#line 822
  (retval->player + i)->think = & beginner_ai_think;
#line 823
  (retval->player + i)->reset = & wes_ai_reset;
#line 824
  i ++;
#line 826
  (retval->player + i)->name = (char *)"Lightning";
#line 827
  (retval->player + i)->msg = (char *)"Warp-speed heuristics.";
#line 828
  (retval->player + i)->move = & wes_ai_move;
#line 829
  (retval->player + i)->think = & wes_ai_think;
#line 830
  (retval->player + i)->reset = & wes_ai_reset;
#line 831
  i ++;
#line 833
  (retval->player + i)->name = (char *)"Aliz";
#line 834
  (retval->player + i)->msg = (char *)"Kiri\'s codified wit and wisdom.";
#line 835
  (retval->player + i)->move = & alizMove;
#line 836
  (retval->player + i)->think = & alizCogitate;
#line 837
  (retval->player + i)->reset = & alizReset;
#line 838
  i ++;
#line 840
  (retval->player + i)->name = (char *)"Double-Think";
#line 841
  (retval->player + i)->msg = (char *)"Brilliant but slow.";
#line 842
  (retval->player + i)->move = & double_ai_move;
#line 843
  (retval->player + i)->think = & double_ai_think;
#line 844
  (retval->player + i)->reset = & double_ai_reset;
#line 845
  i ++;
#line 847
  printf((char const   * __restrict  )"%-14.14s| ", "AI_Players_Setup");
#line 847
  printf((char const   * __restrict  )"AI Players Initialized (%d AIs).\n", retval->n);
#line 847
  fflush(stdout);
#line 849
  return (retval);
}
}
#line 856 "ai.c"
int pick_key_repeat(SDL_Surface *screen___0 ) 
{ char *factor ;
  int retval ;

  {
#line 862
  clear_screen_to_flame();
#line 863
  draw_string((char *)"(1 = Slow Repeat, 16 = Default, 32 = Fastest)", color_purple,
              screen___0->w / 2, screen___0->h / 2, ((1 << 3) | 1) | (1 << 1));
#line 866
  draw_string((char *)"Keyboard repeat delay factor:", color_purple, screen___0->w / 2,
              screen___0->h / 2, (1 << 3) | (1 << 2));
#line 868
  factor = input_string(screen___0, screen___0->w / 2, screen___0->h / 2, 0);
#line 869
  retval = 0;
#line 870
  sscanf((char const   * __restrict  )factor, (char const   * __restrict  )"%d", & retval);
#line 871
  free((void *)factor);
#line 872
  if (retval < 1) {
#line 872
    retval = 1;
  }
#line 873
  if (retval > 32) {
#line 873
    retval = 32;
  }
#line 874
  clear_screen_to_flame();
#line 875
  return (retval);
}
}
#line 882 "ai.c"
int pick_ai_factor(SDL_Surface *screen___0 ) 
{ char *factor ;
  int retval ;

  {
#line 888
  clear_screen_to_flame();
#line 889
  draw_string((char *)"(1 = Impossible, 100 = Easy, 0 = Set Automatically)", color_purple,
              screen___0->w / 2, screen___0->h / 2, ((1 << 3) | 1) | (1 << 1));
#line 892
  draw_string((char *)"Pick an AI delay factor:", color_purple, screen___0->w / 2,
              screen___0->h / 2, (1 << 3) | (1 << 2));
#line 894
  factor = input_string(screen___0, screen___0->w / 2, screen___0->h / 2, 0);
#line 895
  retval = 0;
#line 896
  sscanf((char const   * __restrict  )factor, (char const   * __restrict  )"%d", & retval);
#line 897
  free((void *)factor);
#line 898
  if (retval < 0) {
#line 898
    retval = 0;
  }
#line 899
  if (retval > 100) {
#line 899
    retval = 100;
  }
#line 900
  return (retval);
}
}
#line 910 "ai.c"
int pick_an_ai(SDL_Surface *screen___0 , char *msg , AI_Players *AI ) 
{ WalkRadioGroup *wrg___1 ;
  int i ;
  int text_h ;
  int retval ;
  SDL_Event event ;
  char buf[1024] ;
  char *tmp___8 ;
  int retval___0 ;

  {
#line 918
  wrg___1 = create_single_wrg(AI->n + 1);
#line 919
  i = 0;
#line 919
  while (i < AI->n) {
#line 921
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"\"%s\" : %s",
            (AI->player + i)->name, (AI->player + i)->msg);
#line 922
    tmp___8 = __strdup((char const   *)(buf));
#line 922
    *((wrg___1->wr + 0)->label + i) = tmp___8;
#line 919
    i ++;
  }
#line 925
  *((wrg___1->wr + 0)->label + AI->n) = (char *)"-- Cancel --";
#line 927
  retval = 0;
#line 927
  (wrg___1->wr + 0)->defaultchoice = retval;
#line 929
  if ((wrg___1->wr + 0)->defaultchoice > AI->n) {
#line 930
    Panic("pick_an_ai", "ai.c", (char *)"not enough choices!");
  }
#line 932
  setup_radio(wrg___1->wr + 0);
#line 934
  (wrg___1->wr + 0)->x = (screen___0->w - (int )(wrg___1->wr + 0)->area.w) / 2;
#line 935
  (wrg___1->wr + 0)->y = (screen___0->h - (int )(wrg___1->wr + 0)->area.h) / 2;
#line 937
  clear_screen_to_flame();
#line 939
  text_h = draw_string(msg, color_blue, screen___0->w / 2, (wrg___1->wr + 0)->y - 30,
                       (1 << 3) | 1);
#line 942
  draw_string((char *)"Choose a Computer Player", color_blue, screen___0->w / 2, ((wrg___1->wr + 0)->y - 30) - text_h,
              (1 << 3) | 1);
#line 945
  draw_radio(wrg___1->wr + 0, 1);
#line 947
  while (1) {
#line 949
    poll_and_flame(& event);
#line 951
    retval___0 = handle_radio_event(wrg___1, (SDL_Event const   *)(& event));
#line 952
    if (retval___0 == -1) {
#line 953
      continue;
    }
#line 954
    if (retval___0 == AI->n) {
#line 955
      return (-1);
    }
#line 956
    return (retval___0);
  }
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "atris.o"
#pragma merger(0,"/tmp/cil-xwNu28XB.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 309 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 216 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 251
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 348
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 354
__inline static int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
#line 538
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 735
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 33 "/usr/include/bits/stdio.h"
__inline static int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ int tmp ;

  {
#line 36
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
#line 36
  return (tmp);
}
}
#line 632 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 102 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 331
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 38 "/usr/include/SDL/SDL_error.h"
extern char __attribute__((__visibility__("default")))  *SDL_GetError(void) ;
#line 244 "/usr/include/SDL/SDL_audio.h"
extern void __attribute__((__visibility__("default")))  SDL_CloseAudio(void) ;
#line 73 "/usr/include/SDL/SDL_keyboard.h"
extern int __attribute__((__visibility__("default")))  SDL_EnableUNICODE(int enable ) ;
#line 86
extern int __attribute__((__visibility__("default")))  SDL_EnableKeyRepeat(int delay ,
                                                                           int interval ) ;
#line 347 "/usr/include/SDL/SDL_video.h"
extern SDL_Surface __attribute__((__visibility__("default")))  *SDL_SetVideoMode(int width ,
                                                                                 int height ,
                                                                                 int bpp ,
                                                                                 Uint32 flags ) ;
#line 829
extern void __attribute__((__visibility__("default")))  SDL_WM_SetCaption(char const   *title ,
                                                                          char const   *icon ) ;
#line 271 "/usr/include/SDL/SDL_events.h"
extern int __attribute__((__visibility__("default")))  SDL_PollEvent(SDL_Event *event ) ;
#line 49 "/usr/include/SDL/SDL_timer.h"
extern void __attribute__((__visibility__("default")))  SDL_Delay(Uint32 ms ) ;
#line 69 "/usr/include/SDL/SDL.h"
extern int __attribute__((__visibility__("default")))  SDL_Init(Uint32 flags ) ;
#line 86
extern void __attribute__((__visibility__("default")))  SDL_Quit(void) ;
#line 83 "/usr/include/SDL/SDL_ttf.h"
extern int __attribute__((__visibility__("default")))  TTF_Init(void) ;
#line 89
extern TTF_Font __attribute__((__visibility__("default")))  *TTF_OpenFont(char const   *file ,
                                                                          int ptsize ) ;
#line 103
extern void __attribute__((__visibility__("default")))  TTF_SetFontStyle(TTF_Font *font ,
                                                                         int style ) ;
#line 216
extern void __attribute__((__visibility__("default")))  TTF_CloseFont(TTF_Font *font ) ;
#line 219
extern void __attribute__((__visibility__("default")))  TTF_Quit(void) ;
#line 136 "/usr/include/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 143
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 96 "atris.h"
void SeedRandom(Uint32 Seed ) ;
#line 97
Uint16 FastRandom(Uint16 range ) ;
#line 2 ".protos/piece.pro"
piece_styles load_piece_styles(void) ;
#line 4
color_styles load_color_styles(SDL_Surface *screen___0 ) ;
#line 12 ".protos/sound.pro"
sound_styles load_sound_styles(int sound_wanted ) ;
#line 10 "options.h"
struct option_struct Options  ;
#line 6 ".protos/display.pro"
void setup_colors(SDL_Surface *screen___0 ) ;
#line 18
int give_notice(char *s , int quit_possible ) ;
#line 24
void setup_layers(SDL_Surface *screen___0 ) ;
#line 26
void draw_background(SDL_Surface *screen___0 , int blockWidth , Grid *g___0 , int *level ,
                     int *my_adj , int *their_adj , char **name ) ;
#line 33
void draw_score(SDL_Surface *screen___0 , int i ) ;
#line 16 ".protos/event.pro"
int event_loop(SDL_Surface *screen___0 , piece_style *ps , color_style **cs , sound_style **ss ,
               Grid *g___0 , int *level , int sock , int *seconds_remaining , int time_is_hard_limit ,
               int *adjust , int (*handle)(SDL_Event const   * ) , int seed , int p1 ,
               int p2 , AI_Player **AI ) ;
#line 2 ".protos/gamemenu.pro"
int choose_gametype(piece_styles *ps , color_styles *cs , sound_styles *ss , AI_Players *ai ) ;
#line 2 ".protos/highscore.pro"
void high_score_check(int level , int new_score ) ;
#line 4 ".protos/identity.pro"
identity *load_identity_file(void) ;
#line 6
void save_identity_file(identity *id , char *new_name , int new_level ) ;
#line 8
char *network_choice(SDL_Surface *screen___0 ) ;
#line 10
int who_are_you(SDL_Surface *screen___0 , identity **id , int taken , int p ) ;
#line 2 ".protos/network.pro"
int Server_AwaitConnection(int port ) ;
#line 4
int Client_Connect(char *hoststr , int lport ) ;
#line 6
int Network_Init(void) ;
#line 8
void Network_Quit(void) ;
#line 4 ".protos/xflame.pro"
void atris_xflame_setup(void) ;
#line 46 "atris.c"
static color_style *event_cs[2]  ;
#line 47 "atris.c"
static sound_style *event_ss[2]  ;
#line 48 "atris.c"
static AI_Player *event_ai[2]  ;
#line 49 "atris.c"
static char *event_name[2]  ;
#line 50
int Score[2] ;
#line 56
 __attribute__((__noreturn__)) void Panic(char const   *func , char const   *file ,
                                          char *fmt  , ...) ;
#line 56 "atris.c"
void Panic(char const   *func , char const   *file , char *fmt  , ...) 
{ va_list ap ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char __attribute__((__visibility__("default")))  *tmp___2 ;

  {
#line 60
  __builtin_va_start(ap, fmt);
#line 62
  printf((char const   * __restrict  )"\nPANIC in %s() of %s:\n\t", func, file);
#line 64
  vprintf((char const   * __restrict  )((char const   *)fmt), ap);
#line 68
  tmp = __errno_location();
#line 68
  tmp___0 = strerror(*tmp);
#line 68
  tmp___1 = __errno_location();
#line 68
  printf((char const   * __restrict  )"\n\nlibc error %3d| %s\n", *tmp___1, tmp___0);
#line 69
  tmp___2 = SDL_GetError();
#line 69
  printf((char const   * __restrict  )"SDL error     | %s\n", tmp___2);
#line 70
  SDL_CloseAudio();
#line 71
  exit(1);
}
}
#line 78 "atris.c"
static void usage(void) 
{ 

  {
#line 81
  printf((char const   * __restrict  )"\n\t\t\t\tatris -- Alizarin Tetris\nUsage: atris [options] \n\t-h --help\t\tThis message.\n\t-b --bg     \t\tFlaming background (default).\n\t-n --noflame\t\tNo flaming background.\n\t-s --sound\t\tEnable sound effects (default).\n\t-q --quiet\t\tNo sound effects.\n\t-w --window\t\tWindowed display (default).\n\t-f --fullscreen\t\tFull-screen display.\n\t-d=X --depth=X\t\tSet color detph (bpp) to X.\n\t-r=X --repeat=X\t\tSet the keyboard repeat delay to X.\n\t\t\t\t(1 = Slow Repeat, 16 = Fast Repeat)\n");
#line 94
  exit(1);
}
}
#line 101 "atris.c"
void save_options(char *filespec ) 
{ FILE *fout ;
  FILE *tmp ;

  {
#line 104
  tmp = fopen((char const   * __restrict  )filespec, (char const   * __restrict  )"wt");
#line 104
  fout = tmp;
#line 105
  if (! fout) {
#line 105
    return;
  }
#line 106
  fprintf((FILE * __restrict  )fout, (char const   * __restrict  )"# bpp = 15, 16, 24, 32 or 0 for auto-detect bits per pixel\nbpp = %d\n# sound_wanted = 0 or 1\nsound_wanted = %d\n# full_screen = 0 or 1\nfull_screen = %d\n# flame = 0 or 1 (CPU-sucking background flame)\nflame = %d\n# key_repeat = 1 to 32 (1 = slow repeat, 16 = default)\nkey_repeat = %d\n# power_pieces = 0 or 1\npower_pieces = %d\n# double_difficulty = 0 or 1\ndouble_difficulty = %d\n# long_settle = 0 or 1\nlong_settle = %d\n# upward_rotation = 0 or 1\nupward_rotation = %d\n#\ncolor_style = %d\nsound_style = %d\npiece_style = %d\ngame_style = %d\n",
          Options.bpp_wanted, Options.sound_wanted, Options.full_screen, Options.flame_wanted,
          Options.key_repeat_delay, Options.special_wanted, Options.faster_levels,
          Options.long_settle_delay, Options.upward_rotation, Options.named_color,
          Options.named_sound, Options.named_piece, Options.named_game);
#line 138
  fclose(fout);
#line 139
  printf((char const   * __restrict  )"%-14.14s| ", "save_options");
#line 139
  printf((char const   * __restrict  )"Preference file [%s] saved.\n", filespec);
#line 139
  fflush(stdout);
#line 140
  return;
}
}
#line 147 "atris.c"
void load_options(char *filespec ) 
{ FILE *fin ;
  FILE *tmp ;
  char buf[1024] ;
  char cmd[1024] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 150
  tmp = fopen((char const   * __restrict  )filespec, (char const   * __restrict  )"rt");
#line 150
  fin = tmp;
#line 152
  Options.full_screen = 0;
#line 153
  Options.sound_wanted = 1;
#line 154
  Options.flame_wanted = 1;
#line 155
  Options.bpp_wanted = 0;
#line 156
  Options.key_repeat_delay = 16;
#line 157
  Options.special_wanted = 0;
#line 158
  Options.faster_levels = 0;
#line 159
  Options.upward_rotation = 1;
#line 160
  Options.long_settle_delay = 1;
#line 161
  Options.named_color = -1;
#line 162
  Options.named_sound = -1;
#line 163
  Options.named_piece = -1;
#line 164
  Options.named_game = -1;
#line 166
  if (! fin) {
#line 166
    return;
  }
#line 168
  while (1) {
#line 168
    tmp___14 = feof(fin);
#line 168
    if (tmp___14) {
#line 168
      break;
    }
#line 171
    fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 172
    tmp___0 = feof(fin);
#line 172
    if (tmp___0) {
#line 172
      break;
    }
#line 173
    if ((int )buf[0] == 35) {
#line 174
      continue;
    } else {
#line 173
      if ((int )buf[0] == 10) {
#line 174
        continue;
      }
    }
#line 176
    sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s",
           cmd);
#line 177
    tmp___13 = strcasecmp((char const   *)(cmd), "full_screen");
#line 177
    if (tmp___13) {
#line 179
      tmp___12 = strcasecmp((char const   *)(cmd), "sound_wanted");
#line 179
      if (tmp___12) {
#line 181
        tmp___11 = strcasecmp((char const   *)(cmd), "flame");
#line 181
        if (tmp___11) {
#line 183
          tmp___10 = strcasecmp((char const   *)(cmd), "bpp");
#line 183
          if (tmp___10) {
#line 185
            tmp___9 = strcasecmp((char const   *)(cmd), "key_repeat");
#line 185
            if (tmp___9) {
#line 189
              tmp___8 = strcasecmp((char const   *)(cmd), "power_pieces");
#line 189
              if (tmp___8) {
#line 191
                tmp___7 = strcasecmp((char const   *)(cmd), "double_difficulty");
#line 191
                if (tmp___7) {
#line 193
                  tmp___6 = strcasecmp((char const   *)(cmd), "long_settle");
#line 193
                  if (tmp___6) {
#line 195
                    tmp___5 = strcasecmp((char const   *)(cmd), "upward_rotation");
#line 195
                    if (tmp___5) {
#line 197
                      tmp___4 = strcasecmp((char const   *)(cmd), "color_style");
#line 197
                      if (tmp___4) {
#line 199
                        tmp___3 = strcasecmp((char const   *)(cmd), "sound_style");
#line 199
                        if (tmp___3) {
#line 201
                          tmp___2 = strcasecmp((char const   *)(cmd), "piece_style");
#line 201
                          if (tmp___2) {
#line 203
                            tmp___1 = strcasecmp((char const   *)(cmd), "game_style");
#line 203
                            if (tmp___1) {
#line 206
                              printf((char const   * __restrict  )"%-14.14s| ", "load_options");
#line 206
                              printf((char const   * __restrict  )"Unable to parse configuration line\n%s",
                                     buf);
#line 206
                              fflush(stdout);
                            } else {
#line 204
                              sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                                     cmd, & Options.named_game);
                            }
                          } else {
#line 202
                            sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                                   cmd, & Options.named_piece);
                          }
                        } else {
#line 200
                          sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                                 cmd, & Options.named_sound);
                        }
                      } else {
#line 198
                        sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                               cmd, & Options.named_color);
                      }
                    } else {
#line 196
                      sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                             cmd, & Options.upward_rotation);
                    }
                  } else {
#line 194
                    sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                           cmd, & Options.long_settle_delay);
                  }
                } else {
#line 192
                  sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                         cmd, & Options.faster_levels);
                }
              } else {
#line 190
                sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                       cmd, & Options.special_wanted);
              }
            } else {
#line 186
              sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                     cmd, & Options.key_repeat_delay);
#line 187
              if (Options.key_repeat_delay < 1) {
#line 187
                Options.key_repeat_delay = 1;
              }
#line 188
              if (Options.key_repeat_delay > 32) {
#line 188
                Options.key_repeat_delay = 32;
              }
            }
          } else {
#line 184
            sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                   cmd, & Options.bpp_wanted);
          }
        } else {
#line 182
          sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
                 cmd, & Options.flame_wanted);
        }
      } else {
#line 180
        sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
               cmd, & Options.sound_wanted);
      }
    } else {
#line 178
      sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s = %d",
             cmd, & Options.full_screen);
    }
  }
#line 209
  fclose(fin);
#line 210
  printf((char const   * __restrict  )"%-14.14s| ", "load_options");
#line 210
  printf((char const   * __restrict  )"Preference file [%s] loaded.\n", filespec);
#line 210
  fflush(stdout);
#line 211
  return;
}
}
#line 218 "atris.c"
static void parse_options(int argc , char **argv ) 
{ int i ;
  char *tmp___0 ;
  char *tmp___2 ;
  int tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___42 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___68 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___94 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___100 ;
  int tmp___103 ;
  int tmp___104 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___112 ;
  int tmp___115 ;
  int tmp___116 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___122 ;
  int tmp___125 ;
  int tmp___126 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___132 ;
  int tmp___135 ;
  int tmp___136 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___142 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___152 ;
  int tmp___155 ;
  int tmp___156 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___162 ;
  int tmp___165 ;
  int tmp___166 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___172 ;
  int tmp___175 ;
  int tmp___176 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___182 ;
  int tmp___185 ;
  int tmp___186 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___192 ;
  int tmp___195 ;
  int tmp___196 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___202 ;
  int tmp___205 ;
  int tmp___206 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___212 ;
  int tmp___215 ;
  int tmp___216 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___222 ;
  int tmp___225 ;
  int tmp___226 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___232 ;
  int tmp___235 ;
  int tmp___236 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___242 ;
  int tmp___245 ;
  int tmp___246 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___252 ;
  int tmp___255 ;
  int tmp___256 ;
  size_t __s1_len___22 ;
  size_t __s2_len___22 ;
  int tmp___262 ;
  int tmp___265 ;
  int tmp___266 ;

  {
#line 223
  i = 1;
#line 223
  while (i < argc) {
#line 224
    if (0) {
#line 224
      __s1_len___21 = strlen((char const   *)*(argv + i));
#line 224
      __s2_len___21 = strlen("-h");
#line 224
      if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
        goto _L___45;
      } else {
#line 224
        if (__s1_len___21 >= 4U) {
          _L___45: /* CIL Label */ 
#line 224
          if (! ((unsigned int )((void const   *)("-h" + 1)) - (unsigned int )((void const   *)"-h") == 1U)) {
#line 224
            tmp___256 = 1;
          } else {
#line 224
            if (__s2_len___21 >= 4U) {
#line 224
              tmp___256 = 1;
            } else {
#line 224
              tmp___256 = 0;
            }
          }
        } else {
#line 224
          tmp___256 = 0;
        }
      }
#line 224
      if (tmp___256) {
#line 224
        tmp___252 = __builtin_strcmp((char const   *)*(argv + i), "-h");
      } else {
#line 224
        tmp___255 = __builtin_strcmp((char const   *)*(argv + i), "-h");
#line 224
        tmp___252 = tmp___255;
      }
    } else {
#line 224
      tmp___255 = __builtin_strcmp((char const   *)*(argv + i), "-h");
#line 224
      tmp___252 = tmp___255;
    }
#line 224
    if (tmp___252) {
#line 224
      if (0) {
#line 224
        __s1_len___22 = strlen((char const   *)*(argv + i));
#line 224
        __s2_len___22 = strlen("--help");
#line 224
        if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
          goto _L___47;
        } else {
#line 224
          if (__s1_len___22 >= 4U) {
            _L___47: /* CIL Label */ 
#line 224
            if (! ((unsigned int )((void const   *)("--help" + 1)) - (unsigned int )((void const   *)"--help") == 1U)) {
#line 224
              tmp___266 = 1;
            } else {
#line 224
              if (__s2_len___22 >= 4U) {
#line 224
                tmp___266 = 1;
              } else {
#line 224
                tmp___266 = 0;
              }
            }
          } else {
#line 224
            tmp___266 = 0;
          }
        }
#line 224
        if (tmp___266) {
#line 224
          tmp___262 = __builtin_strcmp((char const   *)*(argv + i), "--help");
        } else {
#line 224
          tmp___265 = __builtin_strcmp((char const   *)*(argv + i), "--help");
#line 224
          tmp___262 = tmp___265;
        }
      } else {
#line 224
        tmp___265 = __builtin_strcmp((char const   *)*(argv + i), "--help");
#line 224
        tmp___262 = tmp___265;
      }
#line 224
      if (tmp___262) {
#line 226
        if (0) {
#line 226
          __s1_len___19 = strlen((char const   *)*(argv + i));
#line 226
          __s2_len___19 = strlen("-?");
#line 226
          if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
            goto _L___41;
          } else {
#line 226
            if (__s1_len___19 >= 4U) {
              _L___41: /* CIL Label */ 
#line 226
              if (! ((unsigned int )((void const   *)("-?" + 1)) - (unsigned int )((void const   *)"-?") == 1U)) {
#line 226
                tmp___236 = 1;
              } else {
#line 226
                if (__s2_len___19 >= 4U) {
#line 226
                  tmp___236 = 1;
                } else {
#line 226
                  tmp___236 = 0;
                }
              }
            } else {
#line 226
              tmp___236 = 0;
            }
          }
#line 226
          if (tmp___236) {
#line 226
            tmp___232 = __builtin_strcmp((char const   *)*(argv + i), "-?");
          } else {
#line 226
            tmp___235 = __builtin_strcmp((char const   *)*(argv + i), "-?");
#line 226
            tmp___232 = tmp___235;
          }
        } else {
#line 226
          tmp___235 = __builtin_strcmp((char const   *)*(argv + i), "-?");
#line 226
          tmp___232 = tmp___235;
        }
#line 226
        if (tmp___232) {
#line 226
          if (0) {
#line 226
            __s1_len___20 = strlen((char const   *)*(argv + i));
#line 226
            __s2_len___20 = strlen("-help");
#line 226
            if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
              goto _L___43;
            } else {
#line 226
              if (__s1_len___20 >= 4U) {
                _L___43: /* CIL Label */ 
#line 226
                if (! ((unsigned int )((void const   *)("-help" + 1)) - (unsigned int )((void const   *)"-help") == 1U)) {
#line 226
                  tmp___246 = 1;
                } else {
#line 226
                  if (__s2_len___20 >= 4U) {
#line 226
                    tmp___246 = 1;
                  } else {
#line 226
                    tmp___246 = 0;
                  }
                }
              } else {
#line 226
                tmp___246 = 0;
              }
            }
#line 226
            if (tmp___246) {
#line 226
              tmp___242 = __builtin_strcmp((char const   *)*(argv + i), "-help");
            } else {
#line 226
              tmp___245 = __builtin_strcmp((char const   *)*(argv + i), "-help");
#line 226
              tmp___242 = tmp___245;
            }
          } else {
#line 226
            tmp___245 = __builtin_strcmp((char const   *)*(argv + i), "-help");
#line 226
            tmp___242 = tmp___245;
          }
#line 226
          if (tmp___242) {
#line 228
            if (0) {
#line 228
              __s1_len___17 = strlen((char const   *)*(argv + i));
#line 228
              __s2_len___17 = strlen("-b");
#line 228
              if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                goto _L___37;
              } else {
#line 228
                if (__s1_len___17 >= 4U) {
                  _L___37: /* CIL Label */ 
#line 228
                  if (! ((unsigned int )((void const   *)("-b" + 1)) - (unsigned int )((void const   *)"-b") == 1U)) {
#line 228
                    tmp___216 = 1;
                  } else {
#line 228
                    if (__s2_len___17 >= 4U) {
#line 228
                      tmp___216 = 1;
                    } else {
#line 228
                      tmp___216 = 0;
                    }
                  }
                } else {
#line 228
                  tmp___216 = 0;
                }
              }
#line 228
              if (tmp___216) {
#line 228
                tmp___212 = __builtin_strcmp((char const   *)*(argv + i), "-b");
              } else {
#line 228
                tmp___215 = __builtin_strcmp((char const   *)*(argv + i), "-b");
#line 228
                tmp___212 = tmp___215;
              }
            } else {
#line 228
              tmp___215 = __builtin_strcmp((char const   *)*(argv + i), "-b");
#line 228
              tmp___212 = tmp___215;
            }
#line 228
            if (tmp___212) {
#line 228
              if (0) {
#line 228
                __s1_len___18 = strlen((char const   *)*(argv + i));
#line 228
                __s2_len___18 = strlen("--bg");
#line 228
                if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                  goto _L___39;
                } else {
#line 228
                  if (__s1_len___18 >= 4U) {
                    _L___39: /* CIL Label */ 
#line 228
                    if (! ((unsigned int )((void const   *)("--bg" + 1)) - (unsigned int )((void const   *)"--bg") == 1U)) {
#line 228
                      tmp___226 = 1;
                    } else {
#line 228
                      if (__s2_len___18 >= 4U) {
#line 228
                        tmp___226 = 1;
                      } else {
#line 228
                        tmp___226 = 0;
                      }
                    }
                  } else {
#line 228
                    tmp___226 = 0;
                  }
                }
#line 228
                if (tmp___226) {
#line 228
                  tmp___222 = __builtin_strcmp((char const   *)*(argv + i), "--bg");
                } else {
#line 228
                  tmp___225 = __builtin_strcmp((char const   *)*(argv + i), "--bg");
#line 228
                  tmp___222 = tmp___225;
                }
              } else {
#line 228
                tmp___225 = __builtin_strcmp((char const   *)*(argv + i), "--bg");
#line 228
                tmp___222 = tmp___225;
              }
#line 228
              if (tmp___222) {
#line 230
                if (0) {
#line 230
                  __s1_len___15 = strlen((char const   *)*(argv + i));
#line 230
                  __s2_len___15 = strlen("-n");
#line 230
                  if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                    goto _L___33;
                  } else {
#line 230
                    if (__s1_len___15 >= 4U) {
                      _L___33: /* CIL Label */ 
#line 230
                      if (! ((unsigned int )((void const   *)("-n" + 1)) - (unsigned int )((void const   *)"-n") == 1U)) {
#line 230
                        tmp___196 = 1;
                      } else {
#line 230
                        if (__s2_len___15 >= 4U) {
#line 230
                          tmp___196 = 1;
                        } else {
#line 230
                          tmp___196 = 0;
                        }
                      }
                    } else {
#line 230
                      tmp___196 = 0;
                    }
                  }
#line 230
                  if (tmp___196) {
#line 230
                    tmp___192 = __builtin_strcmp((char const   *)*(argv + i), "-n");
                  } else {
#line 230
                    tmp___195 = __builtin_strcmp((char const   *)*(argv + i), "-n");
#line 230
                    tmp___192 = tmp___195;
                  }
                } else {
#line 230
                  tmp___195 = __builtin_strcmp((char const   *)*(argv + i), "-n");
#line 230
                  tmp___192 = tmp___195;
                }
#line 230
                if (tmp___192) {
#line 230
                  if (0) {
#line 230
                    __s1_len___16 = strlen((char const   *)*(argv + i));
#line 230
                    __s2_len___16 = strlen("--noflame");
#line 230
                    if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                      goto _L___35;
                    } else {
#line 230
                      if (__s1_len___16 >= 4U) {
                        _L___35: /* CIL Label */ 
#line 230
                        if (! ((unsigned int )((void const   *)("--noflame" + 1)) - (unsigned int )((void const   *)"--noflame") == 1U)) {
#line 230
                          tmp___206 = 1;
                        } else {
#line 230
                          if (__s2_len___16 >= 4U) {
#line 230
                            tmp___206 = 1;
                          } else {
#line 230
                            tmp___206 = 0;
                          }
                        }
                      } else {
#line 230
                        tmp___206 = 0;
                      }
                    }
#line 230
                    if (tmp___206) {
#line 230
                      tmp___202 = __builtin_strcmp((char const   *)*(argv + i), "--noflame");
                    } else {
#line 230
                      tmp___205 = __builtin_strcmp((char const   *)*(argv + i), "--noflame");
#line 230
                      tmp___202 = tmp___205;
                    }
                  } else {
#line 230
                    tmp___205 = __builtin_strcmp((char const   *)*(argv + i), "--noflame");
#line 230
                    tmp___202 = tmp___205;
                  }
#line 230
                  if (tmp___202) {
#line 232
                    if (0) {
#line 232
                      __s1_len___13 = strlen((char const   *)*(argv + i));
#line 232
                      __s2_len___13 = strlen("-s");
#line 232
                      if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                        goto _L___29;
                      } else {
#line 232
                        if (__s1_len___13 >= 4U) {
                          _L___29: /* CIL Label */ 
#line 232
                          if (! ((unsigned int )((void const   *)("-s" + 1)) - (unsigned int )((void const   *)"-s") == 1U)) {
#line 232
                            tmp___176 = 1;
                          } else {
#line 232
                            if (__s2_len___13 >= 4U) {
#line 232
                              tmp___176 = 1;
                            } else {
#line 232
                              tmp___176 = 0;
                            }
                          }
                        } else {
#line 232
                          tmp___176 = 0;
                        }
                      }
#line 232
                      if (tmp___176) {
#line 232
                        tmp___172 = __builtin_strcmp((char const   *)*(argv + i),
                                                     "-s");
                      } else {
#line 232
                        tmp___175 = __builtin_strcmp((char const   *)*(argv + i),
                                                     "-s");
#line 232
                        tmp___172 = tmp___175;
                      }
                    } else {
#line 232
                      tmp___175 = __builtin_strcmp((char const   *)*(argv + i), "-s");
#line 232
                      tmp___172 = tmp___175;
                    }
#line 232
                    if (tmp___172) {
#line 232
                      if (0) {
#line 232
                        __s1_len___14 = strlen((char const   *)*(argv + i));
#line 232
                        __s2_len___14 = strlen("--sound");
#line 232
                        if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                          goto _L___31;
                        } else {
#line 232
                          if (__s1_len___14 >= 4U) {
                            _L___31: /* CIL Label */ 
#line 232
                            if (! ((unsigned int )((void const   *)("--sound" + 1)) - (unsigned int )((void const   *)"--sound") == 1U)) {
#line 232
                              tmp___186 = 1;
                            } else {
#line 232
                              if (__s2_len___14 >= 4U) {
#line 232
                                tmp___186 = 1;
                              } else {
#line 232
                                tmp___186 = 0;
                              }
                            }
                          } else {
#line 232
                            tmp___186 = 0;
                          }
                        }
#line 232
                        if (tmp___186) {
#line 232
                          tmp___182 = __builtin_strcmp((char const   *)*(argv + i),
                                                       "--sound");
                        } else {
#line 232
                          tmp___185 = __builtin_strcmp((char const   *)*(argv + i),
                                                       "--sound");
#line 232
                          tmp___182 = tmp___185;
                        }
                      } else {
#line 232
                        tmp___185 = __builtin_strcmp((char const   *)*(argv + i),
                                                     "--sound");
#line 232
                        tmp___182 = tmp___185;
                      }
#line 232
                      if (tmp___182) {
#line 234
                        if (0) {
#line 234
                          __s1_len___11 = strlen((char const   *)*(argv + i));
#line 234
                          __s2_len___11 = strlen("-q");
#line 234
                          if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                            goto _L___25;
                          } else {
#line 234
                            if (__s1_len___11 >= 4U) {
                              _L___25: /* CIL Label */ 
#line 234
                              if (! ((unsigned int )((void const   *)("-q" + 1)) - (unsigned int )((void const   *)"-q") == 1U)) {
#line 234
                                tmp___156 = 1;
                              } else {
#line 234
                                if (__s2_len___11 >= 4U) {
#line 234
                                  tmp___156 = 1;
                                } else {
#line 234
                                  tmp___156 = 0;
                                }
                              }
                            } else {
#line 234
                              tmp___156 = 0;
                            }
                          }
#line 234
                          if (tmp___156) {
#line 234
                            tmp___152 = __builtin_strcmp((char const   *)*(argv + i),
                                                         "-q");
                          } else {
#line 234
                            tmp___155 = __builtin_strcmp((char const   *)*(argv + i),
                                                         "-q");
#line 234
                            tmp___152 = tmp___155;
                          }
                        } else {
#line 234
                          tmp___155 = __builtin_strcmp((char const   *)*(argv + i),
                                                       "-q");
#line 234
                          tmp___152 = tmp___155;
                        }
#line 234
                        if (tmp___152) {
#line 234
                          if (0) {
#line 234
                            __s1_len___12 = strlen((char const   *)*(argv + i));
#line 234
                            __s2_len___12 = strlen("--quiet");
#line 234
                            if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                              goto _L___27;
                            } else {
#line 234
                              if (__s1_len___12 >= 4U) {
                                _L___27: /* CIL Label */ 
#line 234
                                if (! ((unsigned int )((void const   *)("--quiet" + 1)) - (unsigned int )((void const   *)"--quiet") == 1U)) {
#line 234
                                  tmp___166 = 1;
                                } else {
#line 234
                                  if (__s2_len___12 >= 4U) {
#line 234
                                    tmp___166 = 1;
                                  } else {
#line 234
                                    tmp___166 = 0;
                                  }
                                }
                              } else {
#line 234
                                tmp___166 = 0;
                              }
                            }
#line 234
                            if (tmp___166) {
#line 234
                              tmp___162 = __builtin_strcmp((char const   *)*(argv + i),
                                                           "--quiet");
                            } else {
#line 234
                              tmp___165 = __builtin_strcmp((char const   *)*(argv + i),
                                                           "--quiet");
#line 234
                              tmp___162 = tmp___165;
                            }
                          } else {
#line 234
                            tmp___165 = __builtin_strcmp((char const   *)*(argv + i),
                                                         "--quiet");
#line 234
                            tmp___162 = tmp___165;
                          }
#line 234
                          if (tmp___162) {
#line 236
                            if (0) {
#line 236
                              __s1_len___9 = strlen((char const   *)*(argv + i));
#line 236
                              __s2_len___9 = strlen("-w");
#line 236
                              if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                goto _L___21;
                              } else {
#line 236
                                if (__s1_len___9 >= 4U) {
                                  _L___21: /* CIL Label */ 
#line 236
                                  if (! ((unsigned int )((void const   *)("-w" + 1)) - (unsigned int )((void const   *)"-w") == 1U)) {
#line 236
                                    tmp___136 = 1;
                                  } else {
#line 236
                                    if (__s2_len___9 >= 4U) {
#line 236
                                      tmp___136 = 1;
                                    } else {
#line 236
                                      tmp___136 = 0;
                                    }
                                  }
                                } else {
#line 236
                                  tmp___136 = 0;
                                }
                              }
#line 236
                              if (tmp___136) {
#line 236
                                tmp___132 = __builtin_strcmp((char const   *)*(argv + i),
                                                             "-w");
                              } else {
#line 236
                                tmp___135 = __builtin_strcmp((char const   *)*(argv + i),
                                                             "-w");
#line 236
                                tmp___132 = tmp___135;
                              }
                            } else {
#line 236
                              tmp___135 = __builtin_strcmp((char const   *)*(argv + i),
                                                           "-w");
#line 236
                              tmp___132 = tmp___135;
                            }
#line 236
                            if (tmp___132) {
#line 236
                              if (0) {
#line 236
                                __s1_len___10 = strlen((char const   *)*(argv + i));
#line 236
                                __s2_len___10 = strlen("--window");
#line 236
                                if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                  goto _L___23;
                                } else {
#line 236
                                  if (__s1_len___10 >= 4U) {
                                    _L___23: /* CIL Label */ 
#line 236
                                    if (! ((unsigned int )((void const   *)("--window" + 1)) - (unsigned int )((void const   *)"--window") == 1U)) {
#line 236
                                      tmp___146 = 1;
                                    } else {
#line 236
                                      if (__s2_len___10 >= 4U) {
#line 236
                                        tmp___146 = 1;
                                      } else {
#line 236
                                        tmp___146 = 0;
                                      }
                                    }
                                  } else {
#line 236
                                    tmp___146 = 0;
                                  }
                                }
#line 236
                                if (tmp___146) {
#line 236
                                  tmp___142 = __builtin_strcmp((char const   *)*(argv + i),
                                                               "--window");
                                } else {
#line 236
                                  tmp___145 = __builtin_strcmp((char const   *)*(argv + i),
                                                               "--window");
#line 236
                                  tmp___142 = tmp___145;
                                }
                              } else {
#line 236
                                tmp___145 = __builtin_strcmp((char const   *)*(argv + i),
                                                             "--window");
#line 236
                                tmp___142 = tmp___145;
                              }
#line 236
                              if (tmp___142) {
#line 238
                                if (0) {
#line 238
                                  __s1_len___7 = strlen((char const   *)*(argv + i));
#line 238
                                  __s2_len___7 = strlen("-f");
#line 238
                                  if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                    goto _L___17;
                                  } else {
#line 238
                                    if (__s1_len___7 >= 4U) {
                                      _L___17: /* CIL Label */ 
#line 238
                                      if (! ((unsigned int )((void const   *)("-f" + 1)) - (unsigned int )((void const   *)"-f") == 1U)) {
#line 238
                                        tmp___116 = 1;
                                      } else {
#line 238
                                        if (__s2_len___7 >= 4U) {
#line 238
                                          tmp___116 = 1;
                                        } else {
#line 238
                                          tmp___116 = 0;
                                        }
                                      }
                                    } else {
#line 238
                                      tmp___116 = 0;
                                    }
                                  }
#line 238
                                  if (tmp___116) {
#line 238
                                    tmp___112 = __builtin_strcmp((char const   *)*(argv + i),
                                                                 "-f");
                                  } else {
#line 238
                                    tmp___115 = __builtin_strcmp((char const   *)*(argv + i),
                                                                 "-f");
#line 238
                                    tmp___112 = tmp___115;
                                  }
                                } else {
#line 238
                                  tmp___115 = __builtin_strcmp((char const   *)*(argv + i),
                                                               "-f");
#line 238
                                  tmp___112 = tmp___115;
                                }
#line 238
                                if (tmp___112) {
#line 238
                                  if (0) {
#line 238
                                    __s1_len___8 = strlen((char const   *)*(argv + i));
#line 238
                                    __s2_len___8 = strlen("--fullscreen");
#line 238
                                    if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                      goto _L___19;
                                    } else {
#line 238
                                      if (__s1_len___8 >= 4U) {
                                        _L___19: /* CIL Label */ 
#line 238
                                        if (! ((unsigned int )((void const   *)("--fullscreen" + 1)) - (unsigned int )((void const   *)"--fullscreen") == 1U)) {
#line 238
                                          tmp___126 = 1;
                                        } else {
#line 238
                                          if (__s2_len___8 >= 4U) {
#line 238
                                            tmp___126 = 1;
                                          } else {
#line 238
                                            tmp___126 = 0;
                                          }
                                        }
                                      } else {
#line 238
                                        tmp___126 = 0;
                                      }
                                    }
#line 238
                                    if (tmp___126) {
#line 238
                                      tmp___122 = __builtin_strcmp((char const   *)*(argv + i),
                                                                   "--fullscreen");
                                    } else {
#line 238
                                      tmp___125 = __builtin_strcmp((char const   *)*(argv + i),
                                                                   "--fullscreen");
#line 238
                                      tmp___122 = tmp___125;
                                    }
                                  } else {
#line 238
                                    tmp___125 = __builtin_strcmp((char const   *)*(argv + i),
                                                                 "--fullscreen");
#line 238
                                    tmp___122 = tmp___125;
                                  }
#line 238
                                  if (tmp___122) {
#line 240
                                    if (0) {
#line 240
                                      if (0) {
#line 240
                                        __s1_len___4 = strlen((char const   *)*(argv + i));
#line 240
                                        __s2_len___4 = strlen("-d=");
#line 240
                                        if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                          goto _L___11;
                                        } else {
#line 240
                                          if (__s1_len___4 >= 4U) {
                                            _L___11: /* CIL Label */ 
#line 240
                                            if (! ((unsigned int )((void const   *)("-d=" + 1)) - (unsigned int )((void const   *)"-d=") == 1U)) {
#line 240
                                              tmp___78 = 1;
                                            } else {
#line 240
                                              if (__s2_len___4 >= 4U) {
#line 240
                                                tmp___78 = 1;
                                              } else {
#line 240
                                                tmp___78 = 0;
                                              }
                                            }
                                          } else {
#line 240
                                            tmp___78 = 0;
                                          }
                                        }
#line 240
                                        if (tmp___78) {
#line 240
                                          tmp___74 = __builtin_strcmp((char const   *)*(argv + i),
                                                                      "-d=");
                                        } else {
#line 240
                                          tmp___77 = __builtin_strcmp((char const   *)*(argv + i),
                                                                      "-d=");
#line 240
                                          tmp___74 = tmp___77;
                                        }
                                      } else {
#line 240
                                        tmp___77 = __builtin_strcmp((char const   *)*(argv + i),
                                                                    "-d=");
#line 240
                                        tmp___74 = tmp___77;
                                      }
#line 240
                                      tmp___68 = tmp___74;
                                    } else {
#line 240
                                      tmp___68 = strncmp((char const   *)*(argv + i),
                                                         "-d=", 3U);
                                    }
#line 240
                                    if (tmp___68) {
#line 240
                                      if (0) {
#line 240
                                        if (0) {
#line 240
                                          __s1_len___6 = strlen((char const   *)*(argv + i));
#line 240
                                          __s2_len___6 = strlen("--depth=");
#line 240
                                          if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                            goto _L___15;
                                          } else {
#line 240
                                            if (__s1_len___6 >= 4U) {
                                              _L___15: /* CIL Label */ 
#line 240
                                              if (! ((unsigned int )((void const   *)("--depth=" + 1)) - (unsigned int )((void const   *)"--depth=") == 1U)) {
#line 240
                                                tmp___104 = 1;
                                              } else {
#line 240
                                                if (__s2_len___6 >= 4U) {
#line 240
                                                  tmp___104 = 1;
                                                } else {
#line 240
                                                  tmp___104 = 0;
                                                }
                                              }
                                            } else {
#line 240
                                              tmp___104 = 0;
                                            }
                                          }
#line 240
                                          if (tmp___104) {
#line 240
                                            tmp___100 = __builtin_strcmp((char const   *)*(argv + i),
                                                                         "--depth=");
                                          } else {
#line 240
                                            tmp___103 = __builtin_strcmp((char const   *)*(argv + i),
                                                                         "--depth=");
#line 240
                                            tmp___100 = tmp___103;
                                          }
                                        } else {
#line 240
                                          tmp___103 = __builtin_strcmp((char const   *)*(argv + i),
                                                                       "--depth=");
#line 240
                                          tmp___100 = tmp___103;
                                        }
#line 240
                                        tmp___94 = tmp___100;
                                      } else {
#line 240
                                        tmp___94 = strncmp((char const   *)*(argv + i),
                                                           "--depth=", 8U);
                                      }
#line 240
                                      if (tmp___94) {
#line 242
                                        if (0) {
#line 242
                                          if (0) {
#line 242
                                            __s1_len___0 = strlen((char const   *)*(argv + i));
#line 242
                                            __s2_len___0 = strlen("-r=");
#line 242
                                            if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                              goto _L___2;
                                            } else {
#line 242
                                              if (__s1_len___0 >= 4U) {
                                                _L___2: /* CIL Label */ 
#line 242
                                                if (! ((unsigned int )((void const   *)("-r=" + 1)) - (unsigned int )((void const   *)"-r=") == 1U)) {
#line 242
                                                  tmp___26 = 1;
                                                } else {
#line 242
                                                  if (__s2_len___0 >= 4U) {
#line 242
                                                    tmp___26 = 1;
                                                  } else {
#line 242
                                                    tmp___26 = 0;
                                                  }
                                                }
                                              } else {
#line 242
                                                tmp___26 = 0;
                                              }
                                            }
#line 242
                                            if (tmp___26) {
#line 242
                                              tmp___22 = __builtin_strcmp((char const   *)*(argv + i),
                                                                          "-r=");
                                            } else {
#line 242
                                              tmp___25 = __builtin_strcmp((char const   *)*(argv + i),
                                                                          "-r=");
#line 242
                                              tmp___22 = tmp___25;
                                            }
                                          } else {
#line 242
                                            tmp___25 = __builtin_strcmp((char const   *)*(argv + i),
                                                                        "-r=");
#line 242
                                            tmp___22 = tmp___25;
                                          }
#line 242
                                          tmp___16 = tmp___22;
                                        } else {
#line 242
                                          tmp___16 = strncmp((char const   *)*(argv + i),
                                                             "-r=", 3U);
                                        }
#line 242
                                        if (tmp___16) {
#line 242
                                          if (0) {
#line 242
                                            if (0) {
#line 242
                                              __s1_len___2 = strlen((char const   *)*(argv + i));
#line 242
                                              __s2_len___2 = strlen("--repeat=");
#line 242
                                              if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                                goto _L___6;
                                              } else {
#line 242
                                                if (__s1_len___2 >= 4U) {
                                                  _L___6: /* CIL Label */ 
#line 242
                                                  if (! ((unsigned int )((void const   *)("--repeat=" + 1)) - (unsigned int )((void const   *)"--repeat=") == 1U)) {
#line 242
                                                    tmp___52 = 1;
                                                  } else {
#line 242
                                                    if (__s2_len___2 >= 4U) {
#line 242
                                                      tmp___52 = 1;
                                                    } else {
#line 242
                                                      tmp___52 = 0;
                                                    }
                                                  }
                                                } else {
#line 242
                                                  tmp___52 = 0;
                                                }
                                              }
#line 242
                                              if (tmp___52) {
#line 242
                                                tmp___48 = __builtin_strcmp((char const   *)*(argv + i),
                                                                            "--repeat=");
                                              } else {
#line 242
                                                tmp___51 = __builtin_strcmp((char const   *)*(argv + i),
                                                                            "--repeat=");
#line 242
                                                tmp___48 = tmp___51;
                                              }
                                            } else {
#line 242
                                              tmp___51 = __builtin_strcmp((char const   *)*(argv + i),
                                                                          "--repeat=");
#line 242
                                              tmp___48 = tmp___51;
                                            }
#line 242
                                            tmp___42 = tmp___48;
                                          } else {
#line 242
                                            tmp___42 = strncmp((char const   *)*(argv + i),
                                                               "--repeat=", 8U);
                                          }
#line 242
                                          if (tmp___42) {
#line 247
                                            printf((char const   * __restrict  )"%-14.14s| ",
                                                   "parse_options");
#line 247
                                            printf((char const   * __restrict  )"option not understood: [%s]\n",
                                                   *(argv + i));
#line 247
                                            fflush(stdout);
#line 248
                                            usage();
                                          } else {
                                            _L___7: /* CIL Label */ 
#line 243
                                            tmp___2 = __builtin_strchr(*(argv + i),
                                                                       '=');
#line 243
                                            sscanf((char const   * __restrict  )(tmp___2 + 1),
                                                   (char const   * __restrict  )"%d",
                                                   & Options.key_repeat_delay);
#line 244
                                            if (Options.key_repeat_delay < 1) {
#line 244
                                              Options.key_repeat_delay = 1;
                                            }
#line 245
                                            if (Options.key_repeat_delay > 32) {
#line 245
                                              Options.key_repeat_delay = 32;
                                            }
                                          }
                                        } else {
                                          goto _L___7;
                                        }
                                      } else {
#line 241
                                        tmp___0 = __builtin_strchr(*(argv + i), '=');
#line 241
                                        sscanf((char const   * __restrict  )(tmp___0 + 1),
                                               (char const   * __restrict  )"%d",
                                               & Options.bpp_wanted);
                                      }
                                    } else {
#line 241
                                      tmp___0 = __builtin_strchr(*(argv + i), '=');
#line 241
                                      sscanf((char const   * __restrict  )(tmp___0 + 1),
                                             (char const   * __restrict  )"%d", & Options.bpp_wanted);
                                    }
                                  } else {
#line 239
                                    Options.full_screen = 1;
                                  }
                                } else {
#line 239
                                  Options.full_screen = 1;
                                }
                              } else {
#line 237
                                Options.full_screen = 0;
                              }
                            } else {
#line 237
                              Options.full_screen = 0;
                            }
                          } else {
#line 235
                            Options.sound_wanted = 0;
                          }
                        } else {
#line 235
                          Options.sound_wanted = 0;
                        }
                      } else {
#line 233
                        Options.sound_wanted = 1;
                      }
                    } else {
#line 233
                      Options.sound_wanted = 1;
                    }
                  } else {
#line 231
                    Options.flame_wanted = 0;
                  }
                } else {
#line 231
                  Options.flame_wanted = 0;
                }
              } else {
#line 229
                Options.flame_wanted = 1;
              }
            } else {
#line 229
              Options.flame_wanted = 1;
            }
          } else {
#line 227
            usage();
          }
        } else {
#line 227
          usage();
        }
      } else {
#line 225
        usage();
      }
    } else {
#line 225
      usage();
    }
#line 223
    i ++;
  }
#line 251
  printf((char const   * __restrict  )"%-14.14s| ", "parse_options");
#line 251
  printf((char const   * __restrict  )"Command line arguments parsed.\n");
#line 251
  fflush(stdout);
#line 252
  return;
}
}
#line 261 "atris.c"
static int level_adjust(int *a , int *b , int *level , int match ) 
{ int i ;
  int up[2] ;
  int down[2] ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 265
  up[0] = 0;
#line 265
  up[1] = 0;
#line 265
  down[0] = 0;
#line 265
  down[1] = 0;
#line 267
  i = 0;
#line 267
  while (i <= match) {
#line 268
    if (*(a + i) == 0) {
#line 268
      (up[0]) ++;
    }
#line 269
    if (*(a + i) == 2) {
#line 269
      (down[0]) ++;
    }
#line 270
    if (*(b + i) == 0) {
#line 270
      (up[1]) ++;
    }
#line 271
    if (*(b + i) == 2) {
#line 271
      (down[1]) ++;
    }
#line 267
    i ++;
  }
#line 274
  while (1) {
#line 274
    if (up[0] > 0) {
#line 274
      if (! (up[1] > 0)) {
#line 274
        break;
      }
    } else {
#line 274
      break;
    }
#line 275
    (up[0]) --;
#line 276
    (up[1]) --;
  }
#line 278
  while (1) {
#line 278
    if (up[0] > 0) {
#line 278
      if (! (down[0] > 0)) {
#line 278
        break;
      }
    } else {
#line 278
      break;
    }
#line 279
    (up[0]) --;
#line 280
    (down[0]) --;
  }
#line 282
  while (1) {
#line 282
    if (up[1] > 0) {
#line 282
      if (! (down[1] > 0)) {
#line 282
        break;
      }
    } else {
#line 282
      break;
    }
#line 283
    (up[1]) --;
#line 284
    (down[1]) --;
  }
#line 286
  while (1) {
#line 286
    if (down[0] > 0) {
#line 286
      if (! (down[1] > 0)) {
#line 286
        break;
      }
    } else {
#line 286
      break;
    }
#line 287
    (down[0]) --;
#line 288
    (down[1]) --;
  }
#line 290
  if (up[0] == 3) {
    goto _L;
  } else {
#line 290
    if (down[0] == 3) {
      goto _L;
    } else {
#line 290
      if (up[1] == 3) {
        goto _L;
      } else {
#line 290
        if (down[1] == 3) {
          _L: /* CIL Label */ 
#line 291
          if (up[0] == 3) {
#line 291
            (*(level + 0)) ++;
          }
#line 292
          if (down[0] == 3) {
#line 292
            (*(level + 0)) --;
          }
#line 293
          if (up[1] == 3) {
#line 293
            (*(level + 1)) ++;
          }
#line 294
          if (down[1] == 3) {
#line 294
            (*(level + 1)) --;
          }
#line 295
          *(b + 2) = -1;
#line 295
          *(b + 1) = *(b + 2);
#line 295
          *(b + 0) = *(b + 1);
#line 295
          *(a + 2) = *(b + 0);
#line 295
          *(a + 1) = *(a + 2);
#line 295
          *(a + 0) = *(a + 1);
#line 296
          return (0);
        }
      }
    }
  }
#line 298
  *(b + 2) = -1;
#line 298
  *(b + 1) = *(b + 2);
#line 298
  *(b + 0) = *(b + 1);
#line 298
  *(a + 2) = *(b + 0);
#line 298
  *(a + 1) = *(a + 2);
#line 298
  *(a + 0) = *(a + 1);
#line 299
  if (up[0] > up[1]) {
#line 299
    tmp___3 = up[0];
  } else {
#line 299
    tmp___3 = up[1];
  }
#line 299
  if (down[0] > down[1]) {
#line 299
    tmp___4 = down[0];
  } else {
#line 299
    tmp___4 = down[1];
  }
#line 299
  if (tmp___3 > tmp___4) {
#line 299
    if (up[0] > up[1]) {
#line 299
      match = up[0];
    } else {
#line 299
      match = up[1];
    }
  } else {
#line 299
    if (down[0] > down[1]) {
#line 299
      match = down[0];
    } else {
#line 299
      match = down[1];
    }
  }
#line 301
  i = 0;
#line 301
  while (i < up[0]) {
#line 302
    *(a + i) = 0;
#line 301
    i ++;
  }
#line 303
  i = up[0];
#line 303
  while (i < up[0] + down[0]) {
#line 304
    *(a + i) = 2;
#line 303
    i ++;
  }
#line 305
  i = up[0] + down[0];
#line 305
  while (i < match) {
#line 306
    *(a + i) = 1;
#line 305
    i ++;
  }
#line 308
  i = 0;
#line 308
  while (i < up[1]) {
#line 309
    *(b + i) = 0;
#line 308
    i ++;
  }
#line 310
  i = up[1];
#line 310
  while (i < up[1] + down[1]) {
#line 311
    *(b + i) = 2;
#line 310
    i ++;
  }
#line 312
  i = up[1] + down[1];
#line 312
  while (i < match) {
#line 313
    *(b + i) = 1;
#line 312
    i ++;
  }
#line 315
  return (match);
}
}
#line 323 "atris.c"
static void play_TWO_PLAYERS(color_styles cs , piece_styles ps , sound_styles ss ,
                             Grid *g___0 , person *p1 , person *p2 ) 
{ int curtimeleft ;
  int match ;
  int adjustment[2] ;
  int my_adj[3] ;
  int their_adj[3] ;
  int done ;
  int level[2] ;
  time_t our_time ;
  int tmp ;

  {
#line 329
  adjustment[0] = -1;
#line 329
  adjustment[1] = -1;
#line 332
  done = 0;
#line 336
  my_adj[2] = -1;
#line 336
  my_adj[1] = my_adj[2];
#line 336
  my_adj[0] = my_adj[1];
#line 337
  their_adj[2] = -1;
#line 337
  their_adj[1] = their_adj[2];
#line 337
  their_adj[0] = their_adj[1];
#line 338
  match = 0;
#line 340
  level[0] = p1->level;
#line 341
  level[1] = p2->level;
#line 344
  while (! done) {
#line 345
    time(& our_time);
#line 348
    SeedRandom((unsigned int )our_time);
#line 349
    *(g___0 + 0) = generate_board(10, 20, level[0]);
#line 350
    SeedRandom((unsigned int )our_time);
#line 351
    *(g___0 + 1) = generate_board(10, 20, level[1]);
#line 352
    SeedRandom((unsigned int )our_time);
#line 354
    event_name[0] = p1->name;
#line 355
    event_name[1] = p2->name;
#line 358
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, their_adj,
                    event_name);
#line 362
    curtimeleft = 120;
#line 364
    event_cs[1] = *(cs.style + cs.choice);
#line 364
    event_cs[0] = event_cs[1];
#line 365
    event_ss[1] = *(ss.style + ss.choice);
#line 365
    event_ss[0] = event_ss[1];
#line 367
    tmp = event_loop(screen, *(ps.style + ps.choice), (color_style **)(event_cs),
                     (sound_style **)(event_ss), (Grid *)g___0, (int *)(level), 0,
                     & curtimeleft, 0, adjustment, (int (*)(SDL_Event const   * ))((void *)0),
                     (int )our_time, 1, 1, (AI_Player **)((void *)0));
#line 367
    if (tmp >= 0) {
#line 371
      draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj,
                      their_adj, event_name);
#line 373
      SDL_Delay(1000U);
    }
#line 375
    my_adj[match] = adjustment[0];
#line 376
    their_adj[match] = adjustment[1];
#line 377
    match = level_adjust((int *)(my_adj), (int *)(their_adj), (int *)(level), match);
#line 381
    p1->level = level[0];
#line 382
    p2->level = level[1];
#line 385
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, their_adj,
                    event_name);
#line 387
    draw_score(screen, 0);
#line 388
    draw_score(screen, 1);
#line 389
    done = give_notice((char *)((void *)0), 1);
  }
#line 391
  return;
}
}
#line 399 "atris.c"
static void play_AI_VS_AI(color_styles cs , piece_styles ps , sound_styles ss , Grid *g___0 ,
                          AI_Player *p1 , AI_Player *p2 ) 
{ int curtimeleft ;
  int match ;
  int level[2] ;
  int adjustment[2] ;
  int my_adj[3] ;
  int their_adj[3] ;
  int done ;
  time_t our_time ;
  int p1_results[3] ;
  int p2_results[3] ;
  Uint16 tmp___1 ;
  Uint16 tmp___2 ;
  Uint16 tmp___3 ;
  int tmp___4 ;

  {
#line 406
  adjustment[0] = -1;
#line 406
  adjustment[1] = -1;
#line 409
  done = 0;
#line 411
  p1_results[0] = 0;
#line 411
  p1_results[1] = 0;
#line 411
  p1_results[2] = 0;
#line 412
  p2_results[0] = 0;
#line 412
  p2_results[1] = 0;
#line 412
  p2_results[2] = 0;
#line 414
  my_adj[0] = -1;
#line 414
  my_adj[1] = -1;
#line 414
  my_adj[2] = -1;
#line 415
  their_adj[0] = -1;
#line 415
  their_adj[1] = -1;
#line 415
  their_adj[2] = -1;
#line 416
  match = 0;
#line 419
  while (! done) {
#line 421
    time(& our_time);
#line 423
    if (Options.faster_levels) {
#line 423
      tmp___1 = FastRandom((unsigned short)8);
#line 423
      level[1] = 1 + (int )tmp___1;
    } else {
#line 423
      tmp___2 = FastRandom((unsigned short)16);
#line 423
      level[1] = 2 + (int )tmp___2;
    }
#line 423
    level[0] = level[1];
#line 427
    SeedRandom((unsigned int )our_time);
#line 428
    *(g___0 + 0) = generate_board(10, 20, level[0]);
#line 429
    SeedRandom((unsigned int )our_time);
#line 430
    *(g___0 + 1) = generate_board(10, 20, level[0]);
#line 431
    SeedRandom((unsigned int )our_time);
#line 433
    event_name[0] = p1->name;
#line 434
    event_name[1] = p2->name;
#line 437
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, p1_results,
                    p2_results, event_name);
#line 440
    curtimeleft = 120;
#line 442
    event_cs[0] = *(cs.style + cs.choice);
#line 443
    tmp___3 = FastRandom((unsigned short )cs.num_style);
#line 443
    event_cs[1] = *(cs.style + tmp___3);
#line 444
    event_ss[1] = *(ss.style + ss.choice);
#line 444
    event_ss[0] = event_ss[1];
#line 445
    event_ai[0] = p1;
#line 445
    event_ai[1] = p2;
#line 447
    tmp___4 = event_loop(screen, *(ps.style + ps.choice), (color_style **)(event_cs),
                         (sound_style **)(event_ss), (Grid *)g___0, (int *)(level),
                         0, & curtimeleft, 0, adjustment, (int (*)(SDL_Event const   * ))((void *)0),
                         (int )our_time, 2, 2, (AI_Player **)(event_ai));
#line 447
    if (tmp___4 < 0) {
#line 451
      return;
    }
#line 454
    if (adjustment[0] != -1) {
#line 455
      (p1_results[adjustment[0]]) ++;
    }
#line 456
    if (adjustment[1] != -1) {
#line 457
      (p2_results[adjustment[1]]) ++;
    }
#line 460
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, p1_results,
                    p2_results, event_name);
#line 462
    draw_score(screen, 0);
#line 463
    draw_score(screen, 1);
  }
#line 465
  return;
}
}
#line 473 "atris.c"
static int play_SINGLE_VS_AI(color_styles cs , piece_styles ps , sound_styles ss ,
                             Grid *g___0 , person *p , AI_Player *aip ) 
{ int curtimeleft ;
  int match ;
  int level[2] ;
  int adjustment[2] ;
  int my_adj[3] ;
  int their_adj[3] ;
  int done ;
  time_t our_time ;
  Uint16 tmp ;
  int tmp___0 ;

  {
#line 480
  adjustment[0] = -1;
#line 480
  adjustment[1] = -1;
#line 483
  done = 0;
#line 486
  my_adj[2] = -1;
#line 486
  my_adj[1] = my_adj[2];
#line 486
  my_adj[0] = my_adj[1];
#line 487
  their_adj[2] = -1;
#line 487
  their_adj[1] = their_adj[2];
#line 487
  their_adj[0] = their_adj[1];
#line 488
  match = 0;
#line 491
  level[1] = p->level;
#line 491
  level[0] = level[1];
#line 492
  while (! done) {
#line 493
    time(& our_time);
#line 495
    level[1] = level[0];
#line 497
    SeedRandom((unsigned int )our_time);
#line 498
    *(g___0 + 0) = generate_board(10, 20, level[0]);
#line 499
    SeedRandom((unsigned int )our_time);
#line 500
    *(g___0 + 1) = generate_board(10, 20, level[0]);
#line 501
    SeedRandom((unsigned int )our_time);
#line 503
    event_name[0] = p->name;
#line 504
    event_name[1] = aip->name;
#line 507
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, their_adj,
                    event_name);
#line 511
    curtimeleft = 120;
#line 513
    event_cs[0] = *(cs.style + cs.choice);
#line 514
    tmp = FastRandom((unsigned short )cs.num_style);
#line 514
    event_cs[1] = *(cs.style + tmp);
#line 515
    event_ss[1] = *(ss.style + ss.choice);
#line 515
    event_ss[0] = event_ss[1];
#line 516
    event_ai[0] = (AI_Player *)((void *)0);
#line 516
    event_ai[1] = aip;
#line 518
    tmp___0 = event_loop(screen, *(ps.style + ps.choice), (color_style **)(event_cs),
                         (sound_style **)(event_ss), (Grid *)g___0, (int *)(level),
                         0, & curtimeleft, 0, adjustment, (int (*)(SDL_Event const   * ))((void *)0),
                         (int )our_time, 1, 2, (AI_Player **)(event_ai));
#line 518
    if (tmp___0 >= 0) {
#line 522
      draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj,
                      their_adj, event_name);
#line 524
      draw_score(screen, 0);
#line 525
      draw_score(screen, 1);
#line 526
      SDL_Delay(1000U);
    }
#line 528
    my_adj[match] = adjustment[0];
#line 529
    their_adj[match] = adjustment[1];
#line 530
    match = level_adjust((int *)(my_adj), (int *)(their_adj), (int *)(level), match);
#line 533
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, their_adj,
                    event_name);
#line 535
    draw_score(screen, 0);
#line 536
    draw_score(screen, 1);
#line 537
    done = give_notice((char *)((void *)0), 1);
  }
#line 539
  return (level[0]);
}
}
#line 553
char *error_msg ;
#line 548 "atris.c"
static int play_NETWORK(color_styles cs , piece_styles ps , sound_styles ss , Grid *g___0 ,
                        person *p , char *hostname ) 
{ int curtimeleft ;
  int server ;
  int match ;
  int level[2] ;
  int adjustment[2] ;
  int my_adj[3] ;
  int their_adj[3] ;
  char message[1024] ;
  char *their_name ;
  int done ;
  int sock ;
  int their_cs_choice ;
  int their_data ;
  time_t our_time ;
  SDL_Event event ;
  int __attribute__((__visibility__("default")))  tmp ;
  int i ;
  SDL_Event event___0 ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  ssize_t tmp___10 ;
  size_t tmp___11 ;
  ssize_t tmp___12 ;
  size_t tmp___13 ;
  ssize_t tmp___14 ;
  size_t tmp___15 ;
  ssize_t tmp___16 ;
  ssize_t tmp___17 ;
  ssize_t tmp___18 ;
  void *tmp___19 ;
  ssize_t tmp___20 ;
  ssize_t tmp___21 ;
  ssize_t tmp___22 ;
  ssize_t tmp___23 ;
  ssize_t tmp___24 ;
  unsigned int msg ;
  ssize_t tmp___25 ;
  ssize_t tmp___26 ;
  unsigned int msg___0 ;
  ssize_t tmp___27 ;
  ssize_t tmp___28 ;
  ssize_t tmp___29 ;
  SDL_Event event___1 ;
  ssize_t tmp___30 ;
  int __attribute__((__visibility__("default")))  tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;

  {
#line 557
  adjustment[0] = -1;
#line 557
  adjustment[1] = -1;
#line 562
  done = 0;
#line 568
  server = (unsigned int )hostname == (unsigned int )((void *)0);
#line 576
  level[0] = p->level;
#line 578
  if (server) {
#line 581
    clear_screen_to_flame();
#line 583
    draw_string((char *)"Waiting for the client ...", color_blue, screen->w / 2, screen->h / 2,
                (1 | (1 << 1)) | (1 << 3));
#line 586
    draw_string((char *)"Press \'Q\' to give up.", color_blue, screen->w / 2, screen->h / 2,
                1 | (1 << 3));
#line 589
    while (1) {
#line 590
      sock = Server_AwaitConnection(7741);
#line 591
      if (sock == -1) {
#line 591
        tmp = SDL_PollEvent(& event);
#line 591
        if (tmp) {
#line 591
          if ((int )event.type == 2) {
#line 592
            if ((int )event.key.keysym.sym == 113) {
              goto done;
            }
          }
        }
      }
#line 589
      if (! (sock == -1)) {
#line 589
        break;
      }
    }
  } else {
#line 598
    sock = -1;
#line 599
    i = 0;
#line 599
    while (1) {
#line 599
      if (i < 5) {
#line 599
        if (! (sock == -1)) {
#line 599
          break;
        }
      } else {
#line 599
        break;
      }
#line 600
      sock = Client_Connect(hostname, 7741);
#line 601
      if (sock == -1) {
#line 601
        tmp___0 = SDL_PollEvent(& event___0);
#line 601
        if (tmp___0) {
#line 601
          if ((int )event___0.type == 2) {
#line 601
            if ((int )event___0.key.keysym.sym == 113) {
              goto done;
            }
          }
        }
      }
#line 604
      if (sock == -1) {
#line 604
        SDL_Delay(1000U);
      }
#line 599
      i ++;
    }
#line 606
    if (sock == -1) {
      goto error;
    }
  }
#line 609
  clear_screen_to_flame();
#line 612
  tmp___1 = send(sock, (void const   *)((char const   *)(& (*(cs.style + cs.choice))->num_color)),
                 sizeof(int ), 0);
#line 612
  if (tmp___1 < (int )sizeof(int )) {
    goto error;
  }
#line 613
  tmp___2 = recv(sock, (void *)((char *)(& their_data)), sizeof(int ), 0);
#line 613
  if (tmp___2 < (int )sizeof(int )) {
    goto error;
  }
#line 614
  if (their_data != (*(cs.style + cs.choice))->num_color) {
#line 615
    sprintf((char * __restrict  )(message), (char const   * __restrict  )"The # of colors in your styles are not equal. (%d/%d)",
            (*(cs.style + cs.choice))->num_color, their_data);
    goto known_error;
  }
#line 620
  tmp___3 = send(sock, (void const   *)((char const   *)(& (*(ps.style + ps.choice))->num_piece)),
                 sizeof(int ), 0);
#line 620
  if (tmp___3 < (int )sizeof(int )) {
    goto error;
  }
#line 621
  tmp___4 = recv(sock, (void *)((char *)(& their_data)), sizeof(int ), 0);
#line 621
  if (tmp___4 < (int )sizeof(int )) {
    goto error;
  }
#line 622
  if (their_data != (*(ps.style + ps.choice))->num_piece) {
#line 623
    sprintf((char * __restrict  )(message), (char const   * __restrict  )"The # of shapes in your styles are not equal. (%d/%d)",
            (*(ps.style + ps.choice))->num_piece, their_data);
    goto known_error;
  }
#line 628
  tmp___5 = send(sock, (void const   *)((char const   *)(& Options.special_wanted)),
                 sizeof(int ), 0);
#line 628
  if (tmp___5 < (int )sizeof(int )) {
    goto error;
  }
#line 629
  tmp___6 = recv(sock, (void *)((char *)(& their_data)), sizeof(int ), 0);
#line 629
  if (tmp___6 < (int )sizeof(int )) {
    goto error;
  }
#line 630
  if (their_data != Options.special_wanted) {
#line 631
    sprintf((char * __restrict  )(message), (char const   * __restrict  )"You must both agree on whether to use Power Pieces");
    goto known_error;
  }
#line 635
  tmp___7 = send(sock, (void const   *)((char const   *)(& Options.faster_levels)),
                 sizeof(int ), 0);
#line 635
  if (tmp___7 < (int )sizeof(int )) {
    goto error;
  }
#line 636
  tmp___8 = recv(sock, (void *)((char *)(& their_data)), sizeof(int ), 0);
#line 636
  if (tmp___8 < (int )sizeof(int )) {
    goto error;
  }
#line 637
  if (their_data != Options.special_wanted) {
#line 638
    sprintf((char * __restrict  )(message), (char const   * __restrict  )"You must both agree on Double Difficulty");
    goto known_error;
  }
#line 643
  tmp___9 = send(sock, (void const   *)((char const   *)(level)), sizeof(level[0]),
                 0);
#line 643
  if (tmp___9 < (int )sizeof(level[0])) {
    goto error;
  }
#line 644
  tmp___10 = send(sock, (void const   *)((char const   *)(& cs.choice)), sizeof(cs.choice),
                  0);
#line 644
  if (tmp___10 < (int )sizeof(cs.choice)) {
    goto error;
  }
#line 645
  tmp___11 = strlen((char const   *)p->name);
#line 645
  match = (int )tmp___11;
#line 646
  tmp___12 = send(sock, (void const   *)((char const   *)(& match)), sizeof(match),
                  0);
#line 646
  if (tmp___12 < (int )sizeof(match)) {
    goto error;
  }
#line 647
  tmp___13 = strlen((char const   *)p->name);
#line 647
  tmp___14 = send(sock, (void const   *)((char const   *)p->name), tmp___13, 0);
#line 647
  tmp___15 = strlen((char const   *)p->name);
#line 647
  if (tmp___14 < (int )tmp___15) {
    goto error;
  }
#line 649
  tmp___16 = recv(sock, (void *)((char *)(& level[1])), sizeof(level[1]), 0);
#line 649
  if (tmp___16 < (int )sizeof(level[1])) {
    goto error;
  }
#line 650
  if (! (sizeof(their_cs_choice) == sizeof(cs.choice))) {
#line 650
    Panic("play_NETWORK", "atris.c", (char *)"Failed assertion \"%s\" on line %d",
          "sizeof(their_cs_choice) == sizeof(cs.choice)", 650);
  }
#line 651
  tmp___17 = recv(sock, (void *)((char *)(& their_cs_choice)), sizeof(cs.choice),
                  0);
#line 651
  if (tmp___17 < (int )sizeof(cs.choice)) {
    goto error;
  }
#line 652
  if (their_cs_choice < 0) {
#line 653
    their_cs_choice = cs.choice;
  } else {
#line 652
    if (their_cs_choice >= cs.num_style) {
#line 653
      their_cs_choice = cs.choice;
    }
  }
#line 655
  tmp___18 = recv(sock, (void *)((char *)(& match)), sizeof(match), 0);
#line 655
  if (tmp___18 < (int )sizeof(match)) {
    goto error;
  }
#line 656
  tmp___19 = calloc((unsigned int )match, 1U);
#line 656
  their_name = (char *)tmp___19;
#line 656
  if (! their_name) {
#line 656
    Panic("play_NETWORK", "atris.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for their_name",
          match);
  }
#line 657
  tmp___20 = recv(sock, (void *)their_name, (unsigned int )match, 0);
#line 657
  if (tmp___20 < match) {
    goto error;
  }
#line 659
  my_adj[2] = -1;
#line 659
  my_adj[1] = my_adj[2];
#line 659
  my_adj[0] = my_adj[1];
#line 660
  their_adj[2] = -1;
#line 660
  their_adj[1] = their_adj[2];
#line 660
  their_adj[0] = their_adj[1];
#line 661
  match = 0;
#line 664
  while (! done) {
#line 666
    if (server) {
#line 667
      time(& our_time);
#line 668
      tmp___21 = send(sock, (void const   *)((char const   *)(& our_time)), sizeof(our_time),
                      0);
#line 668
      if (tmp___21 < (int )sizeof(our_time)) {
        goto error;
      }
    } else {
#line 670
      tmp___22 = recv(sock, (void *)((char *)(& our_time)), sizeof(our_time), 0);
#line 670
      if (tmp___22 < (int )sizeof(our_time)) {
        goto error;
      }
    }
#line 673
    SeedRandom((unsigned int )our_time);
#line 674
    *(g___0 + 0) = generate_board(10, 20, level[0]);
#line 675
    SeedRandom((unsigned int )our_time);
#line 676
    *(g___0 + 1) = generate_board(10, 20, level[1]);
#line 677
    SeedRandom((unsigned int )our_time);
#line 679
    event_name[0] = p->name;
#line 680
    event_name[1] = their_name;
#line 683
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, their_adj,
                    event_name);
#line 687
    curtimeleft = 120;
#line 689
    event_cs[0] = *(cs.style + cs.choice);
#line 690
    event_cs[1] = *(cs.style + their_cs_choice);
#line 691
    event_ss[1] = *(ss.style + ss.choice);
#line 691
    event_ss[0] = event_ss[1];
#line 693
    event_loop(screen, *(ps.style + ps.choice), (color_style **)(event_cs), (sound_style **)(event_ss),
               (Grid *)g___0, (int *)(level), sock, & curtimeleft, 0, adjustment,
               (int (*)(SDL_Event const   * ))((void *)0), (int )our_time, 1, 3, (AI_Player **)((void *)0));
#line 697
    tmp___23 = send(sock, (void const   *)((char const   *)(Score)), sizeof(Score[0]),
                    0);
#line 697
    if (tmp___23 < (int )sizeof(Score[0])) {
      goto error;
    }
#line 698
    tmp___24 = recv(sock, (void *)((char *)(& Score[1])), sizeof(Score[1]), 0);
#line 698
    if (tmp___24 < (int )sizeof(Score[1])) {
      goto error;
    }
#line 699
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, their_adj,
                    event_name);
#line 701
    draw_score(screen, 0);
#line 702
    draw_score(screen, 1);
#line 703
    SDL_Delay(1000U);
#line 704
    my_adj[match] = adjustment[0];
#line 705
    their_adj[match] = adjustment[1];
#line 706
    match = level_adjust((int *)(my_adj), (int *)(their_adj), (int *)(level), match);
#line 709
    if (server) {
#line 710
      msg = 305419896U;
#line 711
      tmp___25 = send(sock, (void const   *)((char const   *)(& msg)), sizeof(msg),
                      0);
#line 711
      if (tmp___25 < (int )sizeof(msg)) {
        goto error;
      }
#line 712
      tmp___26 = recv(sock, (void *)((char *)(& msg)), sizeof(msg), 0);
#line 712
      if (tmp___26 < (int )sizeof(msg)) {
        goto error;
      }
#line 713
      if (msg != 2557891634U) {
#line 714
        give_notice((char *)"Network Error: Syncronization Failed", 0);
        goto done;
      }
    } else {
#line 719
      tmp___27 = recv(sock, (void *)((char *)(& msg___0)), sizeof(msg___0), 0);
#line 719
      if (tmp___27 < (int )sizeof(msg___0)) {
        goto error;
      }
#line 720
      if (msg___0 != 305419896U) {
#line 721
        give_notice((char *)"Network Error: Syncronization Failed", 1);
        goto done;
      }
#line 724
      msg___0 = 2557891634U;
#line 725
      tmp___28 = send(sock, (void const   *)((char const   *)(& msg___0)), sizeof(msg___0),
                      0);
#line 725
      if (tmp___28 < (int )sizeof(msg___0)) {
        goto error;
      }
    }
#line 731
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, their_adj,
                    event_name);
#line 733
    draw_score(screen, 0);
#line 734
    draw_score(screen, 1);
#line 735
    if (server) {
#line 736
      done = give_notice((char *)((void *)0), 1);
#line 737
      tmp___29 = send(sock, (void const   *)((char const   *)(& done)), sizeof(done),
                      0);
#line 737
      if (tmp___29 < (int )sizeof(done)) {
        goto error;
      }
    } else {
#line 740
      draw_string((char *)"Waiting for the", color_blue, 0, 0, ((1 | (1 << 1)) | (1 << 3)) | (1 << 7));
#line 742
      draw_string((char *)"Server to go on.", color_blue, 0, 0, (1 | (1 << 3)) | (1 << 7));
#line 744
      tmp___30 = recv(sock, (void *)((char *)(& done)), sizeof(done), 0);
#line 744
      if (tmp___30 < (int )sizeof(done)) {
        goto error;
      }
#line 745
      while (1) {
#line 745
        tmp___31 = SDL_PollEvent(& event___1);
#line 745
        if (! tmp___31) {
#line 745
          break;
        }
      }
    }
#line 748
    clear_screen_to_flame();
  }
#line 750
  close(sock);
#line 751
  return (level[0]);
  error: 
#line 755
  if (error_msg) {
#line 756
    sprintf((char * __restrict  )(message), (char const   * __restrict  )"Network Error: %s",
            error_msg);
  } else {
#line 758
    tmp___32 = __errno_location();
#line 758
    tmp___33 = strerror(*tmp___32);
#line 758
    sprintf((char * __restrict  )(message), (char const   * __restrict  )"Network Error: %s",
            tmp___33);
  }
  known_error: 
#line 760
  clear_screen_to_flame();
#line 761
  give_notice(message, 0);
  done: 
#line 763
  close(sock);
#line 764
  return (level[0]);
}
}
#line 772 "atris.c"
static int play_MARATHON(color_styles cs , piece_styles ps , sound_styles ss , Grid *g___0 ,
                         person *p ) 
{ int curtimeleft ;
  int level[2] ;
  int adjustment[2] ;
  int my_adj[3] ;
  char message[1024] ;
  int result ;
  time_t tmp ;
  int tmp___0 ;

  {
#line 778
  adjustment[0] = -1;
#line 778
  adjustment[1] = -1;
#line 783
  level[0] = p->level;
#line 784
  SeedRandom(0U);
#line 785
  Score[0] = 0;
#line 787
  my_adj[0] = -1;
#line 787
  my_adj[1] = -1;
#line 787
  my_adj[2] = -1;
#line 788
  while (1) {
#line 791
    curtimeleft = 300;
#line 793
    *(g___0 + 0) = generate_board(10, 20, level[0]);
#line 796
    event_name[0] = p->name;
#line 798
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, (int *)((void *)0),
                    event_name);
#line 802
    event_cs[1] = *(cs.style + cs.choice);
#line 802
    event_cs[0] = event_cs[1];
#line 803
    event_ss[1] = *(ss.style + ss.choice);
#line 803
    event_ss[0] = event_ss[1];
#line 805
    tmp = time((time_t *)((void *)0));
#line 805
    result = event_loop(screen, *(ps.style + ps.choice), (color_style **)(event_cs),
                        (sound_style **)(event_ss), (Grid *)g___0, (int *)(level),
                        0, & curtimeleft, 1, adjustment, (int (*)(SDL_Event const   * ))((void *)0),
                        (int )tmp, 1, 0, (AI_Player **)((void *)0));
#line 809
    if (result < 0) {
#line 810
      return (level[0]);
    }
#line 813
    my_adj[0] = adjustment[0];
#line 815
    draw_background(screen, (*(cs.style + 0))->w, (Grid *)g___0, level, my_adj, (int *)((void *)0),
                    event_name);
#line 817
    draw_score(screen, 0);
#line 818
    if (adjustment[0] != 0) {
#line 819
      give_notice((char *)"Game Over!", 0);
#line 820
      return (level[0]);
    }
#line 822
    my_adj[0] = -1;
#line 823
    (level[0]) ++;
#line 824
    sprintf((char * __restrict  )(message), (char const   * __restrict  )"Up to Level %d!",
            level[0]);
#line 825
    tmp___0 = give_notice(message, 1);
#line 825
    if (tmp___0) {
#line 826
      return (level[0]);
    }
  }
}
}
#line 836 "atris.c"
static int play_SINGLE(color_styles cs , piece_styles ps , sound_styles ss , Grid *g___0 ,
                       person *p ) 
{ int curtimeleft ;
  int match ;
  int level[2] ;
  int adjustment[2] ;
  int my_adj[3] ;
  char message[1024] ;
  int result ;
  time_t tmp ;
  int tmp___0 ;

  {
#line 843
  adjustment[0] = -1;
#line 843
  adjustment[1] = -1;
#line 848
  level[0] = p->level;
#line 849
  SeedRandom(0U);
#line 850
  Score[0] = 0;
#line 852
  while (1) {
#line 855
    curtimeleft = 300;
#line 856
    my_adj[0] = -1;
#line 856
    my_adj[1] = -1;
#line 856
    my_adj[2] = -1;
#line 858
    match = 0;
#line 858
    while (1) {
#line 858
      if (match < 3) {
#line 858
        if (! (curtimeleft > 0)) {
#line 858
          break;
        }
      } else {
#line 858
        break;
      }
#line 860
      *(g___0 + 0) = generate_board(10, 20, level[0]);
#line 862
      event_name[0] = p->name;
#line 865
      draw_background(screen, (*(cs.style + 0))->w, g___0, level, my_adj, (int *)((void *)0),
                      event_name);
#line 869
      event_cs[1] = *(cs.style + cs.choice);
#line 869
      event_cs[0] = event_cs[1];
#line 870
      event_ss[1] = *(ss.style + ss.choice);
#line 870
      event_ss[0] = event_ss[1];
#line 872
      tmp = time((time_t *)((void *)0));
#line 872
      result = event_loop(screen, *(ps.style + ps.choice), (color_style **)(event_cs),
                          (sound_style **)(event_ss), g___0, (int *)(level), 0, & curtimeleft,
                          1, adjustment, (int (*)(SDL_Event const   * ))((void *)0),
                          (int )tmp, 1, 0, (AI_Player **)((void *)0));
#line 876
      if (result < 0) {
#line 877
        return (level[0]);
      }
#line 880
      my_adj[match] = adjustment[0];
#line 882
      draw_background(screen, (*(cs.style + 0))->w, g___0, level, my_adj, (int *)((void *)0),
                      event_name);
#line 884
      draw_score(screen, 0);
#line 885
      message[0] = (char)0;
#line 886
      if (match == 2) {
#line 887
        if (my_adj[0] == 0) {
#line 887
          if (my_adj[1] == 0) {
#line 887
            if (my_adj[2] == 0) {
#line 889
              (level[0]) ++;
#line 890
              sprintf((char * __restrict  )(message), (char const   * __restrict  )"Up to level %d!",
                      level[0]);
            } else {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 892
          if (my_adj[0] == 2) {
#line 892
            if (my_adj[1] == 2) {
#line 892
              if (my_adj[2] == 2) {
#line 894
                (level[0]) --;
#line 895
                sprintf((char * __restrict  )(message), (char const   * __restrict  )"Down to level %d!",
                        level[0]);
              }
            }
          }
        }
      }
#line 898
      tmp___0 = give_notice(message, 1);
#line 898
      if (tmp___0 == 1) {
#line 899
        return (level[0]);
      }
#line 858
      match ++;
    }
  }
}
}
#line 909 "atris.c"
int main(int argc , char **argv ) 
{ color_styles cs ;
  piece_styles ps ;
  sound_styles ss ;
  identity *id ;
  AI_Players *ai ;
  Grid g___0[2] ;
  int renderstyle ;
  int flags___0 ;
  Uint32 time_now ;
  SDL_Event event ;
  char filespec[2048] ;
  char *tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___2 ;
  int tmp___3 ;
  TTF_Font __attribute__((__visibility__("default")))  *tmp___4 ;
  TTF_Font __attribute__((__visibility__("default")))  *tmp___5 ;
  TTF_Font __attribute__((__visibility__("default")))  *tmp___6 ;
  TTF_Font __attribute__((__visibility__("default")))  *tmp___7 ;
  int __attribute__((__visibility__("default")))  tmp___8 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___9 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___10 ;
  int p1 ;
  int p2 ;
  int retval ;
  char *tmp___11 ;
  char filespec___0[2048] ;
  char *tmp___12 ;

  {
#line 918
  renderstyle = 0;
#line 923
  umask(0U);
#line 924
  printf((char const   * __restrict  )"%-14.14s| ", "main");
#line 924
  printf((char const   * __restrict  )"\tWelcome to Alizarin Tetris (version %s - %s)\n",
         "1.0.6", "Delay");
#line 924
  fflush(stdout);
#line 925
  printf((char const   * __restrict  )"%-14.14s| ", "main");
#line 925
  printf((char const   * __restrict  )"\t~~~~~~~~~~~~~~~~~~~~~~~~~~ (%s)\n", "Aug 19 2008");
#line 925
  fflush(stdout);
#line 932
  tmp = getenv("HOME");
#line 932
  sprintf((char * __restrict  )(filespec), (char const   * __restrict  )"%s/.atrisrc",
          tmp);
#line 933
  load_options(filespec);
#line 936
  parse_options(argc, argv);
#line 938
  tmp___0 = SDL_Init(32U);
#line 938
  if (tmp___0) {
#line 939
    Panic("main", "atris.c", (char *)"SDL_Init failed!");
  }
#line 942
  atexit((void (*)(void))(& SDL_Quit));
#line 944
  tmp___1 = TTF_Init();
#line 944
  if (tmp___1 < (int __attribute__((__visibility__("default")))  )0) {
#line 944
    Panic("main", "atris.c", (char *)"TTF_Init failed!");
  }
#line 944
  atexit((void (*)(void))(& TTF_Quit));
#line 945
  printf((char const   * __restrict  )"%-14.14s| ", "main");
#line 945
  printf((char const   * __restrict  )"SDL initialized.\n");
#line 945
  fflush(stdout);
#line 948
  flags___0 = 805310465;
#line 949
  if (Options.full_screen) {
#line 949
    flags___0 = (int )((unsigned int )flags___0 | 2147483648U);
  }
#line 950
  tmp___2 = SDL_SetVideoMode(640, 480, Options.bpp_wanted, (unsigned int )flags___0);
#line 950
  screen = (SDL_Surface *)tmp___2;
#line 951
  if ((unsigned int )screen == (unsigned int )((void *)0)) {
#line 951
    Panic("main", "atris.c", (char *)"Could not set 640x480 video mode");
  }
#line 952
  printf((char const   * __restrict  )"%-14.14s| ", "main");
#line 952
  printf((char const   * __restrict  )"Video Mode: %d x %d @ %d bpp\n", screen->w,
         screen->h, (screen->format)->BitsPerPixel);
#line 952
  fflush(stdout);
#line 955
  if ((int )(screen->format)->BitsPerPixel <= 8) {
#line 956
    Panic("main", "atris.c", (char *)"You need >256 colors to play atris");
  }
#line 960
  SDL_WM_SetCaption("Alizarin Tetris", (char const   *)((char *)((void *)0)));
#line 962
  Network_Init();
#line 964
  setup_colors(screen);
#line 965
  setup_layers(screen);
#line 967
  tmp___3 = chdir("/usr/local/games/atris");
#line 967
  if (tmp___3) {
#line 968
    printf((char const   * __restrict  )"%-14.14s| ", "main");
#line 968
    printf((char const   * __restrict  )"WARNING: cannot change directory to [%s]\n",
           "/usr/local/games/atris");
#line 968
    fflush(stdout);
#line 969
    printf((char const   * __restrict  )"%-14.14s| ", "main");
#line 969
    printf((char const   * __restrict  )"WARNING: playing in current directory instead\n");
#line 969
    fflush(stdout);
  } else {
#line 971
    printf((char const   * __restrict  )"%-14.14s| ", "main");
#line 971
    printf((char const   * __restrict  )"Changing directory to [%s]\n", "/usr/local/games/atris");
#line 971
    fflush(stdout);
  }
#line 974
  tmp___4 = TTF_OpenFont("graphics/NewMediumNormal.ttf", 18);
#line 974
  sfont = (TTF_Font *)tmp___4;
#line 975
  tmp___5 = TTF_OpenFont("graphics/NewMediumNormal.ttf", 24);
#line 975
  font = (TTF_Font *)tmp___5;
#line 976
  tmp___6 = TTF_OpenFont("graphics/NewMediumNormal.ttf", 36);
#line 976
  lfont = (TTF_Font *)tmp___6;
#line 977
  tmp___7 = TTF_OpenFont("graphics/NewMediumNormal.ttf", 96);
#line 977
  hfont = (TTF_Font *)tmp___7;
#line 978
  if ((unsigned int )font == (unsigned int )((void *)0)) {
#line 978
    Panic("main", "atris.c", (char *)"Couldn\'t open [graphics/NewMediumNormal.ttf].",
          "/usr/local/games/atris");
  }
#line 979
  TTF_SetFontStyle(font, renderstyle);
#line 980
  TTF_SetFontStyle(sfont, renderstyle);
#line 982
  Score[1] = 0;
#line 982
  Score[0] = Score[1];
#line 984
  SDL_EnableUNICODE(1);
#line 986
  ps = load_piece_styles();
#line 987
  cs = load_color_styles(screen);
#line 988
  ss = load_sound_styles(Options.sound_wanted);
#line 990
  if (Options.named_color >= 0) {
#line 990
    if (Options.named_color < cs.num_style) {
#line 991
      cs.choice = Options.named_color;
    }
  }
#line 992
  if (Options.named_piece >= 0) {
#line 992
    if (Options.named_piece < ps.num_style) {
#line 993
      ps.choice = Options.named_piece;
    }
  }
#line 994
  if (Options.named_sound >= 0) {
#line 994
    if (Options.named_sound < ss.num_style) {
#line 995
      ss.choice = Options.named_sound;
    }
  }
#line 996
  if (Options.named_game >= 0) {
#line 996
    if (Options.named_game <= 5) {
#line 997
      gametype = (enum __anonenum_GT_50 )Options.named_game;
    } else {
#line 998
      gametype = 0;
    }
  } else {
#line 998
    gametype = 0;
  }
#line 1000
  ai = AI_Players_Setup();
#line 1001
  id = load_identity_file();
#line 1003
  atris_xflame_setup();
#line 1007
  while (1) {
#line 1007
    tmp___8 = SDL_PollEvent(& event);
#line 1007
    if (! tmp___8) {
#line 1007
      break;
    }
  }
#line 1009
  draw_string((char *)"atris - 1.0.6", color_white, screen->w, 0, (1 << 2) | (1 << 3));
#line 1011
  draw_string((char *)"Welcome To", color_purple, screen->w / 2, screen->h / 2, ((1 | (1 << 3)) | (1 << 1)) | (1 << 6));
#line 1013
  draw_string((char *)"Alizarin Tetris", color_blue, screen->w / 2, screen->h / 2,
              (1 | (1 << 3)) | (1 << 5));
#line 1017
  tmp___9 = SDL_GetTicks();
#line 1017
  time_now = (unsigned int )tmp___9;
#line 1018
  while (1) {
#line 1019
    poll_and_flame(& event);
#line 1018
    tmp___10 = SDL_GetTicks();
#line 1018
    if (! (tmp___10 < (Uint32 __attribute__((__visibility__("default")))  )(time_now + 600U))) {
#line 1018
      break;
    }
  }
#line 1022
  clear_screen_to_flame();
#line 1024
  while (1) {
#line 1028
    SDL_EnableKeyRepeat(5000, 30);
#line 1030
    choose_gametype(& ps, & cs, & ss, ai);
#line 1031
    if ((int )gametype == 6) {
#line 1031
      break;
    } else {
#line 1032
      Options.named_game = (int )gametype;
    }
#line 1035
    Score[1] = 0;
#line 1035
    Score[0] = Score[1];
#line 1036
    SDL_EnableKeyRepeat(5000, 30);
#line 1040
    switch ((int )gametype) {
    case 0: 
#line 1042
    p1 = who_are_you(screen, & id, -1, 1);
#line 1043
    clear_screen_to_flame();
#line 1044
    if (p1 < 0) {
#line 1044
      break;
    }
#line 1045
    (id->p + p1)->level = play_SINGLE(cs, ps, ss, g___0, id->p + p1);
#line 1046
    clear_screen_to_flame();
#line 1047
    break;
    case 1: 
#line 1049
    p1 = who_are_you(screen, & id, -1, 1);
#line 1050
    clear_screen_to_flame();
#line 1051
    if (p1 < 0) {
#line 1051
      break;
    }
#line 1052
    retval = play_MARATHON(cs, ps, ss, (Grid *)(g___0), id->p + p1);
#line 1053
    clear_screen_to_flame();
#line 1055
    SDL_EnableKeyRepeat(5000, 30);
#line 1057
    high_score_check(retval, Score[0]);
#line 1058
    clear_screen_to_flame();
#line 1059
    break;
    case 2: 
#line 1061
    p1 = who_are_you(screen, & id, -1, 1);
#line 1062
    clear_screen_to_flame();
#line 1063
    if (p1 < 0) {
#line 1063
      break;
    }
#line 1064
    p2 = pick_an_ai(screen, (char *)"As Your Opponent", ai);
#line 1065
    if (p2 < 0) {
#line 1065
      break;
    }
#line 1066
    (ai->player + p2)->delay_factor = pick_ai_factor(screen);
#line 1067
    clear_screen_to_flame();
#line 1068
    (id->p + p1)->level = play_SINGLE_VS_AI(cs, ps, ss, (Grid *)(g___0), id->p + p1,
                                            ai->player + p2);
#line 1070
    clear_screen_to_flame();
#line 1071
    break;
    case 5: 
#line 1073
    p1 = pick_an_ai(screen, (char *)"As Player 1", ai);
#line 1074
    clear_screen_to_flame();
#line 1075
    if (p1 < 0) {
#line 1075
      break;
    }
#line 1076
    p2 = pick_an_ai(screen, (char *)"As Player 2", ai);
#line 1077
    clear_screen_to_flame();
#line 1078
    if (p2 < 0) {
#line 1078
      break;
    }
#line 1079
    play_AI_VS_AI(cs, ps, ss, (Grid *)(g___0), ai->player + p1, ai->player + p2);
#line 1081
    clear_screen_to_flame();
#line 1082
    break;
    case 3: 
#line 1084
    p1 = who_are_you(screen, & id, -1, 1);
#line 1085
    clear_screen_to_flame();
#line 1086
    if (p1 < 0) {
#line 1086
      break;
    }
#line 1087
    p2 = who_are_you(screen, & id, p1, 2);
#line 1088
    clear_screen_to_flame();
#line 1089
    if (p2 < 0) {
#line 1089
      break;
    }
#line 1090
    play_TWO_PLAYERS(cs, ps, ss, (Grid *)(g___0), id->p + p1, id->p + p2);
#line 1091
    clear_screen_to_flame();
#line 1092
    break;
    case 4: 
#line 1094
    p1 = who_are_you(screen, & id, -1, 1);
#line 1095
    clear_screen_to_flame();
#line 1096
    if (p1 < 0) {
#line 1096
      break;
    }
#line 1098
    tmp___11 = network_choice(screen);
#line 1098
    (id->p + p1)->level = play_NETWORK(cs, ps, ss, (Grid *)(g___0), id->p + p1, tmp___11);
#line 1100
    clear_screen_to_flame();
#line 1101
    break;
    default: ;
#line 1103
    break;
    }
#line 1109
    save_identity_file(id, (char *)((void *)0), 0);
  }
#line 1111
  SDL_CloseAudio();
#line 1112
  TTF_CloseFont(sfont);
#line 1113
  TTF_CloseFont(font);
#line 1114
  TTF_CloseFont(lfont);
#line 1115
  TTF_CloseFont(hfont);
#line 1116
  Network_Quit();
#line 1118
  Options.named_color = cs.choice;
#line 1119
  Options.named_piece = ps.choice;
#line 1120
  Options.named_sound = ss.choice;
#line 1127
  tmp___12 = getenv("HOME");
#line 1127
  sprintf((char * __restrict  )(filespec___0), (char const   * __restrict  )"%s/.atrisrc",
          tmp___12);
#line 1128
  save_options(filespec___0);
#line 1131
  return (0);
}
}
#line 1 "button.o"
#pragma merger(0,"/tmp/cil-5Y9Zh4f9.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 589 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 356 "/usr/include/SDL/SDL_video.h"
extern void __attribute__((__visibility__("default")))  SDL_UpdateRects(SDL_Surface *screen ,
                                                                        int numrects ,
                                                                        SDL_Rect *rects ) ;
#line 463
extern void __attribute__((__visibility__("default")))  SDL_GetRGB(Uint32 pixel ,
                                                                   SDL_PixelFormat *fmt ,
                                                                   Uint8 *r , Uint8 *g ,
                                                                   Uint8 *b ) ;
#line 698
extern int __attribute__((__visibility__("default")))  SDL_UpperBlit(SDL_Surface *src ,
                                                                     SDL_Rect *srcrect ,
                                                                     SDL_Surface *dst ,
                                                                     SDL_Rect *dstrect ) ;
#line 717
extern int __attribute__((__visibility__("default")))  SDL_FillRect(SDL_Surface *dst ,
                                                                    SDL_Rect *dstrect ,
                                                                    Uint32 color ) ;
#line 191 "/usr/include/SDL/SDL_ttf.h"
extern SDL_Surface __attribute__((__visibility__("default")))  *TTF_RenderText_Blended(TTF_Font *font ,
                                                                                       char const   *text ,
                                                                                       SDL_Color fg ) ;
#line 2 ".protos/button.pro"
ATButton *button(char *text , Uint32 face_color0 , Uint32 text_color0 , Uint32 face_color1 ,
                 Uint32 text_color1 , int x , int y ) ;
#line 5
void show_button(ATButton *ab , int state ) ;
#line 6
char check_button(ATButton *ab , int x , int y ) ;
#line 21 "button.c"
ATButton *button(char *text , Uint32 face_color0 , Uint32 text_color0 , Uint32 face_color1 ,
                 Uint32 text_color1 , int x , int y ) 
{ SDL_Color sc ;
  ATButton *ab ;
  void *tmp ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___0 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___1 ;

  {
#line 26
  tmp = malloc(sizeof(ATButton ));
#line 26
  ab = (ATButton *)tmp;
#line 26
  if (! ab) {
#line 26
    Panic("button", "button.c", (char *)"Failed assertion \"%s\" on line %d", "ab",
          26);
  }
#line 29
  ab->face_color[0] = face_color0;
#line 30
  ab->text_color[0] = text_color0;
#line 31
  ab->face_color[1] = face_color1;
#line 32
  ab->text_color[1] = text_color1;
#line 34
  SDL_GetRGB(text_color0, screen->format, & sc.r, & sc.g, & sc.b);
#line 35
  tmp___0 = TTF_RenderText_Blended(font, (char const   *)text, sc);
#line 35
  ab->bitmap[0] = (SDL_Surface *)tmp___0;
#line 36
  if (! ab->bitmap[0]) {
#line 36
    Panic("button", "button.c", (char *)"Failed assertion \"%s\" on line %d", "ab->bitmap[0]",
          36);
  }
#line 37
  SDL_GetRGB(text_color1, screen->format, & sc.r, & sc.g, & sc.b);
#line 38
  tmp___1 = TTF_RenderText_Blended(font, (char const   *)text, sc);
#line 38
  ab->bitmap[1] = (SDL_Surface *)tmp___1;
#line 39
  if (! ab->bitmap[1]) {
#line 39
    Panic("button", "button.c", (char *)"Failed assertion \"%s\" on line %d", "ab->bitmap[1]",
          39);
  }
#line 41
  ab->area.x = (short )x;
#line 41
  ab->area.y = (short )y;
#line 42
  ab->area.w = (unsigned short )((ab->bitmap[0])->w + 10);
#line 43
  ab->area.h = (unsigned short )((ab->bitmap[0])->h + 10);
#line 44
  return (ab);
}
}
#line 51 "button.c"
void show_button(ATButton *ab , int state ) 
{ SDL_Rect *my_c ;
  SDL_Rect *my_c___0 ;
  SDL_Rect *my_c___1 ;

  {
#line 53
  SDL_FillRect(screen, & ab->area, ab->text_color[state]);
#line 54
  my_c = & ab->area;
#line 54
  if (! my_c) {
#line 54
    Panic("show_button", "button.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 54);
  }
#line 54
  if (my_c) {
#line 54
    if ((int )my_c->x < 0) {
#line 54
      my_c->x = (short)0;
    }
#line 54
    if ((int )my_c->y < 0) {
#line 54
      my_c->y = (short)0;
    }
#line 54
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 54
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 54
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 54
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 54
  SDL_UpdateRects(screen, 1, & ab->area);
#line 55
  ab->area.x = (short )((int )ab->area.x + 2);
#line 55
  ab->area.y = (short )((int )ab->area.y + 2);
#line 56
  ab->area.w = (unsigned short )((int )ab->area.w - 4);
#line 56
  ab->area.h = (unsigned short )((int )ab->area.h - 4);
#line 57
  SDL_FillRect(screen, & ab->area, ab->face_color[state]);
#line 58
  my_c___0 = & ab->area;
#line 58
  if (! my_c___0) {
#line 58
    Panic("show_button", "button.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 58);
  }
#line 58
  if (my_c___0) {
#line 58
    if ((int )my_c___0->x < 0) {
#line 58
      my_c___0->x = (short)0;
    }
#line 58
    if ((int )my_c___0->y < 0) {
#line 58
      my_c___0->y = (short)0;
    }
#line 58
    if ((int )my_c___0->x + (int )my_c___0->w > 640) {
#line 58
      my_c___0->w = (unsigned short )(640 - (int )my_c___0->x);
    }
#line 58
    if ((int )my_c___0->y + (int )my_c___0->h > 480) {
#line 58
      my_c___0->h = (unsigned short )(480 - (int )my_c___0->y);
    }
  }
#line 58
  SDL_UpdateRects(screen, 1, & ab->area);
#line 59
  ab->area.x = (short )((int )ab->area.x + 3);
#line 59
  ab->area.y = (short )((int )ab->area.y + 3);
#line 60
  ab->area.w = (unsigned short )((int )ab->area.w - 6);
#line 60
  ab->area.h = (unsigned short )((int )ab->area.h - 6);
#line 61
  SDL_UpperBlit(ab->bitmap[state], (SDL_Rect *)((void *)0), screen, & ab->area);
#line 63
  ab->area.x = (short )((int )ab->area.x - 5);
#line 63
  ab->area.y = (short )((int )ab->area.y - 5);
#line 64
  ab->area.w = (unsigned short )((int )ab->area.w + 10);
#line 64
  ab->area.h = (unsigned short )((int )ab->area.h + 10);
#line 65
  my_c___1 = & ab->area;
#line 65
  if (! my_c___1) {
#line 65
    Panic("show_button", "button.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 65);
  }
#line 65
  if (my_c___1) {
#line 65
    if ((int )my_c___1->x < 0) {
#line 65
      my_c___1->x = (short)0;
    }
#line 65
    if ((int )my_c___1->y < 0) {
#line 65
      my_c___1->y = (short)0;
    }
#line 65
    if ((int )my_c___1->x + (int )my_c___1->w > 640) {
#line 65
      my_c___1->w = (unsigned short )(640 - (int )my_c___1->x);
    }
#line 65
    if ((int )my_c___1->y + (int )my_c___1->h > 480) {
#line 65
      my_c___1->h = (unsigned short )(480 - (int )my_c___1->y);
    }
  }
#line 65
  SDL_UpdateRects(screen, 1, & ab->area);
#line 66
  return;
}
}
#line 73 "button.c"
char check_button(ATButton *ab , int x , int y ) 
{ 

  {
#line 75
  if ((int )ab->area.x <= x) {
#line 75
    if (x <= (int )ab->area.x + (int )ab->area.w) {
#line 75
      if ((int )ab->area.y <= y) {
#line 75
        if (y <= (int )ab->area.y + (int )ab->area.h) {
#line 77
          return ((char)1);
        } else {
#line 78
          return ((char)0);
        }
      } else {
#line 78
        return ((char)0);
      }
    } else {
#line 78
      return ((char)0);
    }
  } else {
#line 78
    return ((char)0);
  }
}
}
#line 1 "display.o"
#pragma merger(0,"/tmp/cil-KxZiCfac.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 97 "/usr/include/SDL/SDL_rwops.h"
extern SDL_RWops __attribute__((__visibility__("default")))  *SDL_RWFromFile(char const   *file ,
                                                                             char const   *mode ) ;
#line 423 "/usr/include/SDL/SDL_video.h"
extern int __attribute__((__visibility__("default")))  SDL_SetColors(SDL_Surface *surface ,
                                                                     SDL_Color *colors ,
                                                                     int firstcolor ,
                                                                     int ncolors ) ;
#line 449
extern Uint32 __attribute__((__visibility__("default")))  SDL_MapRGB(SDL_PixelFormat const   *format ,
                                                                     Uint8 r , Uint8 g ,
                                                                     Uint8 b ) ;
#line 507
extern SDL_Surface __attribute__((__visibility__("default")))  *SDL_CreateRGBSurface(Uint32 flags ,
                                                                                     int width ,
                                                                                     int height ,
                                                                                     int depth ,
                                                                                     Uint32 Rmask ,
                                                                                     Uint32 Gmask ,
                                                                                     Uint32 Bmask ,
                                                                                     Uint32 Amask ) ;
#line 513
extern void __attribute__((__visibility__("default")))  SDL_FreeSurface(SDL_Surface *surface ) ;
#line 542
extern SDL_Surface __attribute__((__visibility__("default")))  *SDL_LoadBMP_RW(SDL_RWops *src ,
                                                                               int freesrc ) ;
#line 568
extern int __attribute__((__visibility__("default")))  SDL_SetColorKey(SDL_Surface *surface ,
                                                                       Uint32 flag ,
                                                                       Uint32 key ) ;
#line 731
extern SDL_Surface __attribute__((__visibility__("default")))  *SDL_DisplayFormat(SDL_Surface *surface ) ;
#line 8 ".protos/piece.pro"
void draw_play_piece(SDL_Surface *screen___0 , color_style *cs , play_piece *o_pp ,
                     int o_x , int o_y , int o_rot , play_piece *pp , int x , int y ,
                     int rot ) ;
#line 2 ".protos/xflame.pro"
void atris_run_flame(void) ;
#line 17 "display.c"
struct layout_struct layout  ;
#line 40 "display.c"
SDL_Surface *adjust_symbol[3]  = {      (SDL_Surface *)((void *)0),      (SDL_Surface *)((void *)0),      (SDL_Surface *)((void *)0)};
#line 43 "display.c"
int Score[2]  ;
#line 49 "display.c"
void poll_and_flame(SDL_Event *ev ) 
{ int __attribute__((__visibility__("default")))  tmp ;

  {
#line 52
  while (1) {
#line 52
    tmp = SDL_PollEvent(ev);
#line 52
    if (tmp) {
#line 52
      break;
    }
#line 53
    atris_run_flame();
  }
#line 55
  return;
}
}
#line 62 "display.c"
void clear_screen_to_flame(void) 
{ SDL_Rect all ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  SDL_Rect *my_c ;

  {
#line 67
  all.y = (short)0;
#line 67
  all.x = all.y;
#line 68
  all.w = (unsigned short )screen->w;
#line 69
  all.h = (unsigned short )screen->h;
#line 71
  SDL_FillRect(widget_layer, & all, int_black);
#line 72
  SDL_FillRect(screen, & all, int_black);
#line 73
  my_b = (SDL_Rect *)((void *)0);
#line 73
  my_d = (SDL_Rect *)((void *)0);
#line 73
  if (my_b) {
#line 73
    if ((int )my_b->x < 0) {
#line 73
      my_b->x = (short)0;
    }
#line 73
    if ((int )my_b->y < 0) {
#line 73
      my_b->y = (short)0;
    }
#line 73
    if ((int )my_b->x + (int )my_b->w > 640) {
#line 73
      my_b->w = (unsigned short )(640 - (int )my_b->x);
    }
#line 73
    if ((int )my_b->y + (int )my_b->h > 480) {
#line 73
      my_b->h = (unsigned short )(480 - (int )my_b->y);
    }
  }
#line 73
  if (my_d) {
#line 73
    if ((int )my_d->x < 0) {
#line 73
      my_d->x = (short)0;
    }
#line 73
    if ((int )my_d->y < 0) {
#line 73
      my_d->y = (short)0;
    }
#line 73
    if ((int )my_d->x + (int )my_d->w > 640) {
#line 73
      my_d->w = (unsigned short )(640 - (int )my_d->x);
    }
#line 73
    if ((int )my_d->y + (int )my_d->h > 480) {
#line 73
      my_d->h = (unsigned short )(480 - (int )my_d->y);
    }
  }
#line 73
  tmp = SDL_UpperBlit(flame_layer, my_b, screen, my_d);
#line 73
  if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 73
    Panic("clear_screen_to_flame", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(flame_layer,my_b,screen,my_d) == 0", 73);
  }
#line 74
  my_c = & all;
#line 74
  if (! my_c) {
#line 74
    Panic("clear_screen_to_flame", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 74);
  }
#line 74
  if (my_c) {
#line 74
    if ((int )my_c->x < 0) {
#line 74
      my_c->x = (short)0;
    }
#line 74
    if ((int )my_c->y < 0) {
#line 74
      my_c->y = (short)0;
    }
#line 74
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 74
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 74
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 74
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 74
  SDL_UpdateRects(screen, 1, & all);
#line 75
  return;
}
}
#line 81 "display.c"
void setup_colors(SDL_Surface *screen___0 ) 
{ int i ;
  Uint32 __attribute__((__visibility__("default")))  tmp ;
  Uint32 __attribute__((__visibility__("default")))  tmp___0 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___1 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___2 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___3 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___4 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___5 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___6 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___7 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___8 ;

  {
#line 84
  i = 0;
#line 86
  color_white.b = (unsigned char)255;
#line 86
  color_white.g = color_white.b;
#line 86
  color_white.r = color_white.g;
#line 87
  color_white.unused = (unsigned char)0;
#line 89
  color_black.unused = (unsigned char)0;
#line 89
  color_black.b = color_black.unused;
#line 89
  color_black.g = color_black.b;
#line 89
  color_black.r = color_black.g;
#line 91
  color_red.r = (unsigned char)255;
#line 91
  color_red.unused = (unsigned char)0;
#line 91
  color_red.b = color_red.unused;
#line 91
  color_red.g = color_red.b;
#line 93
  color_blue.b = (unsigned char)255;
#line 93
  color_blue.unused = (unsigned char)0;
#line 93
  color_blue.g = color_blue.unused;
#line 93
  color_blue.r = color_blue.g;
#line 95
  color_purple.b = (unsigned char)128;
#line 95
  color_purple.r = (unsigned char)128;
#line 95
  color_purple.g = (unsigned char)64;
#line 96
  color_purple.unused = (unsigned char)0;
#line 98
  tmp = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)0,
                   (unsigned char)0, (unsigned char)0);
#line 98
  int_black = (unsigned int )tmp;
#line 101
  while (1) {
#line 102
    i ++;
#line 103
    tmp___0 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char )i,
                         (unsigned char )i, (unsigned char )i);
#line 103
    int_solid_black = (unsigned int )tmp___0;
#line 101
    if (int_black == int_solid_black) {
#line 101
      if (! (i < 255)) {
#line 101
        break;
      }
    } else {
#line 101
      break;
    }
  }
#line 106
  if (i == 255) {
#line 107
    printf((char const   * __restrict  )"%-14.14s| ", "setup_colors");
#line 107
    printf((char const   * __restrict  )"*** Warning: transparency is compromised by RGB format.\n");
#line 107
    fflush(stdout);
#line 108
    tmp___1 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)1,
                         (unsigned char)1, (unsigned char)1);
#line 108
    int_solid_black = (unsigned int )tmp___1;
  } else {
#line 109
    if (i != 1) {
#line 110
      printf((char const   * __restrict  )"%-14.14s| ", "setup_colors");
#line 110
      printf((char const   * __restrict  )"*** Note: First non-black color found at magnitude %d.\n",
             i);
#line 110
      fflush(stdout);
    }
  }
#line 112
  tmp___2 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)255,
                       (unsigned char)255, (unsigned char)255);
#line 112
  int_white = (unsigned int )tmp___2;
#line 113
  tmp___3 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)128,
                       (unsigned char)128, (unsigned char)128);
#line 113
  int_grey = (unsigned int )tmp___3;
#line 114
  tmp___4 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)255);
#line 114
  int_blue = (unsigned int )tmp___4;
#line 115
  tmp___5 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0);
#line 115
  int_med_blue = (unsigned int )tmp___5;
#line 116
  tmp___6 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)128);
#line 116
  int_dark_blue = (unsigned int )tmp___6;
#line 117
  tmp___7 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)128,
                       (unsigned char)64, (unsigned char)128);
#line 117
  int_purple = (unsigned int )tmp___7;
#line 118
  tmp___8 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)64,
                       (unsigned char)32, (unsigned char)64);
#line 118
  int_dark_purple = (unsigned int )tmp___8;
#line 119
  return;
}
}
#line 133 "display.c"
int draw_string(char *text , SDL_Color sc , int x , int y , int flags___0 ) 
{ SDL_Surface *text_surface ;
  SDL_Rect r ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___0 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___1 ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  SDL_Rect *my_b___1 ;
  SDL_Rect *my_d___1 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  SDL_Rect *my_c ;

  {
#line 139
  if (flags___0 & (1 << 7)) {
#line 140
    r.x = (short )((int )layout.grid[0].x + (int )layout.grid[0].w / 2);
#line 141
    r.y = (short )((int )layout.grid[0].y + (int )layout.grid[0].h / 2);
  } else {
#line 143
    r.x = (short )x;
#line 144
    r.y = (short )y;
  }
#line 147
  if (flags___0 & (1 << 5)) {
#line 148
    tmp = TTF_RenderText_Blended(hfont, (char const   *)text, sc);
#line 148
    text_surface = (SDL_Surface *)tmp;
#line 148
    if (! text_surface) {
#line 148
      Panic("draw_string", "display.c", (char *)"Failed assertion \"%s\" on line %d",
            "text_surface", 148);
    }
  } else {
#line 149
    if (flags___0 & (1 << 6)) {
#line 150
      tmp___0 = TTF_RenderText_Blended(lfont, (char const   *)text, sc);
#line 150
      text_surface = (SDL_Surface *)tmp___0;
#line 150
      if (! text_surface) {
#line 150
        Panic("draw_string", "display.c", (char *)"Failed assertion \"%s\" on line %d",
              "text_surface", 150);
      }
    } else {
#line 152
      tmp___1 = TTF_RenderText_Blended(font, (char const   *)text, sc);
#line 152
      text_surface = (SDL_Surface *)tmp___1;
#line 152
      if (! text_surface) {
#line 152
        Panic("draw_string", "display.c", (char *)"Failed assertion \"%s\" on line %d",
              "text_surface", 152);
      }
    }
  }
#line 155
  r.w = (unsigned short )text_surface->w;
#line 156
  r.h = (unsigned short )text_surface->h;
#line 158
  if (flags___0 & 1) {
#line 159
    r.x = (short )((int )r.x - (int )r.w / 2);
  }
#line 160
  if (flags___0 & (1 << 2)) {
#line 161
    r.x = (short )((int )r.x - text_surface->w);
  }
#line 162
  if (flags___0 & (1 << 1)) {
#line 163
    r.y = (short )((int )r.y - (int )r.h);
  }
#line 164
  if (flags___0 & (1 << 4)) {
#line 165
    SDL_FillRect(widget_layer, & r, int_black);
#line 166
    SDL_FillRect(screen, & r, int_black);
  }
#line 169
  my_b = (SDL_Rect *)((void *)0);
#line 169
  my_d = & r;
#line 169
  if (my_b) {
#line 169
    if ((int )my_b->x < 0) {
#line 169
      my_b->x = (short)0;
    }
#line 169
    if ((int )my_b->y < 0) {
#line 169
      my_b->y = (short)0;
    }
#line 169
    if ((int )my_b->x + (int )my_b->w > 640) {
#line 169
      my_b->w = (unsigned short )(640 - (int )my_b->x);
    }
#line 169
    if ((int )my_b->y + (int )my_b->h > 480) {
#line 169
      my_b->h = (unsigned short )(480 - (int )my_b->y);
    }
  }
#line 169
  if (my_d) {
#line 169
    if ((int )my_d->x < 0) {
#line 169
      my_d->x = (short)0;
    }
#line 169
    if ((int )my_d->y < 0) {
#line 169
      my_d->y = (short)0;
    }
#line 169
    if ((int )my_d->x + (int )my_d->w > 640) {
#line 169
      my_d->w = (unsigned short )(640 - (int )my_d->x);
    }
#line 169
    if ((int )my_d->y + (int )my_d->h > 480) {
#line 169
      my_d->h = (unsigned short )(480 - (int )my_d->y);
    }
  }
#line 169
  tmp___2 = SDL_UpperBlit(text_surface, my_b, widget_layer, my_d);
#line 169
  if (! (tmp___2 == (int __attribute__((__visibility__("default")))  )0)) {
#line 169
    Panic("draw_string", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(text_surface,my_b,widget_layer,my_d) == 0", 169);
  }
#line 170
  my_b___0 = & r;
#line 170
  my_d___0 = & r;
#line 170
  if (my_b___0) {
#line 170
    if ((int )my_b___0->x < 0) {
#line 170
      my_b___0->x = (short)0;
    }
#line 170
    if ((int )my_b___0->y < 0) {
#line 170
      my_b___0->y = (short)0;
    }
#line 170
    if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 170
      my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
    }
#line 170
    if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 170
      my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
    }
  }
#line 170
  if (my_d___0) {
#line 170
    if ((int )my_d___0->x < 0) {
#line 170
      my_d___0->x = (short)0;
    }
#line 170
    if ((int )my_d___0->y < 0) {
#line 170
      my_d___0->y = (short)0;
    }
#line 170
    if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 170
      my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
    }
#line 170
    if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 170
      my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
    }
  }
#line 170
  tmp___3 = SDL_UpperBlit(flame_layer, my_b___0, screen, my_d___0);
#line 170
  if (! (tmp___3 == (int __attribute__((__visibility__("default")))  )0)) {
#line 170
    Panic("draw_string", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(flame_layer,my_b,screen,my_d) == 0", 170);
  }
#line 171
  my_b___1 = & r;
#line 171
  my_d___1 = & r;
#line 171
  if (my_b___1) {
#line 171
    if ((int )my_b___1->x < 0) {
#line 171
      my_b___1->x = (short)0;
    }
#line 171
    if ((int )my_b___1->y < 0) {
#line 171
      my_b___1->y = (short)0;
    }
#line 171
    if ((int )my_b___1->x + (int )my_b___1->w > 640) {
#line 171
      my_b___1->w = (unsigned short )(640 - (int )my_b___1->x);
    }
#line 171
    if ((int )my_b___1->y + (int )my_b___1->h > 480) {
#line 171
      my_b___1->h = (unsigned short )(480 - (int )my_b___1->y);
    }
  }
#line 171
  if (my_d___1) {
#line 171
    if ((int )my_d___1->x < 0) {
#line 171
      my_d___1->x = (short)0;
    }
#line 171
    if ((int )my_d___1->y < 0) {
#line 171
      my_d___1->y = (short)0;
    }
#line 171
    if ((int )my_d___1->x + (int )my_d___1->w > 640) {
#line 171
      my_d___1->w = (unsigned short )(640 - (int )my_d___1->x);
    }
#line 171
    if ((int )my_d___1->y + (int )my_d___1->h > 480) {
#line 171
      my_d___1->h = (unsigned short )(480 - (int )my_d___1->y);
    }
  }
#line 171
  tmp___4 = SDL_UpperBlit(widget_layer, my_b___1, screen, my_d___1);
#line 171
  if (! (tmp___4 == (int __attribute__((__visibility__("default")))  )0)) {
#line 171
    Panic("draw_string", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 171);
  }
#line 172
  if (flags___0 & (1 << 3)) {
#line 173
    my_c = & r;
#line 173
    if (! my_c) {
#line 173
      Panic("draw_string", "display.c", (char *)"Failed assertion \"%s\" on line %d",
            "my_c", 173);
    }
#line 173
    if (my_c) {
#line 173
      if ((int )my_c->x < 0) {
#line 173
        my_c->x = (short)0;
      }
#line 173
      if ((int )my_c->y < 0) {
#line 173
        my_c->y = (short)0;
      }
#line 173
      if ((int )my_c->x + (int )my_c->w > 640) {
#line 173
        my_c->w = (unsigned short )(640 - (int )my_c->x);
      }
#line 173
      if ((int )my_c->y + (int )my_c->h > 480) {
#line 173
        my_c->h = (unsigned short )(480 - (int )my_c->y);
      }
    }
#line 173
    SDL_UpdateRects(screen, 1, & r);
  }
#line 175
  SDL_FreeSurface(text_surface);
#line 176
  return ((int )r.h);
}
}
#line 185 "display.c"
int give_notice(char *s , int quit_possible ) 
{ SDL_Event event ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
#line 190
  while (1) {
#line 190
    tmp = SDL_PollEvent(& event);
#line 190
    if (! tmp) {
#line 190
      break;
    }
  }
#line 194
  if (s) {
#line 194
    if (*(s + 0)) {
#line 195
      draw_string(s, color_blue, (int )layout.grid[0].x + (int )layout.grid[0].w / 2,
                  (int )layout.grid[0].y + 64, 1 | (1 << 3));
    }
  }
#line 199
  if (quit_possible) {
#line 200
    draw_string((char *)"Press \'Q\' to Quit", color_red, (int )layout.grid[0].x + (int )layout.grid[0].w / 2,
                (int )layout.grid[0].y + 128, 1 | (1 << 3));
  }
#line 204
  draw_string((char *)"Press \'G\' to Go On", color_red, (int )layout.grid[0].x + (int )layout.grid[0].w / 2,
              ((int )layout.grid[0].y + 128) + 30, 1 | (1 << 3));
#line 207
  while (1) {
#line 208
    poll_and_flame(& event);
#line 209
    if ((int )event.type == 2) {
#line 209
      if ((int )event.key.keysym.sym == 113) {
#line 211
        return (1);
      }
    }
#line 212
    if ((int )event.type == 2) {
#line 212
      if ((int )event.key.keysym.sym == 103) {
#line 214
        return (0);
      }
    }
  }
}
}
#line 222 "display.c"
static void load_adjust_symbols(void) 
{ SDL_Surface *bitmap ;
  SDL_RWops __attribute__((__visibility__("default")))  *tmp ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___0 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___1 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___2 ;
  SDL_RWops __attribute__((__visibility__("default")))  *tmp___3 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___4 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___5 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___6 ;
  SDL_RWops __attribute__((__visibility__("default")))  *tmp___7 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___8 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___9 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___10 ;

  {
#line 225
  tmp = SDL_RWFromFile("graphics/Level-Up.bmp", "rb");
#line 225
  tmp___0 = SDL_LoadBMP_RW((SDL_RWops *)tmp, 1);
#line 225
  bitmap = (SDL_Surface *)tmp___0;
#line 226
  if (! bitmap) {
#line 226
    Panic("load_adjust_symbols", "display.c", (char *)"Could not load [graphics/Level-Up.bmp]");
  }
#line 227
  if ((unsigned int )(bitmap->format)->palette != (unsigned int )((void *)0)) {
#line 228
    SDL_SetColors(screen, ((bitmap->format)->palette)->colors, 0, ((bitmap->format)->palette)->ncolors);
  }
#line 231
  tmp___1 = SDL_DisplayFormat(bitmap);
#line 231
  adjust_symbol[0] = (SDL_Surface *)tmp___1;
#line 232
  if (! adjust_symbol[0]) {
#line 233
    Panic("load_adjust_symbols", "display.c", (char *)"Can not convert [graphics/Level-Up.bmp] to hardware format");
  }
#line 234
  tmp___2 = SDL_MapRGB((SDL_PixelFormat const   *)screen->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0);
#line 234
  SDL_SetColorKey(adjust_symbol[0], 4096U, (unsigned int )tmp___2);
#line 236
  SDL_FreeSurface(bitmap);
#line 238
  tmp___3 = SDL_RWFromFile("graphics/Level-Medium.bmp", "rb");
#line 238
  tmp___4 = SDL_LoadBMP_RW((SDL_RWops *)tmp___3, 1);
#line 238
  bitmap = (SDL_Surface *)tmp___4;
#line 239
  if (! bitmap) {
#line 239
    Panic("load_adjust_symbols", "display.c", (char *)"Could not load [graphics/Level-Medium.bmp]");
  }
#line 240
  if ((unsigned int )(bitmap->format)->palette != (unsigned int )((void *)0)) {
#line 241
    SDL_SetColors(screen, ((bitmap->format)->palette)->colors, 0, ((bitmap->format)->palette)->ncolors);
  }
#line 244
  tmp___5 = SDL_DisplayFormat(bitmap);
#line 244
  adjust_symbol[1] = (SDL_Surface *)tmp___5;
#line 245
  if (! adjust_symbol[1]) {
#line 246
    Panic("load_adjust_symbols", "display.c", (char *)"Can not convert [graphics/Level-Medium.bmp] to hardware format");
  }
#line 247
  tmp___6 = SDL_MapRGB((SDL_PixelFormat const   *)screen->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0);
#line 247
  SDL_SetColorKey(adjust_symbol[1], 4096U, (unsigned int )tmp___6);
#line 249
  SDL_FreeSurface(bitmap);
#line 251
  tmp___7 = SDL_RWFromFile("graphics/Level-Down.bmp", "rb");
#line 251
  tmp___8 = SDL_LoadBMP_RW((SDL_RWops *)tmp___7, 1);
#line 251
  bitmap = (SDL_Surface *)tmp___8;
#line 252
  if (! bitmap) {
#line 252
    Panic("load_adjust_symbols", "display.c", (char *)"Could not load [graphics/Level-Down.bmp]");
  }
#line 253
  if ((unsigned int )(bitmap->format)->palette != (unsigned int )((void *)0)) {
#line 254
    SDL_SetColors(screen, ((bitmap->format)->palette)->colors, 0, ((bitmap->format)->palette)->ncolors);
  }
#line 257
  tmp___9 = SDL_DisplayFormat(bitmap);
#line 257
  adjust_symbol[2] = (SDL_Surface *)tmp___9;
#line 258
  if (! adjust_symbol[2]) {
#line 259
    Panic("load_adjust_symbols", "display.c", (char *)"Can not convert [graphics/Level-Down.bmp] to hardware format");
  }
#line 260
  tmp___10 = SDL_MapRGB((SDL_PixelFormat const   *)screen->format, (unsigned char)0,
                        (unsigned char)0, (unsigned char)0);
#line 260
  SDL_SetColorKey(adjust_symbol[2], 4096U, (unsigned int )tmp___10);
#line 262
  SDL_FreeSurface(bitmap);
#line 264
  if (! ((adjust_symbol[0])->h == (adjust_symbol[1])->h)) {
#line 264
    Panic("load_adjust_symbols", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "adjust_symbol[0]->h == adjust_symbol[1]->h", 264);
  }
#line 265
  if (! ((adjust_symbol[1])->h == (adjust_symbol[2])->h)) {
#line 265
    Panic("load_adjust_symbols", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "adjust_symbol[1]->h == adjust_symbol[2]->h", 265);
  }
#line 266
  return;
}
}
#line 272 "display.c"
void draw_bordered_rect(SDL_Rect *orig , SDL_Rect *border , int thick ) 
{ SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  SDL_Rect *my_c ;

  {
#line 275
  if (thick > 0) {
#line 275
    if (! (thick < 8)) {
#line 275
      Panic("draw_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
            "thick > 0 && thick < 8", 275);
    }
  } else {
#line 275
    Panic("draw_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "thick > 0 && thick < 8", 275);
  }
#line 277
  border->x = (short )((int )orig->x - thick);
#line 278
  border->y = (short )((int )orig->y - thick);
#line 279
  border->w = (unsigned short )((int )orig->w + thick * 2);
#line 280
  border->h = (unsigned short )((int )orig->h + thick * 2);
#line 282
  SDL_FillRect(widget_layer, border, int_grey);
#line 283
  SDL_FillRect(widget_layer, orig, int_solid_black);
#line 286
  my_b = border;
#line 286
  my_d = border;
#line 286
  if (my_b) {
#line 286
    if ((int )my_b->x < 0) {
#line 286
      my_b->x = (short)0;
    }
#line 286
    if ((int )my_b->y < 0) {
#line 286
      my_b->y = (short)0;
    }
#line 286
    if ((int )my_b->x + (int )my_b->w > 640) {
#line 286
      my_b->w = (unsigned short )(640 - (int )my_b->x);
    }
#line 286
    if ((int )my_b->y + (int )my_b->h > 480) {
#line 286
      my_b->h = (unsigned short )(480 - (int )my_b->y);
    }
  }
#line 286
  if (my_d) {
#line 286
    if ((int )my_d->x < 0) {
#line 286
      my_d->x = (short)0;
    }
#line 286
    if ((int )my_d->y < 0) {
#line 286
      my_d->y = (short)0;
    }
#line 286
    if ((int )my_d->x + (int )my_d->w > 640) {
#line 286
      my_d->w = (unsigned short )(640 - (int )my_d->x);
    }
#line 286
    if ((int )my_d->y + (int )my_d->h > 480) {
#line 286
      my_d->h = (unsigned short )(480 - (int )my_d->y);
    }
  }
#line 286
  tmp = SDL_UpperBlit(widget_layer, my_b, screen, my_d);
#line 286
  if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 286
    Panic("draw_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 286);
  }
#line 287
  my_c = border;
#line 287
  if (! my_c) {
#line 287
    Panic("draw_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 287);
  }
#line 287
  if (my_c) {
#line 287
    if ((int )my_c->x < 0) {
#line 287
      my_c->x = (short)0;
    }
#line 287
    if ((int )my_c->y < 0) {
#line 287
      my_c->y = (short)0;
    }
#line 287
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 287
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 287
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 287
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 287
  SDL_UpdateRects(screen, 1, border);
#line 289
  return;
}
}
#line 296 "display.c"
void draw_pre_bordered_rect(SDL_Rect *border , int thick ) 
{ SDL_Rect orig ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  SDL_Rect *my_c ;

  {
#line 300
  if (thick > 0) {
#line 300
    if (! (thick < 8)) {
#line 300
      Panic("draw_pre_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
            "thick > 0 && thick < 8", 300);
    }
  } else {
#line 300
    Panic("draw_pre_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "thick > 0 && thick < 8", 300);
  }
#line 302
  orig.x = (short )((int )border->x + thick);
#line 303
  orig.y = (short )((int )border->y + thick);
#line 304
  orig.w = (unsigned short )((int )border->w - thick * 2);
#line 305
  orig.h = (unsigned short )((int )border->h - thick * 2);
#line 307
  SDL_FillRect(widget_layer, border, int_grey);
#line 308
  SDL_FillRect(widget_layer, & orig, int_solid_black);
#line 311
  my_b = border;
#line 311
  my_d = border;
#line 311
  if (my_b) {
#line 311
    if ((int )my_b->x < 0) {
#line 311
      my_b->x = (short)0;
    }
#line 311
    if ((int )my_b->y < 0) {
#line 311
      my_b->y = (short)0;
    }
#line 311
    if ((int )my_b->x + (int )my_b->w > 640) {
#line 311
      my_b->w = (unsigned short )(640 - (int )my_b->x);
    }
#line 311
    if ((int )my_b->y + (int )my_b->h > 480) {
#line 311
      my_b->h = (unsigned short )(480 - (int )my_b->y);
    }
  }
#line 311
  if (my_d) {
#line 311
    if ((int )my_d->x < 0) {
#line 311
      my_d->x = (short)0;
    }
#line 311
    if ((int )my_d->y < 0) {
#line 311
      my_d->y = (short)0;
    }
#line 311
    if ((int )my_d->x + (int )my_d->w > 640) {
#line 311
      my_d->w = (unsigned short )(640 - (int )my_d->x);
    }
#line 311
    if ((int )my_d->y + (int )my_d->h > 480) {
#line 311
      my_d->h = (unsigned short )(480 - (int )my_d->y);
    }
  }
#line 311
  tmp = SDL_UpperBlit(widget_layer, my_b, screen, my_d);
#line 311
  if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 311
    Panic("draw_pre_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 311);
  }
#line 312
  my_c = border;
#line 312
  if (! my_c) {
#line 312
    Panic("draw_pre_bordered_rect", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 312);
  }
#line 312
  if (my_c) {
#line 312
    if ((int )my_c->x < 0) {
#line 312
      my_c->x = (short)0;
    }
#line 312
    if ((int )my_c->y < 0) {
#line 312
      my_c->y = (short)0;
    }
#line 312
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 312
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 312
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 312
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 312
  SDL_UpdateRects(screen, 1, border);
#line 313
  return;
}
}
#line 320 "display.c"
void setup_layers(SDL_Surface *screen___0 ) 
{ SDL_Rect all ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___0 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___3 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___4 ;

  {
#line 324
  tmp = SDL_CreateRGBSurface(4097U, screen___0->w, screen___0->h, 8, 0U, 0U, 0U, 0U);
#line 324
  flame_layer = (SDL_Surface *)tmp;
#line 327
  tmp___0 = SDL_CreateRGBSurface(4097U, screen___0->w, screen___0->h, (int )(screen___0->format)->BitsPerPixel,
                                 (screen___0->format)->Rmask, (screen___0->format)->Gmask,
                                 (screen___0->format)->Bmask, (screen___0->format)->Amask);
#line 327
  widget_layer = (SDL_Surface *)tmp___0;
#line 332
  tmp___1 = SDL_MapRGB((SDL_PixelFormat const   *)widget_layer->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0);
#line 332
  tmp___2 = SDL_SetColorKey(widget_layer, 4096U, (unsigned int )tmp___1);
#line 332
  if (tmp___2) {
#line 334
    Panic("setup_layers", "display.c", (char *)"SDL_SetColorKey failed on the widget layer.");
  }
#line 336
  tmp___3 = SDL_MapRGB((SDL_PixelFormat const   *)widget_layer->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0);
#line 336
  if (int_black != (Uint32 )tmp___3) {
#line 337
    printf((char const   * __restrict  )"%-14.14s| ", "setup_layers");
#line 337
    printf((char const   * __restrict  )"*** Warning: screen and widget layer have different RGB format.\n");
#line 337
    fflush(stdout);
  }
#line 339
  tmp___4 = SDL_MapRGB((SDL_PixelFormat const   *)flame_layer->format, (unsigned char)0,
                       (unsigned char)0, (unsigned char)0);
#line 339
  if (int_black != (Uint32 )tmp___4) {
#line 340
    printf((char const   * __restrict  )"%-14.14s| ", "setup_layers");
#line 340
    printf((char const   * __restrict  )"*** Warning: screen and flame layer have different RGB format.\n");
#line 340
    fflush(stdout);
  }
#line 343
  all.y = (short)0;
#line 343
  all.x = all.y;
#line 344
  all.w = (unsigned short )screen___0->w;
#line 345
  all.h = (unsigned short )screen___0->h;
#line 347
  SDL_FillRect(widget_layer, & all, int_black);
#line 348
  SDL_FillRect(flame_layer, & all, int_solid_black);
#line 349
  return;
}
}
#line 356 "display.c"
void draw_background(SDL_Surface *screen___0 , int blockWidth , Grid *g___0 , int *level ,
                     int *my_adj , int *their_adj , char **name ) 
{ char buf[1024] ;
  int i ;
  char buf___0[1024] ;
  int tmp ;
  int text_h ;
  int tmp___0 ;
  char buf___1[80] ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  SDL_Rect *my_b___1 ;
  SDL_Rect *my_d___1 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  SDL_Rect *my_b___2 ;
  SDL_Rect *my_d___2 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  int text_h___0 ;
  int tmp___5 ;
  int text_h___1 ;
  int tmp___6 ;
  SDL_Rect dest ;
  SDL_Rect *my_b___3 ;
  SDL_Rect *my_d___3 ;
  int __attribute__((__visibility__("default")))  tmp___7 ;
  SDL_Rect *my_b___4 ;
  SDL_Rect *my_d___4 ;
  int __attribute__((__visibility__("default")))  tmp___8 ;
  SDL_Rect *my_c ;

  {
#line 364
  if ((int )gametype == 4) {
    goto _L;
  } else {
#line 364
    if ((int )gametype == 2) {
      goto _L;
    } else {
#line 364
      if ((int )gametype == 3) {
        goto _L;
      } else {
#line 364
        if ((int )gametype == 5) {
          _L: /* CIL Label */ 
#line 365
          if (! ((g___0 + 0)->w == (g___0 + 1)->w)) {
#line 365
            Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                  "g[0].w == g[1].w", 365);
          }
#line 366
          if (! ((g___0 + 0)->h == (g___0 + 1)->h)) {
#line 366
            Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                  "g[0].h == g[1].h", 366);
          }
        }
      }
    }
  }
#line 372
  memset((void *)(& layout), 0, sizeof(layout));
#line 374
  if (! adjust_symbol[0]) {
#line 375
    load_adjust_symbols();
  }
#line 380
  if ((int )gametype == 4) {
    goto _L___0;
  } else {
#line 380
    if ((int )gametype == 2) {
      goto _L___0;
    } else {
#line 380
      if ((int )gametype == 3) {
        goto _L___0;
      } else {
#line 380
        if ((int )gametype == 5) {
          _L___0: /* CIL Label */ 
#line 381
          layout.grid[0].x = (short )(((screen___0->w / 2 - (g___0 + 0)->w * blockWidth) - 5 * blockWidth) - 2);
#line 382
          layout.grid[0].y = (short )((screen___0->h - (g___0 + 0)->h * blockWidth) / 2);
#line 383
          layout.grid[0].w = (unsigned short )((g___0 + 0)->w * blockWidth);
#line 384
          layout.grid[0].h = (unsigned short )((g___0 + 0)->h * blockWidth);
#line 386
          layout.grid[1].y = (short )((screen___0->h - (g___0 + 0)->h * blockWidth) / 2);
#line 387
          layout.grid[1].w = (unsigned short )((g___0 + 0)->w * blockWidth);
#line 388
          layout.grid[1].h = (unsigned short )((g___0 + 0)->h * blockWidth);
#line 389
          layout.grid[1].x = (short )(((screen___0->w / 2 - 4) + 5 * blockWidth) + 6);
#line 392
          draw_bordered_rect(& layout.grid[1], & layout.grid_border[1], 2);
#line 393
          (g___0 + 1)->board = layout.grid[1];
        } else {
#line 395
          layout.grid[0].x = (short )((screen___0->w - (g___0 + 0)->w * blockWidth) / 2);
#line 396
          layout.grid[0].y = (short )((screen___0->h - (g___0 + 0)->h * blockWidth) / 2);
#line 397
          layout.grid[0].w = (unsigned short )((g___0 + 0)->w * blockWidth);
#line 398
          layout.grid[0].h = (unsigned short )((g___0 + 0)->h * blockWidth);
        }
      }
    }
  }
#line 402
  draw_bordered_rect(& layout.grid[0], & layout.grid_border[0], 2);
#line 403
  (g___0 + 0)->board = layout.grid[0];
#line 408
  i = 0;
#line 408
  while (1) {
#line 408
    if ((int )gametype == 4) {
#line 408
      tmp = 1;
    } else {
#line 408
      if ((int )gametype == 2) {
#line 408
        tmp = 1;
      } else {
#line 408
        if ((int )gametype == 3) {
#line 408
          tmp = 1;
        } else {
#line 408
          if ((int )gametype == 5) {
#line 408
            tmp = 1;
          } else {
#line 408
            tmp = 0;
          }
        }
      }
    }
#line 408
    if (! (i < 1 + tmp)) {
#line 408
      break;
    }
#line 409
    layout.name[i].x = layout.grid[i].x;
#line 410
    layout.name[i].y = (short )(((int )layout.grid[i].y + (int )layout.grid[i].h) + 2);
#line 411
    layout.name[i].w = layout.grid[i].w;
#line 412
    layout.name[i].h = (unsigned short )(screen___0->h - (int )layout.name[i].y);
#line 414
    if ((int )gametype == 7) {
#line 416
      SDL_FillRect(widget_layer, & layout.name[i], int_black);
#line 417
      SDL_FillRect(screen___0, & layout.name[i], int_black);
#line 418
      sprintf((char * __restrict  )(buf___0), (char const   * __restrict  )"Demo (%s)",
              *(name + i));
#line 419
      draw_string(buf___0, color_blue, (int )layout.grid_border[i].x + (int )layout.grid_border[i].w / 2,
                  (int )layout.grid_border[i].y + (int )layout.grid_border[i].h, (1 | (1 << 4)) | (1 << 3));
    } else {
#line 423
      draw_string(*(name + i), color_blue, (int )layout.grid_border[i].x + (int )layout.grid_border[i].w / 2,
                  (int )layout.grid_border[i].y + (int )layout.grid_border[i].h, 1);
    }
#line 429
    layout.score[i].x = layout.grid_border[i].x;
#line 430
    layout.score[i].w = layout.grid_border[i].w;
#line 431
    layout.score[i].y = (short)0;
#line 432
    layout.score[i].h = (unsigned short )layout.grid_border[i].y;
#line 433
    SDL_FillRect(widget_layer, & layout.score[i], int_black);
#line 434
    SDL_FillRect(screen___0, & layout.score[i], int_black);
#line 436
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"Level %d, Score:",
            *(level + i));
#line 437
    draw_string(buf, color_blue, (int )layout.grid_border[i].x, (int )layout.grid_border[i].y,
                (1 << 1) | (1 << 4));
#line 440
    layout.score[i].x = (short )((int )layout.grid_border[i].x + (int )layout.grid_border[i].w);
#line 441
    layout.score[i].y = layout.grid_border[i].y;
#line 408
    i ++;
  }
#line 451
  if (! ((int )gametype == 7)) {
#line 453
    if ((int )gametype == 4) {
      goto _L___1;
    } else {
#line 453
      if ((int )gametype == 2) {
        goto _L___1;
      } else {
#line 453
        if ((int )gametype == 3) {
          goto _L___1;
        } else {
#line 453
          if ((int )gametype == 5) {
            _L___1: /* CIL Label */ 
#line 454
            draw_string((char *)"Time Left", color_blue, screen___0->w / 2, (int )layout.score[0].y,
                        1 | (1 << 1));
#line 456
            layout.time.x = (short )((screen___0->w - 80) / 2);
#line 457
            layout.time.y = layout.score[0].y;
#line 458
            layout.time.w = (unsigned short)80;
#line 459
            layout.time.h = (unsigned short)28;
#line 460
            draw_bordered_rect(& layout.time, & layout.time_border, 2);
          } else {
#line 462
            tmp___0 = draw_string((char *)"Time Left", color_blue, screen___0->w / 10,
                                  screen___0->h / 5, 0);
#line 462
            text_h = tmp___0;
#line 464
            layout.time.x = (short )(screen___0->w / 10);
#line 465
            layout.time.y = (short )(screen___0->h / 5 + text_h);
#line 466
            layout.time.w = (unsigned short)80;
#line 467
            layout.time.h = (unsigned short)28;
#line 469
            draw_bordered_rect(& layout.time, & layout.time_border, 2);
          }
        }
      }
    }
  }
#line 475
  if (! ((int )gametype == 7)) {
#line 477
    if ((int )gametype == 5) {
#line 478
      i = 0;
#line 478
      while (i < 3) {
#line 481
        layout.adjust[0].symbol[i].x = (short )((screen___0->w - (adjust_symbol[i])->w) / 2);
#line 482
        layout.adjust[0].symbol[i].w = (unsigned short )(adjust_symbol[i])->w;
#line 483
        layout.adjust[0].symbol[i].h = (unsigned short )(adjust_symbol[i])->h;
#line 484
        layout.adjust[0].symbol[i].y = (short )(((int )layout.time_border.y + (int )layout.time_border.h) + i * (adjust_symbol[i])->h);
#line 487
        my_b = (SDL_Rect *)((void *)0);
#line 487
        my_d = & layout.adjust[0].symbol[i];
#line 487
        if (my_b) {
#line 487
          if ((int )my_b->x < 0) {
#line 487
            my_b->x = (short)0;
          }
#line 487
          if ((int )my_b->y < 0) {
#line 487
            my_b->y = (short)0;
          }
#line 487
          if ((int )my_b->x + (int )my_b->w > 640) {
#line 487
            my_b->w = (unsigned short )(640 - (int )my_b->x);
          }
#line 487
          if ((int )my_b->y + (int )my_b->h > 480) {
#line 487
            my_b->h = (unsigned short )(480 - (int )my_b->y);
          }
        }
#line 487
        if (my_d) {
#line 487
          if ((int )my_d->x < 0) {
#line 487
            my_d->x = (short)0;
          }
#line 487
          if ((int )my_d->y < 0) {
#line 487
            my_d->y = (short)0;
          }
#line 487
          if ((int )my_d->x + (int )my_d->w > 640) {
#line 487
            my_d->w = (unsigned short )(640 - (int )my_d->x);
          }
#line 487
          if ((int )my_d->y + (int )my_d->h > 480) {
#line 487
            my_d->h = (unsigned short )(480 - (int )my_d->y);
          }
        }
#line 487
        tmp___1 = SDL_UpperBlit(adjust_symbol[i], my_b, widget_layer, my_d);
#line 487
        if (! (tmp___1 == (int __attribute__((__visibility__("default")))  )0)) {
#line 487
          Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                "SDL_UpperBlit(adjust_symbol[i],my_b,widget_layer,my_d) == 0", 488);
        }
#line 491
        sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%d",
                *(my_adj + i));
#line 492
        draw_string(buf___1, color_red, (int )layout.adjust[0].symbol[i].x - 10, (int )layout.adjust[0].symbol[i].y,
                    (1 << 2) | (1 << 4));
#line 495
        sprintf((char * __restrict  )(buf___1), (char const   * __restrict  )"%d",
                *(their_adj + i));
#line 496
        draw_string(buf___1, color_red, ((int )layout.adjust[0].symbol[i].x + (int )layout.adjust[0].symbol[i].w) + 10,
                    (int )layout.adjust[0].symbol[i].y, 1 << 4);
#line 478
        i ++;
      }
    } else {
#line 500
      if ((int )gametype == 4) {
        goto _L___2;
      } else {
#line 500
        if ((int )gametype == 2) {
          goto _L___2;
        } else {
#line 500
          if ((int )gametype == 3) {
            goto _L___2;
          } else {
#line 500
            if ((int )gametype == 5) {
              _L___2: /* CIL Label */ 
#line 501
              i = 0;
#line 501
              while (i < 3) {
#line 502
                layout.adjust[0].symbol[i].w = (unsigned short )(adjust_symbol[i])->w;
#line 503
                layout.adjust[0].symbol[i].h = (unsigned short )(adjust_symbol[i])->h;
#line 504
                layout.adjust[0].symbol[i].x = (short )((screen___0->w - 3 * (adjust_symbol[i])->w) / 2);
#line 505
                layout.adjust[0].symbol[i].y = (short )(((int )layout.time_border.y + (int )layout.time_border.h) + i * (adjust_symbol[i])->h);
#line 507
                SDL_FillRect(widget_layer, & layout.adjust[0].symbol[i], int_black);
#line 508
                SDL_FillRect(screen___0, & layout.adjust[0].symbol[i], int_black);
#line 509
                if (*(my_adj + i) != -1) {
#line 510
                  my_b___0 = (SDL_Rect *)((void *)0);
#line 510
                  my_d___0 = & layout.adjust[0].symbol[i];
#line 510
                  if (my_b___0) {
#line 510
                    if ((int )my_b___0->x < 0) {
#line 510
                      my_b___0->x = (short)0;
                    }
#line 510
                    if ((int )my_b___0->y < 0) {
#line 510
                      my_b___0->y = (short)0;
                    }
#line 510
                    if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 510
                      my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
                    }
#line 510
                    if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 510
                      my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
                    }
                  }
#line 510
                  if (my_d___0) {
#line 510
                    if ((int )my_d___0->x < 0) {
#line 510
                      my_d___0->x = (short)0;
                    }
#line 510
                    if ((int )my_d___0->y < 0) {
#line 510
                      my_d___0->y = (short)0;
                    }
#line 510
                    if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 510
                      my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
                    }
#line 510
                    if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 510
                      my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
                    }
                  }
#line 510
                  tmp___2 = SDL_UpperBlit(adjust_symbol[*(my_adj + i)], my_b___0,
                                          widget_layer, my_d___0);
#line 510
                  if (! (tmp___2 == (int __attribute__((__visibility__("default")))  )0)) {
#line 510
                    Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(adjust_symbol[my_adj[i]],my_b,widget_layer,my_d) == 0",
                          511);
                  }
                }
#line 512
                layout.adjust[1].symbol[i].w = (unsigned short )(adjust_symbol[i])->w;
#line 513
                layout.adjust[1].symbol[i].h = (unsigned short )(adjust_symbol[i])->h;
#line 514
                layout.adjust[1].symbol[i].x = (short )(screen___0->w / 2 + (adjust_symbol[i])->w / 2);
#line 515
                layout.adjust[1].symbol[i].y = (short )(((int )layout.time_border.y + (int )layout.time_border.h) + i * (adjust_symbol[i])->h);
#line 517
                SDL_FillRect(widget_layer, & layout.adjust[1].symbol[i], int_black);
#line 518
                SDL_FillRect(screen___0, & layout.adjust[1].symbol[i], int_black);
#line 519
                if (*(their_adj + i) != -1) {
#line 520
                  my_b___1 = (SDL_Rect *)((void *)0);
#line 520
                  my_d___1 = & layout.adjust[1].symbol[i];
#line 520
                  if (my_b___1) {
#line 520
                    if ((int )my_b___1->x < 0) {
#line 520
                      my_b___1->x = (short)0;
                    }
#line 520
                    if ((int )my_b___1->y < 0) {
#line 520
                      my_b___1->y = (short)0;
                    }
#line 520
                    if ((int )my_b___1->x + (int )my_b___1->w > 640) {
#line 520
                      my_b___1->w = (unsigned short )(640 - (int )my_b___1->x);
                    }
#line 520
                    if ((int )my_b___1->y + (int )my_b___1->h > 480) {
#line 520
                      my_b___1->h = (unsigned short )(480 - (int )my_b___1->y);
                    }
                  }
#line 520
                  if (my_d___1) {
#line 520
                    if ((int )my_d___1->x < 0) {
#line 520
                      my_d___1->x = (short)0;
                    }
#line 520
                    if ((int )my_d___1->y < 0) {
#line 520
                      my_d___1->y = (short)0;
                    }
#line 520
                    if ((int )my_d___1->x + (int )my_d___1->w > 640) {
#line 520
                      my_d___1->w = (unsigned short )(640 - (int )my_d___1->x);
                    }
#line 520
                    if ((int )my_d___1->y + (int )my_d___1->h > 480) {
#line 520
                      my_d___1->h = (unsigned short )(480 - (int )my_d___1->y);
                    }
                  }
#line 520
                  tmp___3 = SDL_UpperBlit(adjust_symbol[*(their_adj + i)], my_b___1,
                                          widget_layer, my_d___1);
#line 520
                  if (! (tmp___3 == (int __attribute__((__visibility__("default")))  )0)) {
#line 520
                    Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(adjust_symbol[their_adj[i]],my_b,widget_layer,my_d) == 0",
                          521);
                  }
                }
#line 501
                i ++;
              }
            } else {
#line 524
              i = 0;
#line 524
              while (i < 3) {
#line 525
                layout.adjust[0].symbol[i].w = (unsigned short )(adjust_symbol[i])->w;
#line 526
                layout.adjust[0].symbol[i].h = (unsigned short )(adjust_symbol[i])->h;
#line 527
                layout.adjust[0].symbol[i].x = (short )(((int )layout.grid_border[0].x + (int )layout.grid_border[0].w) + 2 * (adjust_symbol[i])->w);
#line 530
                layout.adjust[0].symbol[i].y = (short )(((int )layout.time_border.y + (int )layout.time_border.h) + i * (adjust_symbol[i])->h);
#line 532
                SDL_FillRect(widget_layer, & layout.adjust[0].symbol[i], int_black);
#line 533
                SDL_FillRect(screen___0, & layout.adjust[0].symbol[i], int_black);
#line 534
                if (*(my_adj + i) != -1) {
#line 535
                  my_b___2 = (SDL_Rect *)((void *)0);
#line 535
                  my_d___2 = & layout.adjust[0].symbol[i];
#line 535
                  if (my_b___2) {
#line 535
                    if ((int )my_b___2->x < 0) {
#line 535
                      my_b___2->x = (short)0;
                    }
#line 535
                    if ((int )my_b___2->y < 0) {
#line 535
                      my_b___2->y = (short)0;
                    }
#line 535
                    if ((int )my_b___2->x + (int )my_b___2->w > 640) {
#line 535
                      my_b___2->w = (unsigned short )(640 - (int )my_b___2->x);
                    }
#line 535
                    if ((int )my_b___2->y + (int )my_b___2->h > 480) {
#line 535
                      my_b___2->h = (unsigned short )(480 - (int )my_b___2->y);
                    }
                  }
#line 535
                  if (my_d___2) {
#line 535
                    if ((int )my_d___2->x < 0) {
#line 535
                      my_d___2->x = (short)0;
                    }
#line 535
                    if ((int )my_d___2->y < 0) {
#line 535
                      my_d___2->y = (short)0;
                    }
#line 535
                    if ((int )my_d___2->x + (int )my_d___2->w > 640) {
#line 535
                      my_d___2->w = (unsigned short )(640 - (int )my_d___2->x);
                    }
#line 535
                    if ((int )my_d___2->y + (int )my_d___2->h > 480) {
#line 535
                      my_d___2->h = (unsigned short )(480 - (int )my_d___2->y);
                    }
                  }
#line 535
                  tmp___4 = SDL_UpperBlit(adjust_symbol[*(my_adj + i)], my_b___2,
                                          widget_layer, my_d___2);
#line 535
                  if (! (tmp___4 == (int __attribute__((__visibility__("default")))  )0)) {
#line 535
                    Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(adjust_symbol[my_adj[i]],my_b,widget_layer,my_d) == 0",
                          536);
                  }
                }
#line 524
                i ++;
              }
            }
          }
        }
      }
    }
  }
#line 543
  if (! ((int )gametype == 7)) {
#line 545
    if ((int )gametype == 4) {
      goto _L___3;
    } else {
#line 545
      if ((int )gametype == 2) {
        goto _L___3;
      } else {
#line 545
        if ((int )gametype == 3) {
          goto _L___3;
        } else {
#line 545
          if ((int )gametype == 5) {
            _L___3: /* CIL Label */ 
#line 546
            tmp___5 = draw_string((char *)"Next Piece", color_blue, screen___0->w / 2,
                                  (int )layout.adjust[0].symbol[2].y + (int )layout.adjust[0].symbol[2].h,
                                  1);
#line 546
            text_h___0 = tmp___5;
#line 551
            layout.next_piece[0].w = (unsigned short )(5 * blockWidth);
#line 552
            layout.next_piece[0].h = (unsigned short )(5 * blockWidth);
#line 553
            layout.next_piece[0].x = (short )(screen___0->w / 2 - 5 * blockWidth);
#line 554
            layout.next_piece[0].y = (short )(((int )layout.adjust[0].symbol[2].y + (int )layout.adjust[0].symbol[2].h) + text_h___0);
#line 556
            draw_bordered_rect(& layout.next_piece[0], & layout.next_piece_border[0],
                               2);
#line 558
            layout.next_piece[1].w = layout.next_piece[0].w;
#line 559
            layout.next_piece[1].h = layout.next_piece[0].h;
#line 560
            layout.next_piece[1].y = layout.next_piece[0].y;
#line 561
            layout.next_piece[1].x = (short )(screen___0->w / 2);
#line 562
            draw_bordered_rect(& layout.next_piece[1], & layout.next_piece_border[1],
                               2);
          } else {
#line 564
            tmp___6 = draw_string((char *)"Next Piece", color_blue, screen___0->w / 10,
                                  (2 * screen___0->h) / 5, 0);
#line 564
            text_h___1 = tmp___6;
#line 567
            layout.next_piece[0].w = (unsigned short )(5 * blockWidth);
#line 568
            layout.next_piece[0].h = (unsigned short )(5 * blockWidth);
#line 569
            layout.next_piece[0].x = (short )(screen___0->w / 10);
#line 570
            layout.next_piece[0].y = (short )((2 * screen___0->h) / 5 + text_h___1);
#line 573
            draw_bordered_rect(& layout.next_piece[0], & layout.next_piece_border[0],
                               2);
          }
        }
      }
    }
  }
#line 579
  if (! ((int )gametype == 7)) {
#line 581
    if ((int )gametype == 4) {
#line 582
      layout.pause.x = layout.next_piece_border[0].x;
#line 583
      layout.pause.y = (short )((((int )layout.next_piece_border[0].h + (int )layout.next_piece_border[0].y) + 2) + (int )layout.next_piece_border[0].h / 3);
#line 585
      layout.pause.w = (unsigned short )((int )layout.next_piece_border[0].w + (int )layout.next_piece[1].w);
#line 586
      layout.pause.h = (unsigned short )((int )layout.next_piece_border[0].h / 3);
    } else {
#line 581
      if ((int )gametype == 2) {
#line 582
        layout.pause.x = layout.next_piece_border[0].x;
#line 583
        layout.pause.y = (short )((((int )layout.next_piece_border[0].h + (int )layout.next_piece_border[0].y) + 2) + (int )layout.next_piece_border[0].h / 3);
#line 585
        layout.pause.w = (unsigned short )((int )layout.next_piece_border[0].w + (int )layout.next_piece[1].w);
#line 586
        layout.pause.h = (unsigned short )((int )layout.next_piece_border[0].h / 3);
      } else {
#line 581
        if ((int )gametype == 3) {
#line 582
          layout.pause.x = layout.next_piece_border[0].x;
#line 583
          layout.pause.y = (short )((((int )layout.next_piece_border[0].h + (int )layout.next_piece_border[0].y) + 2) + (int )layout.next_piece_border[0].h / 3);
#line 585
          layout.pause.w = (unsigned short )((int )layout.next_piece_border[0].w + (int )layout.next_piece[1].w);
#line 586
          layout.pause.h = (unsigned short )((int )layout.next_piece_border[0].h / 3);
        } else {
#line 581
          if ((int )gametype == 5) {
#line 582
            layout.pause.x = layout.next_piece_border[0].x;
#line 583
            layout.pause.y = (short )((((int )layout.next_piece_border[0].h + (int )layout.next_piece_border[0].y) + 2) + (int )layout.next_piece_border[0].h / 3);
#line 585
            layout.pause.w = (unsigned short )((int )layout.next_piece_border[0].w + (int )layout.next_piece[1].w);
#line 586
            layout.pause.h = (unsigned short )((int )layout.next_piece_border[0].h / 3);
          } else {
#line 588
            layout.pause.x = layout.next_piece_border[0].x;
#line 589
            layout.pause.y = (short )((((int )layout.next_piece_border[0].h + (int )layout.next_piece_border[0].y) + 2) + (int )layout.next_piece_border[0].h / 3);
#line 591
            layout.pause.w = layout.next_piece_border[0].w;
#line 592
            layout.pause.h = (unsigned short )((int )layout.next_piece_border[0].h / 3);
          }
        }
      }
    }
  }
#line 598
  dest.x = (short)0;
#line 598
  dest.y = (short)0;
#line 598
  dest.w = (unsigned short )screen___0->w;
#line 598
  dest.h = (unsigned short )screen___0->h;
#line 600
  my_b___3 = (SDL_Rect *)((void *)0);
#line 600
  my_d___3 = (SDL_Rect *)((void *)0);
#line 600
  if (my_b___3) {
#line 600
    if ((int )my_b___3->x < 0) {
#line 600
      my_b___3->x = (short)0;
    }
#line 600
    if ((int )my_b___3->y < 0) {
#line 600
      my_b___3->y = (short)0;
    }
#line 600
    if ((int )my_b___3->x + (int )my_b___3->w > 640) {
#line 600
      my_b___3->w = (unsigned short )(640 - (int )my_b___3->x);
    }
#line 600
    if ((int )my_b___3->y + (int )my_b___3->h > 480) {
#line 600
      my_b___3->h = (unsigned short )(480 - (int )my_b___3->y);
    }
  }
#line 600
  if (my_d___3) {
#line 600
    if ((int )my_d___3->x < 0) {
#line 600
      my_d___3->x = (short)0;
    }
#line 600
    if ((int )my_d___3->y < 0) {
#line 600
      my_d___3->y = (short)0;
    }
#line 600
    if ((int )my_d___3->x + (int )my_d___3->w > 640) {
#line 600
      my_d___3->w = (unsigned short )(640 - (int )my_d___3->x);
    }
#line 600
    if ((int )my_d___3->y + (int )my_d___3->h > 480) {
#line 600
      my_d___3->h = (unsigned short )(480 - (int )my_d___3->y);
    }
  }
#line 600
  tmp___7 = SDL_UpperBlit(flame_layer, my_b___3, screen___0, my_d___3);
#line 600
  if (! (tmp___7 == (int __attribute__((__visibility__("default")))  )0)) {
#line 600
    Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(flame_layer,my_b,screen,my_d) == 0", 600);
  }
#line 601
  my_b___4 = (SDL_Rect *)((void *)0);
#line 601
  my_d___4 = (SDL_Rect *)((void *)0);
#line 601
  if (my_b___4) {
#line 601
    if ((int )my_b___4->x < 0) {
#line 601
      my_b___4->x = (short)0;
    }
#line 601
    if ((int )my_b___4->y < 0) {
#line 601
      my_b___4->y = (short)0;
    }
#line 601
    if ((int )my_b___4->x + (int )my_b___4->w > 640) {
#line 601
      my_b___4->w = (unsigned short )(640 - (int )my_b___4->x);
    }
#line 601
    if ((int )my_b___4->y + (int )my_b___4->h > 480) {
#line 601
      my_b___4->h = (unsigned short )(480 - (int )my_b___4->y);
    }
  }
#line 601
  if (my_d___4) {
#line 601
    if ((int )my_d___4->x < 0) {
#line 601
      my_d___4->x = (short)0;
    }
#line 601
    if ((int )my_d___4->y < 0) {
#line 601
      my_d___4->y = (short)0;
    }
#line 601
    if ((int )my_d___4->x + (int )my_d___4->w > 640) {
#line 601
      my_d___4->w = (unsigned short )(640 - (int )my_d___4->x);
    }
#line 601
    if ((int )my_d___4->y + (int )my_d___4->h > 480) {
#line 601
      my_d___4->h = (unsigned short )(480 - (int )my_d___4->y);
    }
  }
#line 601
  tmp___8 = SDL_UpperBlit(widget_layer, my_b___4, screen___0, my_d___4);
#line 601
  if (! (tmp___8 == (int __attribute__((__visibility__("default")))  )0)) {
#line 601
    Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 601);
  }
#line 602
  my_c = & dest;
#line 602
  if (! my_c) {
#line 602
    Panic("draw_background", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 602);
  }
#line 602
  if (my_c) {
#line 602
    if ((int )my_c->x < 0) {
#line 602
      my_c->x = (short)0;
    }
#line 602
    if ((int )my_c->y < 0) {
#line 602
      my_c->y = (short)0;
    }
#line 602
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 602
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 602
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 602
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 602
  SDL_UpdateRects(screen___0, 1, & dest);
#line 604
  return;
}
}
#line 611 "display.c"
void draw_pause(int on ) 
{ int i ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  SDL_Rect *my_b___1 ;
  SDL_Rect *my_d___1 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  SDL_Rect *my_c ;
  SDL_Rect *my_b___2 ;
  SDL_Rect *my_d___2 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  SDL_Rect *my_b___3 ;
  SDL_Rect *my_d___3 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;

  {
#line 615
  if (on) {
#line 616
    draw_pre_bordered_rect(& layout.pause, 2);
#line 617
    draw_string((char *)"* Paused *", color_blue, (int )layout.pause.x + (int )layout.pause.w / 2,
                (int )layout.pause.y, 1 | (1 << 3));
#line 620
    i = 0;
#line 620
    while (i < 2) {
#line 622
      if (layout.grid[i].w) {
#line 623
        my_b = & layout.grid[i];
#line 623
        my_d = & layout.grid[i];
#line 623
        if (my_b) {
#line 623
          if ((int )my_b->x < 0) {
#line 623
            my_b->x = (short)0;
          }
#line 623
          if ((int )my_b->y < 0) {
#line 623
            my_b->y = (short)0;
          }
#line 623
          if ((int )my_b->x + (int )my_b->w > 640) {
#line 623
            my_b->w = (unsigned short )(640 - (int )my_b->x);
          }
#line 623
          if ((int )my_b->y + (int )my_b->h > 480) {
#line 623
            my_b->h = (unsigned short )(480 - (int )my_b->y);
          }
        }
#line 623
        if (my_d) {
#line 623
          if ((int )my_d->x < 0) {
#line 623
            my_d->x = (short)0;
          }
#line 623
          if ((int )my_d->y < 0) {
#line 623
            my_d->y = (short)0;
          }
#line 623
          if ((int )my_d->x + (int )my_d->w > 640) {
#line 623
            my_d->w = (unsigned short )(640 - (int )my_d->x);
          }
#line 623
          if ((int )my_d->y + (int )my_d->h > 480) {
#line 623
            my_d->h = (unsigned short )(480 - (int )my_d->y);
          }
        }
#line 623
        tmp = SDL_UpperBlit(screen, my_b, widget_layer, my_d);
#line 623
        if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 623
          Panic("draw_pause", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                "SDL_UpperBlit(screen,my_b,widget_layer,my_d) == 0", 624);
        }
#line 625
        my_b___0 = & layout.next_piece[i];
#line 625
        my_d___0 = & layout.next_piece[i];
#line 625
        if (my_b___0) {
#line 625
          if ((int )my_b___0->x < 0) {
#line 625
            my_b___0->x = (short)0;
          }
#line 625
          if ((int )my_b___0->y < 0) {
#line 625
            my_b___0->y = (short)0;
          }
#line 625
          if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 625
            my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
          }
#line 625
          if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 625
            my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
          }
        }
#line 625
        if (my_d___0) {
#line 625
          if ((int )my_d___0->x < 0) {
#line 625
            my_d___0->x = (short)0;
          }
#line 625
          if ((int )my_d___0->y < 0) {
#line 625
            my_d___0->y = (short)0;
          }
#line 625
          if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 625
            my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
          }
#line 625
          if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 625
            my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
          }
        }
#line 625
        tmp___0 = SDL_UpperBlit(screen, my_b___0, widget_layer, my_d___0);
#line 625
        if (! (tmp___0 == (int __attribute__((__visibility__("default")))  )0)) {
#line 625
          Panic("draw_pause", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                "SDL_UpperBlit(screen,my_b,widget_layer,my_d) == 0", 626);
        }
      }
#line 620
      i ++;
    }
  } else {
#line 630
    SDL_FillRect(widget_layer, & layout.pause, int_black);
#line 631
    SDL_FillRect(screen, & layout.pause, int_black);
#line 632
    my_b___1 = & layout.pause;
#line 632
    my_d___1 = & layout.pause;
#line 632
    if (my_b___1) {
#line 632
      if ((int )my_b___1->x < 0) {
#line 632
        my_b___1->x = (short)0;
      }
#line 632
      if ((int )my_b___1->y < 0) {
#line 632
        my_b___1->y = (short)0;
      }
#line 632
      if ((int )my_b___1->x + (int )my_b___1->w > 640) {
#line 632
        my_b___1->w = (unsigned short )(640 - (int )my_b___1->x);
      }
#line 632
      if ((int )my_b___1->y + (int )my_b___1->h > 480) {
#line 632
        my_b___1->h = (unsigned short )(480 - (int )my_b___1->y);
      }
    }
#line 632
    if (my_d___1) {
#line 632
      if ((int )my_d___1->x < 0) {
#line 632
        my_d___1->x = (short)0;
      }
#line 632
      if ((int )my_d___1->y < 0) {
#line 632
        my_d___1->y = (short)0;
      }
#line 632
      if ((int )my_d___1->x + (int )my_d___1->w > 640) {
#line 632
        my_d___1->w = (unsigned short )(640 - (int )my_d___1->x);
      }
#line 632
      if ((int )my_d___1->y + (int )my_d___1->h > 480) {
#line 632
        my_d___1->h = (unsigned short )(480 - (int )my_d___1->y);
      }
    }
#line 632
    tmp___1 = SDL_UpperBlit(flame_layer, my_b___1, screen, my_d___1);
#line 632
    if (! (tmp___1 == (int __attribute__((__visibility__("default")))  )0)) {
#line 632
      Panic("draw_pause", "display.c", (char *)"Failed assertion \"%s\" on line %d",
            "SDL_UpperBlit(flame_layer,my_b,screen,my_d) == 0", 632);
    }
#line 635
    my_c = & layout.pause;
#line 635
    if (! my_c) {
#line 635
      Panic("draw_pause", "display.c", (char *)"Failed assertion \"%s\" on line %d",
            "my_c", 635);
    }
#line 635
    if (my_c) {
#line 635
      if ((int )my_c->x < 0) {
#line 635
        my_c->x = (short)0;
      }
#line 635
      if ((int )my_c->y < 0) {
#line 635
        my_c->y = (short)0;
      }
#line 635
      if ((int )my_c->x + (int )my_c->w > 640) {
#line 635
        my_c->w = (unsigned short )(640 - (int )my_c->x);
      }
#line 635
      if ((int )my_c->y + (int )my_c->h > 480) {
#line 635
        my_c->h = (unsigned short )(480 - (int )my_c->y);
      }
    }
#line 635
    SDL_UpdateRects(screen, 1, & layout.pause);
#line 637
    i = 0;
#line 637
    while (i < 2) {
#line 638
      if (layout.grid[i].w) {
#line 639
        my_b___2 = & layout.grid[i];
#line 639
        my_d___2 = & layout.grid[i];
#line 639
        if (my_b___2) {
#line 639
          if ((int )my_b___2->x < 0) {
#line 639
            my_b___2->x = (short)0;
          }
#line 639
          if ((int )my_b___2->y < 0) {
#line 639
            my_b___2->y = (short)0;
          }
#line 639
          if ((int )my_b___2->x + (int )my_b___2->w > 640) {
#line 639
            my_b___2->w = (unsigned short )(640 - (int )my_b___2->x);
          }
#line 639
          if ((int )my_b___2->y + (int )my_b___2->h > 480) {
#line 639
            my_b___2->h = (unsigned short )(480 - (int )my_b___2->y);
          }
        }
#line 639
        if (my_d___2) {
#line 639
          if ((int )my_d___2->x < 0) {
#line 639
            my_d___2->x = (short)0;
          }
#line 639
          if ((int )my_d___2->y < 0) {
#line 639
            my_d___2->y = (short)0;
          }
#line 639
          if ((int )my_d___2->x + (int )my_d___2->w > 640) {
#line 639
            my_d___2->w = (unsigned short )(640 - (int )my_d___2->x);
          }
#line 639
          if ((int )my_d___2->y + (int )my_d___2->h > 480) {
#line 639
            my_d___2->h = (unsigned short )(480 - (int )my_d___2->y);
          }
        }
#line 639
        tmp___2 = SDL_UpperBlit(widget_layer, my_b___2, screen, my_d___2);
#line 639
        if (! (tmp___2 == (int __attribute__((__visibility__("default")))  )0)) {
#line 639
          Panic("draw_pause", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 640);
        }
#line 641
        SDL_FillRect(widget_layer, & layout.grid[i], int_solid_black);
#line 643
        my_b___3 = & layout.next_piece[i];
#line 643
        my_d___3 = & layout.next_piece[i];
#line 643
        if (my_b___3) {
#line 643
          if ((int )my_b___3->x < 0) {
#line 643
            my_b___3->x = (short)0;
          }
#line 643
          if ((int )my_b___3->y < 0) {
#line 643
            my_b___3->y = (short)0;
          }
#line 643
          if ((int )my_b___3->x + (int )my_b___3->w > 640) {
#line 643
            my_b___3->w = (unsigned short )(640 - (int )my_b___3->x);
          }
#line 643
          if ((int )my_b___3->y + (int )my_b___3->h > 480) {
#line 643
            my_b___3->h = (unsigned short )(480 - (int )my_b___3->y);
          }
        }
#line 643
        if (my_d___3) {
#line 643
          if ((int )my_d___3->x < 0) {
#line 643
            my_d___3->x = (short)0;
          }
#line 643
          if ((int )my_d___3->y < 0) {
#line 643
            my_d___3->y = (short)0;
          }
#line 643
          if ((int )my_d___3->x + (int )my_d___3->w > 640) {
#line 643
            my_d___3->w = (unsigned short )(640 - (int )my_d___3->x);
          }
#line 643
          if ((int )my_d___3->y + (int )my_d___3->h > 480) {
#line 643
            my_d___3->h = (unsigned short )(480 - (int )my_d___3->y);
          }
        }
#line 643
        tmp___3 = SDL_UpperBlit(widget_layer, my_b___3, screen, my_d___3);
#line 643
        if (! (tmp___3 == (int __attribute__((__visibility__("default")))  )0)) {
#line 643
          Panic("draw_pause", "display.c", (char *)"Failed assertion \"%s\" on line %d",
                "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 644);
        }
#line 645
        SDL_FillRect(widget_layer, & layout.next_piece[i], int_solid_black);
      }
#line 637
      i ++;
    }
  }
#line 648
  return;
}
}
#line 657
void draw_clock(int seconds ) ;
#line 657 "display.c"
static int old_seconds  =    -111;
#line 658 "display.c"
static SDL_Surface *digit[12]  ;
#line 660 "display.c"
static int w  =    -1;
#line 660 "display.c"
static int h  =    -1;
#line 654 "display.c"
void draw_clock(int seconds ) 
{ char buf[16] ;
  int i ;
  int c ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___0 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  SDL_Surface *to_blit ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___6 ;
  SDL_Rect *my_b___1 ;
  SDL_Rect *my_d___1 ;
  int __attribute__((__visibility__("default")))  tmp___7 ;
  SDL_Rect *my_c ;

  {
#line 663
  if (seconds == old_seconds) {
#line 663
    return;
  } else {
#line 663
    if ((int )gametype == 7) {
#line 663
      return;
    }
  }
#line 665
  if (old_seconds == -111) {
#line 668
    i = 0;
#line 668
    while (i < 10) {
#line 669
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", i);
#line 670
      tmp = TTF_RenderText_Blended(font, (char const   *)(buf), color_blue);
#line 670
      digit[i] = (SDL_Surface *)tmp;
#line 668
      i ++;
    }
#line 672
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )":");
#line 672
    tmp___0 = TTF_RenderText_Blended(font, (char const   *)(buf), color_red);
#line 672
    digit[10] = (SDL_Surface *)tmp___0;
#line 673
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"-");
#line 673
    tmp___1 = TTF_RenderText_Blended(font, (char const   *)(buf), color_red);
#line 673
    digit[11] = (SDL_Surface *)tmp___1;
#line 675
    i = 0;
#line 675
    while (i < 12) {
#line 676
      if (! digit[i]) {
#line 676
        Panic("draw_clock", "display.c", (char *)"Failed assertion \"%s\" on line %d",
              "digit[i]", 676);
      }
#line 679
      if ((digit[i])->w > w) {
#line 679
        w = (digit[i])->w;
      }
#line 680
      if ((digit[i])->h > h) {
#line 680
        h = (digit[i])->h;
      }
#line 675
      i ++;
    }
  }
#line 684
  old_seconds = seconds;
#line 686
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d:%02d", seconds / 60,
          seconds % 60);
#line 688
  c = (int )layout.time.x;
#line 689
  layout.time.w = (unsigned short )(w * 5);
#line 690
  layout.time.h = (unsigned short )h;
#line 692
  SDL_FillRect(widget_layer, & layout.time, int_solid_black);
#line 694
  tmp___2 = strlen((char const   *)(buf));
#line 694
  if (tmp___2 > 5U) {
#line 695
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"----");
  }
#line 697
  tmp___4 = strlen((char const   *)(buf));
#line 697
  if (tmp___4 < 5U) {
#line 698
    tmp___3 = strlen((char const   *)(buf));
#line 698
    layout.time.x = (short )((size_t )layout.time.x + ((5U - tmp___3) * (size_t )w) / 2U);
  }
#line 701
  i = 0;
#line 701
  while (buf[i]) {
#line 704
    if ((int )buf[i] >= 48) {
#line 704
      if ((int )buf[i] <= 57) {
#line 705
        to_blit = digit[(int )buf[i] - 48];
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 706
      if ((int )buf[i] == 58) {
#line 707
        to_blit = digit[10];
      } else {
#line 708
        if ((int )buf[i] == 45) {
#line 709
          to_blit = digit[11];
        } else {
#line 710
          Panic("draw_clock", "display.c", (char *)"unknown character in clock string [%s]",
                buf);
        }
      }
    }
#line 713
    if (w > to_blit->w) {
#line 713
      layout.time.x = (short )((int )layout.time.x + (w - to_blit->w) / 2);
    }
#line 714
    layout.time.w = (unsigned short )to_blit->w;
#line 715
    layout.time.h = (unsigned short )to_blit->h;
#line 720
    my_b = (SDL_Rect *)((void *)0);
#line 720
    my_d = & layout.time;
#line 720
    if (my_b) {
#line 720
      if ((int )my_b->x < 0) {
#line 720
        my_b->x = (short)0;
      }
#line 720
      if ((int )my_b->y < 0) {
#line 720
        my_b->y = (short)0;
      }
#line 720
      if ((int )my_b->x + (int )my_b->w > 640) {
#line 720
        my_b->w = (unsigned short )(640 - (int )my_b->x);
      }
#line 720
      if ((int )my_b->y + (int )my_b->h > 480) {
#line 720
        my_b->h = (unsigned short )(480 - (int )my_b->y);
      }
    }
#line 720
    if (my_d) {
#line 720
      if ((int )my_d->x < 0) {
#line 720
        my_d->x = (short)0;
      }
#line 720
      if ((int )my_d->y < 0) {
#line 720
        my_d->y = (short)0;
      }
#line 720
      if ((int )my_d->x + (int )my_d->w > 640) {
#line 720
        my_d->w = (unsigned short )(640 - (int )my_d->x);
      }
#line 720
      if ((int )my_d->y + (int )my_d->h > 480) {
#line 720
        my_d->h = (unsigned short )(480 - (int )my_d->y);
      }
    }
#line 720
    tmp___5 = SDL_UpperBlit(to_blit, my_b, widget_layer, my_d);
#line 720
    if (! (tmp___5 == (int __attribute__((__visibility__("default")))  )0)) {
#line 720
      Panic("draw_clock", "display.c", (char *)"Failed assertion \"%s\" on line %d",
            "SDL_UpperBlit(to_blit,my_b,widget_layer,my_d) == 0", 720);
    }
#line 721
    if (w > to_blit->w) {
#line 721
      layout.time.x = (short )((int )layout.time.x - (w - to_blit->w) / 2);
    }
#line 722
    layout.time.x = (short )((int )layout.time.x + w);
#line 701
    i ++;
  }
#line 725
  layout.time.x = (short )c;
#line 727
  layout.time.w = (unsigned short )(w * 5);
#line 728
  layout.time.h = (unsigned short )h;
#line 729
  my_b___0 = & layout.time;
#line 729
  my_d___0 = & layout.time;
#line 729
  if (my_b___0) {
#line 729
    if ((int )my_b___0->x < 0) {
#line 729
      my_b___0->x = (short)0;
    }
#line 729
    if ((int )my_b___0->y < 0) {
#line 729
      my_b___0->y = (short)0;
    }
#line 729
    if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 729
      my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
    }
#line 729
    if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 729
      my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
    }
  }
#line 729
  if (my_d___0) {
#line 729
    if ((int )my_d___0->x < 0) {
#line 729
      my_d___0->x = (short)0;
    }
#line 729
    if ((int )my_d___0->y < 0) {
#line 729
      my_d___0->y = (short)0;
    }
#line 729
    if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 729
      my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
    }
#line 729
    if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 729
      my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
    }
  }
#line 729
  tmp___6 = SDL_UpperBlit(flame_layer, my_b___0, screen, my_d___0);
#line 729
  if (! (tmp___6 == (int __attribute__((__visibility__("default")))  )0)) {
#line 729
    Panic("draw_clock", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(flame_layer,my_b,screen,my_d) == 0", 729);
  }
#line 730
  my_b___1 = & layout.time;
#line 730
  my_d___1 = & layout.time;
#line 730
  if (my_b___1) {
#line 730
    if ((int )my_b___1->x < 0) {
#line 730
      my_b___1->x = (short)0;
    }
#line 730
    if ((int )my_b___1->y < 0) {
#line 730
      my_b___1->y = (short)0;
    }
#line 730
    if ((int )my_b___1->x + (int )my_b___1->w > 640) {
#line 730
      my_b___1->w = (unsigned short )(640 - (int )my_b___1->x);
    }
#line 730
    if ((int )my_b___1->y + (int )my_b___1->h > 480) {
#line 730
      my_b___1->h = (unsigned short )(480 - (int )my_b___1->y);
    }
  }
#line 730
  if (my_d___1) {
#line 730
    if ((int )my_d___1->x < 0) {
#line 730
      my_d___1->x = (short)0;
    }
#line 730
    if ((int )my_d___1->y < 0) {
#line 730
      my_d___1->y = (short)0;
    }
#line 730
    if ((int )my_d___1->x + (int )my_d___1->w > 640) {
#line 730
      my_d___1->w = (unsigned short )(640 - (int )my_d___1->x);
    }
#line 730
    if ((int )my_d___1->y + (int )my_d___1->h > 480) {
#line 730
      my_d___1->h = (unsigned short )(480 - (int )my_d___1->y);
    }
  }
#line 730
  tmp___7 = SDL_UpperBlit(widget_layer, my_b___1, screen, my_d___1);
#line 730
  if (! (tmp___7 == (int __attribute__((__visibility__("default")))  )0)) {
#line 730
    Panic("draw_clock", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 730);
  }
#line 731
  my_c = & layout.time;
#line 731
  if (! my_c) {
#line 731
    Panic("draw_clock", "display.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 731);
  }
#line 731
  if (my_c) {
#line 731
    if ((int )my_c->x < 0) {
#line 731
      my_c->x = (short)0;
    }
#line 731
    if ((int )my_c->y < 0) {
#line 731
      my_c->y = (short)0;
    }
#line 731
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 731
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 731
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 731
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 731
  SDL_UpdateRects(screen, 1, & layout.time);
#line 733
  return;
}
}
#line 739 "display.c"
void draw_score(SDL_Surface *screen___0 , int i ) 
{ char buf[256] ;

  {
#line 744
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", Score[i]);
#line 745
  draw_string(buf, color_red, (int )layout.score[i].x, (int )layout.score[i].y, (((1 << 2) | (1 << 4)) | (1 << 1)) | (1 << 3));
#line 748
  return;
}
}
#line 757 "display.c"
void draw_next_piece(SDL_Surface *screen___0 , piece_style *ps , color_style *cs ,
                     play_piece *cp , play_piece *np , int P ) 
{ int cp_right ;
  int cp_down ;
  int np_right ;
  int np_down ;

  {
#line 761
  if ((int )gametype != 7) {
#line 763
    cp_right = 5 - (cp->base)->dim;
#line 764
    cp_down = 5 - (cp->base)->dim;
#line 765
    np_right = 5 - (np->base)->dim;
#line 766
    np_down = 5 - (np->base)->dim;
#line 768
    draw_play_piece(screen___0, cs, cp, (int )layout.next_piece[P].x + (cp_right * cs->w) / 2,
                    (int )layout.next_piece[P].y + (cp_down * cs->w) / 2, 0, np, (int )layout.next_piece[P].x + (np_right * cs->w) / 2,
                    (int )layout.next_piece[P].y + (np_down * cs->w) / 2, 0);
  }
#line 776
  return;
}
}
#line 1 "event.o"
#pragma merger(0,"/tmp/cil-x7Xyd1ls.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 862 "/usr/include/SDL/SDL_video.h"
extern int __attribute__((__visibility__("default")))  SDL_WM_ToggleFullScreen(SDL_Surface *surface ) ;
#line 6 ".protos/piece.pro"
play_piece generate_piece(piece_style *ps , color_style *cs , unsigned int seq ) ;
#line 6 ".protos/grid.pro"
void add_garbage(Grid *g___0 ) ;
#line 8
void draw_grid(SDL_Surface *screen___0 , color_style *cs , Grid *g___0 , int draw ) ;
#line 10
void draw_falling(SDL_Surface *screen___0 , int blockWidth , Grid *g___0 , int offset ) ;
#line 2 ".protos/sound.pro"
void play_sound_unless_already_playing(sound_style *ss , int which , int delay ) ;
#line 4
void stop_playing_sound(sound_style *ss , int which ) ;
#line 6
void play_sound(sound_style *ss , int which , int delay ) ;
#line 8
void stop_all_playing(void) ;
#line 35 "event.c"
struct state_struct State[2]  ;
#line 66 "event.c"
struct pos_struct pos[2]  ;
#line 76 "event.c"
Grid distract_grid[2]  ;
#line 83 "event.c"
void paste_on_board(play_piece *pp , int col , int row , int rot , Grid *g___0 ) 
{ int i ;
  int j ;
  int c ;
  int t_x ;
  int t_y ;

  {
#line 88
  j = 0;
#line 88
  while (j < (pp->base)->dim) {
#line 89
    i = 0;
#line 89
    while (i < (pp->base)->dim) {
#line 90
      c = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + i));
#line 90
      if (c) {
#line 91
        t_x = i + col;
#line 92
        t_y = j + row;
#line 93
        if (t_x < 0) {
#line 94
          printf((char const   * __restrict  )"%-14.14s| ", "paste_on_board");
#line 94
          printf((char const   * __restrict  )"Serious consistency failure: dropping pieces.\n");
#line 94
          fflush(stdout);
          goto __Cont;
        } else {
#line 93
          if (t_y < 0) {
#line 94
            printf((char const   * __restrict  )"%-14.14s| ", "paste_on_board");
#line 94
            printf((char const   * __restrict  )"Serious consistency failure: dropping pieces.\n");
#line 94
            fflush(stdout);
            goto __Cont;
          } else {
#line 93
            if (t_x >= g___0->w) {
#line 94
              printf((char const   * __restrict  )"%-14.14s| ", "paste_on_board");
#line 94
              printf((char const   * __restrict  )"Serious consistency failure: dropping pieces.\n");
#line 94
              fflush(stdout);
              goto __Cont;
            } else {
#line 93
              if (t_y >= g___0->h) {
#line 94
                printf((char const   * __restrict  )"%-14.14s| ", "paste_on_board");
#line 94
                printf((char const   * __restrict  )"Serious consistency failure: dropping pieces.\n");
#line 94
                fflush(stdout);
                goto __Cont;
              }
            }
          }
        }
#line 97
        *(g___0->changed + (t_x + t_y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (t_x + t_y * g___0->w)) | ((int )*(g___0->contents + (t_x + t_y * g___0->w)) != (int )pp->colormap[c]));
#line 97
        *(g___0->contents + (t_x + t_y * g___0->w)) = pp->colormap[c];
#line 98
        *(g___0->changed + (t_x + t_y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (t_x + t_y * g___0->w)) | ((int )*(g___0->fall + (t_x + t_y * g___0->w)) != 1));
#line 98
        *(g___0->fall + (t_x + t_y * g___0->w)) = (unsigned char)1;
#line 99
        if (t_x > 0) {
#line 99
          *(g___0->changed + ((t_x - 1) + t_y * g___0->w)) = (unsigned char)1;
        }
#line 100
        if (t_y > 0) {
#line 100
          *(g___0->changed + (t_x + (t_y - 1) * g___0->w)) = (unsigned char)1;
        }
#line 101
        if (t_x < g___0->w - 1) {
#line 101
          *(g___0->changed + ((t_x + 1) + t_y * g___0->w)) = (unsigned char)1;
        }
#line 102
        if (t_y < g___0->h - 1) {
#line 102
          *(g___0->changed + (t_x + (t_y + 1) * g___0->w)) = (unsigned char)1;
        }
      }
      __Cont: /* CIL Label */ 
#line 89
      i ++;
    }
#line 88
    j ++;
  }
#line 104
  return;
}
}
#line 112 "event.c"
static void screen_to_exact_grid_coords(Grid *g___0 , int blockWidth , int screen_x ,
                                        int screen_y , int *row , int *col ) 
{ 

  {
#line 116
  screen_x -= (int )g___0->board.x;
#line 117
  screen_y -= (int )g___0->board.y;
#line 119
  if (! (screen_x % blockWidth == 0)) {
#line 119
    Panic("screen_to_exact_grid_coords", "event.c", (char *)"Failed assertion \"%s\" on line %d",
          "screen_x % blockWidth == 0", 119);
  }
#line 120
  if (! (screen_y % blockWidth == 0)) {
#line 120
    Panic("screen_to_exact_grid_coords", "event.c", (char *)"Failed assertion \"%s\" on line %d",
          "screen_y % blockWidth == 0", 120);
  }
#line 122
  *row = screen_y / blockWidth;
#line 123
  *col = screen_x / blockWidth;
#line 125
  return;
}
}
#line 132 "event.c"
void screen_to_grid_coords(Grid *g___0 , int blockWidth , int screen_x , int screen_y ,
                           int *row , int *col ) 
{ 

  {
#line 136
  screen_x -= (int )g___0->board.x;
#line 137
  screen_y -= (int )g___0->board.y;
#line 138
  if (screen_x < 0) {
#line 138
    screen_x -= 19;
  }
#line 139
  if (screen_y < 0) {
#line 139
    screen_y -= 19;
  }
#line 141
  *row = screen_y / blockWidth;
#line 142
  *col = screen_x / blockWidth;
#line 144
  return;
}
}
#line 155 "event.c"
int valid_position(play_piece *pp , int col , int row , int rot , Grid *g___0 ) 
{ int i ;
  int j ;
  int t_x ;
  int t_y ;

  {
#line 168
  j = 0;
#line 168
  while (j < (pp->base)->dim) {
#line 169
    i = 0;
#line 169
    while (i < (pp->base)->dim) {
#line 170
      if (*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + i))) {
#line 171
        t_x = i + col;
#line 172
        t_y = j + row;
#line 173
        if (t_x < 0) {
#line 174
          return (0);
        } else {
#line 173
          if (t_y < 0) {
#line 174
            return (0);
          } else {
#line 173
            if (t_x >= g___0->w) {
#line 174
              return (0);
            } else {
#line 173
              if (t_y >= g___0->h) {
#line 174
                return (0);
              }
            }
          }
        }
#line 175
        if (*(g___0->contents + (t_x + t_y * g___0->w))) {
#line 175
          return (0);
        }
      }
#line 169
      i ++;
    }
#line 168
    j ++;
  }
#line 177
  return (1);
}
}
#line 190 "event.c"
int valid_screen_position(play_piece *pp , int blockWidth , Grid *g___0 , int rot ,
                          int screen_x , int screen_y ) 
{ int row ;
  int row2 ;
  int col ;
  int tmp ;
  int tmp___0 ;

  {
#line 196
  screen_to_grid_coords(g___0, blockWidth, screen_x, screen_y, & row, & col);
#line 198
  tmp = valid_position(pp, col, row, rot, g___0);
#line 198
  if (! tmp) {
#line 199
    return (0);
  }
#line 201
  screen_to_grid_coords(g___0, blockWidth, screen_x, screen_y + 19, & row2, & col);
#line 203
  if (row == row2) {
#line 203
    return (1);
  } else {
#line 204
    tmp___0 = valid_position(pp, col, row2, rot, g___0);
#line 204
    return (tmp___0);
  }
}
}
#line 212 "event.c"
int tetris_event(int *delay , int count , SDL_Surface *screen___0 , piece_style *ps ,
                 color_style *cs , sound_style *ss , Grid *g___0 , int level , int fall_event_interval ,
                 int sock , int draw , int *blank , int *garbage , int P ) 
{ int i ;
  int x ;
  int y ;
  char msg ;
  char msg___0 ;
  char msg___1 ;
  int i___0 ;
  char msg___2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 217
  if (count == 1) {
#line 220
    State[P].check_result = check_tetris(g___0);
#line 221
    State[P].num_lines_cleared += State[P].check_result;
#line 223
    if (State[P].check_result >= 3) {
#line 224
      play_sound(ss, 2, 256);
    } else {
#line 225
      i = 0;
#line 225
      while (i < State[P].check_result) {
#line 226
        play_sound(ss, 1, 256 + 6144 * i);
#line 225
        i ++;
      }
    }
#line 228
    *delay = 1;
#line 229
    return (2);
  } else {
#line 231
    if (count == 2) {
#line 234
      if (sock) {
#line 235
        msg = (char )'c';
#line 236
        send(sock, (void const   *)(& msg), 1U, 0);
#line 237
        send(sock, (void const   *)(g___0 + 0)->contents, (sizeof(*((g___0 + 0)->contents)) * (unsigned int )(g___0 + 0)->h) * (unsigned int )(g___0 + 0)->w,
             0);
      }
#line 241
      draw_grid(screen___0, cs, g___0 + 0, draw);
#line 246
      memcpy((void * __restrict  )g___0->temp, (void const   * __restrict  )g___0->fall,
             (unsigned int )(g___0->w * g___0->h) * sizeof(*(g___0->temp)));
#line 247
      y = g___0->h - 1;
#line 247
      while (y >= 0) {
#line 248
        x = g___0->w - 1;
#line 248
        while (x >= 0) {
#line 249
          *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->fall + (x + y * g___0->w)) != 254));
#line 249
          *(g___0->fall + (x + y * g___0->w)) = (unsigned char)254;
#line 248
          x --;
        }
#line 247
        y --;
      }
#line 250
      run_gravity(g___0 + 0);
#line 251
      memset((void *)g___0->changed, 0, (unsigned int )(g___0->h * g___0->w) * sizeof(*(g___0->changed)));
#line 252
      y = g___0->h - 1;
#line 252
      while (y >= 0) {
#line 253
        x = g___0->w - 1;
#line 253
        while (x >= 0) {
#line 254
          if ((int )*(g___0->temp + (x + y * g___0->w)) != (int )*(g___0->fall + (x + y * g___0->w))) {
#line 255
            *(g___0->changed + (x + y * g___0->w)) = (unsigned char)1;
#line 256
            if (x > 0) {
#line 256
              *(g___0->changed + ((x - 1) + y * g___0->w)) = (unsigned char)1;
            }
#line 257
            if (y > 0) {
#line 257
              *(g___0->changed + (x + (y - 1) * g___0->w)) = (unsigned char)1;
            }
#line 258
            if (x < g___0->w - 1) {
#line 258
              *(g___0->changed + ((x + 1) + y * g___0->w)) = (unsigned char)1;
            }
#line 259
            if (y < g___0->h - 1) {
#line 259
              *(g___0->changed + (x + (y + 1) * g___0->w)) = (unsigned char)1;
            }
          }
#line 253
          x --;
        }
#line 252
        y --;
      }
#line 264
      draw_grid(screen___0, cs, g___0 + 0, draw);
#line 266
      tmp = determine_falling(g___0 + 0);
#line 266
      if (tmp) {
#line 267
        *delay = 1;
#line 268
        return (3);
      } else {
#line 270
        Score[P] += (State[P].num_lines_cleared * State[P].num_lines_cleared) * level;
#line 272
        if (sock) {
#line 273
          msg___0 = (char )'s';
#line 274
          send(sock, (void const   *)(& msg___0), 1U, 0);
#line 275
          send(sock, (void const   *)((char *)(& Score[P])), sizeof(Score[P]), 0);
#line 276
          if (State[P].num_lines_cleared >= 5) {
#line 277
            msg___1 = (char )'g';
#line 278
            send(sock, (void const   *)(& msg___1), 1U, 0);
#line 279
            State[P].num_lines_cleared -= 4;
          }
#line 281
          if (State[P].num_lines_cleared >= 3) {
#line 283
            i___0 = 3;
#line 283
            while (i___0 <= State[P].num_lines_cleared) {
#line 284
              msg___2 = (char )'b';
#line 285
              send(sock, (void const   *)(& msg___2), 1U, 0);
#line 283
              i___0 ++;
            }
          }
        } else {
#line 289
          if (State[P].num_lines_cleared >= 5) {
#line 290
            *garbage = 1;
#line 291
            State[P].num_lines_cleared -= 4;
          }
#line 293
          if (State[P].num_lines_cleared >= 3) {
#line 294
            *blank = State[P].num_lines_cleared - 2;
          }
        }
#line 297
        draw_score(screen___0, P);
#line 298
        State[P].num_lines_cleared = 0;
#line 299
        return (0);
      }
    } else {
#line 301
      if (count >= 3) {
#line 301
        if (count <= 22) {
#line 302
          if (draw) {
#line 303
            draw_falling(screen___0, cs->w, g___0 + 0, count - 2);
          }
#line 308
          *delay = 4;
#line 309
          return (count + 1);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 310
        if (count == 23) {
#line 311
          fall_down(g___0);
#line 312
          draw_grid(screen___0, cs, g___0, draw);
#line 313
          tmp___0 = run_gravity(g___0);
#line 313
          if (tmp___0) {
#line 314
            play_sound(ss, 0, 0);
          }
#line 318
          *delay = 4;
#line 319
          tmp___1 = determine_falling(g___0 + 0);
#line 319
          if (tmp___1) {
#line 320
            return (3);
          }
#line 321
          tmp___2 = check_tetris(g___0);
#line 321
          if (tmp___2) {
#line 322
            return (1);
          } else {
#line 324
            return (2);
          }
        }
      }
    }
  }
#line 326
  return (0);
}
}
#line 333 "event.c"
static void do_blank(SDL_Surface *screen___0 , sound_style **ss , Grid *g___0 , int P ) 
{ Uint32 __attribute__((__visibility__("default")))  tmp ;
  Uint32 __attribute__((__visibility__("default")))  tmp___0 ;
  SDL_Rect *my_c ;
  int i ;
  int j ;

  {
#line 336
  play_sound(*(ss + P), 5, 1);
#line 337
  if (State[P].draw) {
#line 338
    tmp = SDL_GetTicks();
#line 338
    State[P].next_draw = (unsigned int )(tmp + (Uint32 __attribute__((__visibility__("default")))  )1000);
#line 339
    State[P].draw_timeout = 1000U;
#line 340
    tmp___0 = SDL_MapRGB((SDL_PixelFormat const   *)screen___0->format, (unsigned char)32,
                         (unsigned char)32, (unsigned char)32);
#line 340
    SDL_FillRect(screen___0, & (g___0 + P)->board, (unsigned int )tmp___0);
#line 342
    my_c = & (g___0 + P)->board;
#line 342
    if (! my_c) {
#line 342
      Panic("do_blank", "event.c", (char *)"Failed assertion \"%s\" on line %d", "my_c",
            342);
    }
#line 342
    if (my_c) {
#line 342
      if ((int )my_c->x < 0) {
#line 342
        my_c->x = (short)0;
      }
#line 342
      if ((int )my_c->y < 0) {
#line 342
        my_c->y = (short)0;
      }
#line 342
      if ((int )my_c->x + (int )my_c->w > 640) {
#line 342
        my_c->w = (unsigned short )(640 - (int )my_c->x);
      }
#line 342
      if ((int )my_c->y + (int )my_c->h > 480) {
#line 342
        my_c->h = (unsigned short )(480 - (int )my_c->y);
      }
    }
#line 342
    SDL_UpdateRects(screen___0, 1, & (g___0 + P)->board);
  } else {
#line 344
    State[P].next_draw += 1000U;
#line 345
    State[P].draw_timeout += 1000U;
  }
#line 348
  j = 0;
#line 348
  while (j < (g___0 + 0)->h) {
#line 349
    i = 0;
#line 349
    while (i < (g___0 + 0)->w) {
#line 350
      *(distract_grid[P].changed + (i + j * distract_grid[P].w)) = (unsigned char)0;
#line 349
      i ++;
    }
#line 348
    j ++;
  }
#line 352
  State[P].draw = 0;
#line 353
  return;
}
}
#line 359 "event.c"
static void bomb_fun(int x , int y , Grid *g___0 ) 
{ 

  {
#line 362
  if (x < 0) {
#line 363
    return;
  } else {
#line 362
    if (y < 0) {
#line 363
      return;
    } else {
#line 362
      if (x >= g___0->w) {
#line 363
        return;
      } else {
#line 362
        if (y >= g___0->h) {
#line 363
          return;
        }
      }
    }
  }
#line 364
  *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->contents + (x + y * g___0->w)) != 255));
#line 364
  *(g___0->contents + (x + y * g___0->w)) = (unsigned char)255;
#line 365
  return;
}
}
#line 367 "event.c"
static int most_common  =    1;
#line 373 "event.c"
static void colorkill_recurse(int x , int y , Grid *g___0 , int target_color ) 
{ 

  {
#line 376
  if (x < 0) {
#line 377
    return;
  } else {
#line 376
    if (y < 0) {
#line 377
      return;
    } else {
#line 376
      if (x >= g___0->w) {
#line 377
        return;
      } else {
#line 376
        if (y >= g___0->h) {
#line 377
          return;
        }
      }
    }
  }
#line 378
  *(g___0->changed + (x + y * g___0->w)) = (unsigned char)1;
#line 379
  if ((int )*(g___0->contents + (x + y * g___0->w)) != target_color) {
#line 379
    return;
  }
#line 380
  *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->contents + (x + y * g___0->w)) != 255));
#line 380
  *(g___0->contents + (x + y * g___0->w)) = (unsigned char)255;
#line 381
  colorkill_recurse(x - 1, y, g___0, target_color);
#line 382
  colorkill_recurse(x + 1, y, g___0, target_color);
#line 383
  colorkill_recurse(x, y - 1, g___0, target_color);
#line 384
  colorkill_recurse(x, y + 1, g___0, target_color);
#line 385
  return;
}
}
#line 387 "event.c"
static void colorkill_fun(int x , int y , Grid *g___0 ) 
{ int c ;

  {
#line 391
  if (x < 0) {
#line 392
    return;
  } else {
#line 391
    if (y < 0) {
#line 392
      return;
    } else {
#line 391
      if (x >= g___0->w) {
#line 392
        return;
      } else {
#line 391
        if (y >= g___0->h) {
#line 392
          return;
        }
      }
    }
  }
#line 393
  *(g___0->changed + (x + y * g___0->w)) = (unsigned char)1;
#line 394
  c = (int )*(g___0->contents + (x + y * g___0->w));
#line 395
  if (c <= 1) {
#line 395
    return;
  } else {
#line 395
    if (c == 255) {
#line 395
      return;
    }
  }
#line 396
  *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->contents + (x + y * g___0->w)) != 255));
#line 396
  *(g___0->contents + (x + y * g___0->w)) = (unsigned char)255;
#line 397
  colorkill_recurse(x - 1, y, g___0, c);
#line 398
  colorkill_recurse(x + 1, y, g___0, c);
#line 399
  colorkill_recurse(x, y - 1, g___0, c);
#line 400
  colorkill_recurse(x, y + 1, g___0, c);
#line 401
  return;
}
}
#line 407 "event.c"
static void repaint_fun(int x , int y , Grid *g___0 ) 
{ int c ;

  {
#line 411
  if (x < 0) {
#line 412
    return;
  } else {
#line 411
    if (y < 0) {
#line 412
      return;
    } else {
#line 411
      if (x >= g___0->w) {
#line 412
        return;
      } else {
#line 411
        if (y >= g___0->h) {
#line 412
          return;
        }
      }
    }
  }
#line 413
  *(g___0->changed + (x + y * g___0->w)) = (unsigned char)1;
#line 414
  c = (int )*(g___0->contents + (x + y * g___0->w));
#line 415
  if (c <= 1) {
#line 415
    return;
  } else {
#line 415
    if (c == most_common) {
#line 415
      return;
    }
  }
#line 416
  *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->contents + (x + y * g___0->w)) != most_common));
#line 416
  *(g___0->contents + (x + y * g___0->w)) = (unsigned char )most_common;
#line 417
  repaint_fun(x - 1, y, g___0);
#line 418
  repaint_fun(x + 1, y, g___0);
#line 419
  repaint_fun(x, y - 1, g___0);
#line 420
  repaint_fun(x, y + 1, g___0);
#line 421
  return;
}
}
#line 428 "event.c"
static void push_down(play_piece *pp , int col , int row , int rot , Grid *g___0 ,
                      void (*fun)(int  , int  , Grid * ) ) 
{ int i ;
  int j ;
  int c ;
  int place_y ;
  int look_y ;
  int t_x ;
  int t_y ;

  {
#line 435
  j = 0;
#line 435
  while (j < (pp->base)->dim) {
#line 436
    i = 0;
#line 436
    while (i < (pp->base)->dim) {
#line 437
      c = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + i));
#line 437
      if (c) {
#line 438
        t_x = i + col;
#line 439
        t_y = j + row;
#line 440
        if (t_x < 0) {
          goto __Cont;
        } else {
#line 440
          if (t_y < 0) {
            goto __Cont;
          } else {
#line 440
            if (t_x >= g___0->w) {
              goto __Cont;
            } else {
#line 440
              if (t_y >= g___0->h) {
                goto __Cont;
              }
            }
          }
        }
#line 443
        *(g___0->changed + (t_x + t_y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (t_x + t_y * g___0->w)) | ((int )*(g___0->contents + (t_x + t_y * g___0->w)) != 255));
#line 443
        *(g___0->contents + (t_x + t_y * g___0->w)) = (unsigned char)255;
#line 444
        look_y = t_y + 1;
#line 445
        if (look_y >= g___0->h) {
          goto __Cont;
        }
#line 446
        if (! *(g___0->contents + (t_x + look_y * g___0->w))) {
          goto __Cont;
        }
#line 448
        place_y = g___0->h - 1;
#line 448
        while (1) {
#line 448
          if (place_y > look_y) {
#line 448
            if (! ((int )*(g___0->contents + (t_x + place_y * g___0->w)) != 0)) {
#line 448
              break;
            }
          } else {
#line 448
            break;
          }
#line 448
          place_y --;
        }
#line 453
        if (place_y == look_y) {
          goto __Cont;
        }
#line 455
        if (place_y < 0) {
          goto __Cont;
        } else {
#line 455
          if (place_y >= g___0->h) {
            goto __Cont;
          }
        }
#line 457
        if (look_y < 0) {
          goto __Cont;
        } else {
#line 457
          if (look_y >= g___0->h) {
            goto __Cont;
          }
        }
#line 459
        *(g___0->changed + (t_x + place_y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (t_x + place_y * g___0->w)) | ((int )*(g___0->contents + (t_x + place_y * g___0->w)) != (int )*(g___0->contents + (t_x + look_y * g___0->w))));
#line 459
        *(g___0->contents + (t_x + place_y * g___0->w)) = *(g___0->contents + (t_x + look_y * g___0->w));
#line 460
        *(g___0->changed + (t_x + look_y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (t_x + look_y * g___0->w)) | ((int )*(g___0->contents + (t_x + look_y * g___0->w)) != 255));
#line 460
        *(g___0->contents + (t_x + look_y * g___0->w)) = (unsigned char)255;
      }
      __Cont: /* CIL Label */ 
#line 436
      i ++;
    }
#line 435
    j ++;
  }
#line 462
  return;
}
}
#line 469 "event.c"
static void find_on_board(play_piece *pp , int col , int row , int rot , Grid *g___0 ,
                          void (*fun)(int  , int  , Grid * ) ) 
{ int i ;
  int j ;
  int c ;
  int t_x ;
  int t_y ;
  int t_x___0 ;
  int t_y___0 ;

  {
#line 475
  j = 0;
#line 475
  while (j < (pp->base)->dim) {
#line 476
    i = 0;
#line 476
    while (i < (pp->base)->dim) {
#line 477
      c = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + i));
#line 477
      if (c) {
#line 478
        t_x = i + col;
#line 479
        t_y = j + row;
#line 480
        if (t_x < 0) {
          goto __Cont;
        } else {
#line 480
          if (t_y < 0) {
            goto __Cont;
          } else {
#line 480
            if (t_x >= g___0->w) {
              goto __Cont;
            } else {
#line 480
              if (t_y >= g___0->h) {
                goto __Cont;
              }
            }
          }
        }
#line 483
        *(g___0->changed + (t_x + t_y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (t_x + t_y * g___0->w)) | ((int )*(g___0->contents + (t_x + t_y * g___0->w)) != 255));
#line 483
        *(g___0->contents + (t_x + t_y * g___0->w)) = (unsigned char)255;
      }
      __Cont: /* CIL Label */ 
#line 476
      i ++;
    }
#line 475
    j ++;
  }
#line 486
  j = 0;
#line 486
  while (j < (pp->base)->dim) {
#line 487
    i = 0;
#line 487
    while (i < (pp->base)->dim) {
#line 488
      c = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + i));
#line 488
      if (c) {
#line 489
        t_x___0 = i + col;
#line 490
        t_y___0 = j + row;
#line 491
        if (t_x___0 < 0) {
          goto __Cont___0;
        } else {
#line 491
          if (t_y___0 < 0) {
            goto __Cont___0;
          } else {
#line 491
            if (t_x___0 >= g___0->w) {
              goto __Cont___0;
            } else {
#line 491
              if (t_y___0 >= g___0->h) {
                goto __Cont___0;
              }
            }
          }
        }
#line 494
        (*fun)(t_x___0 - 1, t_y___0, g___0);
#line 495
        (*fun)(t_x___0 + 1, t_y___0, g___0);
#line 496
        (*fun)(t_x___0, t_y___0 - 1, g___0);
#line 497
        (*fun)(t_x___0, t_y___0 + 1, g___0);
      }
      __Cont___0: /* CIL Label */ 
#line 487
      i ++;
    }
#line 486
    j ++;
  }
#line 499
  return;
}
}
#line 507 "event.c"
static void most_common_color(Grid *g___0 ) 
{ int count[256] ;
  int x ;
  int y ;
  int c ;
  int max ;
  int max_count ;

  {
#line 514
  memset((void *)(count), 0, sizeof(count));
#line 515
  x = 0;
#line 515
  while (x < g___0->w) {
#line 516
    y = 0;
#line 516
    while (y < g___0->h) {
#line 517
      c = (int )*(g___0->contents + (x + y * g___0->w));
#line 518
      if (c > 1) {
#line 519
        (count[c]) ++;
      }
#line 516
      y ++;
    }
#line 515
    x ++;
  }
#line 521
  max = 1;
#line 522
  max_count = 0;
#line 523
  x = 2;
#line 523
  while (x < 256) {
#line 524
    if (count[x] > max_count) {
#line 525
      max = x;
#line 526
      max_count = count[x];
    }
#line 523
    x ++;
  }
#line 528
  most_common = max;
#line 529
  return;
}
}
#line 537 "event.c"
void handle_special(play_piece *pp , int row , int col , int rot , Grid *g___0 , sound_style *ss ) 
{ 

  {
#line 541
  switch ((int )pp->special) {
  case -1: 
#line 542
  break;
  case 0: 
#line 544
  find_on_board(pp, col, row, rot, g___0, & bomb_fun);
#line 545
  if (ss) {
#line 546
    play_sound(ss, 1, 256);
  }
#line 547
  break;
  case 1: 
#line 549
  most_common_color(g___0);
#line 550
  find_on_board(pp, col, row, rot, g___0, & repaint_fun);
#line 551
  if (ss) {
#line 552
    play_sound(ss, 5, 256);
  }
#line 553
  break;
  case 2: 
#line 555
  push_down(pp, col, row, rot, g___0, & repaint_fun);
#line 556
  if (ss) {
#line 557
    play_sound(ss, 0, 512);
  }
#line 558
  break;
  case 3: 
#line 560
  find_on_board(pp, col, row, rot, g___0, & colorkill_fun);
#line 561
  if (ss) {
#line 562
    play_sound(ss, 1, 256);
  }
#line 563
  break;
  }
#line 566
  return;
}
}
#line 572 "event.c"
static void do_pause(int paused , Uint32 tv_now , int *pause_begin_time , int *tv_start ) 
{ int i ;

  {
#line 576
  draw_pause(paused);
#line 577
  if (! paused) {
#line 579
    *tv_start = (int )((Uint32 )*tv_start + (tv_now - (Uint32 )*pause_begin_time));
#line 580
    i = 0;
#line 580
    while (i < 2) {
#line 581
      State[i].collide_time += tv_now - (Uint32 )*pause_begin_time;
#line 582
      State[i].next_draw += tv_now - (Uint32 )*pause_begin_time;
#line 583
      State[i].tv_next_fall += tv_now - (Uint32 )*pause_begin_time;
#line 584
      State[i].tv_next_tetris += tv_now - (Uint32 )*pause_begin_time;
#line 585
      State[i].tv_next_ai_think += tv_now - (Uint32 )*pause_begin_time;
#line 586
      State[i].tv_next_ai_move += tv_now - (Uint32 )*pause_begin_time;
#line 580
      i ++;
    }
  } else {
#line 589
    *pause_begin_time = (int )tv_now;
  }
#line 591
  return;
}
}
#line 601 "event.c"
static int place_this_piece(int P , int blockWidth , Grid *g___0 ) 
{ int Y ;
  int R ;
  int tmp ;

  {
#line 607
  pos[P].old_x = (int )(g___0 + P)->board.x + (int )(g___0 + P)->board.w / 2;
#line 607
  pos[P].x = pos[P].old_x;
#line 608
  Y = 0;
#line 608
  while (Y >= -2) {
#line 609
    R = 0;
#line 609
    while (R <= 3) {
#line 610
      pos[P].old_y = (int )(g___0 + P)->board.y + blockWidth * Y;
#line 610
      pos[P].y = pos[P].old_y;
#line 611
      pos[P].rot = R;
#line 611
      pos[P].old_rot = pos[P].rot;
#line 612
      tmp = valid_screen_position(& State[P].cp, blockWidth, g___0 + P, pos[P].rot,
                                  pos[P].x, pos[P].y);
#line 612
      if (tmp) {
#line 614
        return (0);
      }
#line 609
      R ++;
    }
#line 608
    Y --;
  }
#line 618
  return (1);
}
}
#line 631 "event.c"
int event_loop(SDL_Surface *screen___0 , piece_style *ps , color_style **cs , sound_style **ss ,
               Grid *g___0 , int *level , int sock , int *seconds_remaining , int time_is_hard_limit ,
               int *adjust , int (*handle)(SDL_Event const   * ) , int seed , int p1 ,
               int p2 , AI_Player **AI ) 
{ SDL_Event event ;
  Uint32 tv_now ;
  Uint32 tv_start ;
  int NUM_PLAYER ;
  int NUM_KEYBOARD ;
  int last_seconds ;
  int minimum_fall_event_interval ;
  int paused ;
  Uint32 pause_begin_time ;
  int blockWidth ;
  int i ;
  int j ;
  int P ;
  int Q ;
  Uint32 __attribute__((__visibility__("default")))  tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  Uint16 tmp___4 ;
  Uint16 tmp___5 ;
  Uint16 tmp___6 ;
  Uint16 tmp___7 ;
  char msg ;
  Uint32 __attribute__((__visibility__("default")))  tmp___8 ;
  int i___0 ;
  int j___0 ;
  int delta ;
  int amt ;
  int i___1 ;
  int j___1 ;
  int try ;
  int we_fell ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int row ;
  int col ;
  int row___0 ;
  int col___0 ;
  char msg___0 ;
  int blank ;
  int garbage ;
  Uint32 __attribute__((__visibility__("default")))  tmp___12 ;
  int tmp___13 ;
  int x ;
  int y ;
  int count ;
  Uint32 __attribute__((__visibility__("default")))  tmp___14 ;
  int tmp___15 ;
  int row___1 ;
  int col___1 ;
  int row___2 ;
  int col___2 ;
  int tmp___16 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___17 ;
  char msg___1 ;
  int ks ;
  int __attribute__((__visibility__("default")))  tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  fd_set read_fds ;
  struct timeval timeout ;
  int retval ;
  int __d0 ;
  int __d1 ;
  char msg___2 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___27 ;
  int i___2 ;
  int j___2 ;
  ssize_t tmp___28 ;
  char msg___3 ;
  char msg___4 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___29 ;
  Uint32 least ;
  int row___3 ;
  int col___3 ;
  int row___4 ;
  int col___4 ;
  int __attribute__((__visibility__("default")))  tmp___30 ;
  int __attribute__((__visibility__("default")))  tmp___31 ;

  {
#line 640
  NUM_PLAYER = 0;
#line 641
  NUM_KEYBOARD = 0;
#line 642
  last_seconds = -1;
#line 643
  minimum_fall_event_interval = 100;
#line 644
  paused = 0;
#line 645
  pause_begin_time = (Uint32 )0;
#line 650
  blockWidth = (*(cs + 0))->w;
#line 653
  SDL_EnableKeyRepeat(500 / Options.key_repeat_delay, 15);
#line 656
  if ((int )gametype != 7) {
#line 657
    stop_all_playing();
  }
#line 659
  memset((void *)(pos), 0, sizeof(pos[0]) * 2U);
#line 660
  memset((void *)(State), 0, sizeof(State[0]) * 2U);
#line 662
  switch (p1) {
  case 0: 
#line 663
  if (! (! handle)) {
#line 663
    Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d", "!handle",
          663);
  }
#line 663
  break;
  case 1: 
#line 664
  if (! (! handle)) {
#line 664
    Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d", "!handle",
          664);
  }
#line 664
  NUM_PLAYER ++;
#line 664
  NUM_KEYBOARD ++;
#line 664
  break;
  case 2: 
#line 665
  State[0].ai = 1;
#line 665
  NUM_PLAYER ++;
#line 665
  break;
  case 3: 
#line 666
  Panic("event_loop", "event.c", (char *)"Cannot have player 1 over the network!");
  }
#line 668
  switch (p2) {
  case 0: 
#line 669
  break;
  case 1: 
#line 670
  if (! (! handle)) {
#line 670
    Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d", "!handle",
          670);
  }
#line 670
  NUM_PLAYER ++;
#line 670
  NUM_KEYBOARD ++;
#line 670
  break;
  case 2: 
#line 671
  State[1].ai = 1;
#line 671
  NUM_PLAYER ++;
#line 671
  break;
  case 3: 
#line 672
  if (! sock) {
#line 672
    Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d", "sock",
          672);
  }
#line 672
  break;
  }
#line 674
  if (NUM_PLAYER >= 1) {
#line 674
    if (! (NUM_PLAYER <= 2)) {
#line 674
      Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d",
            "NUM_PLAYER >= 1 && NUM_PLAYER <= 2", 674);
    }
  } else {
#line 674
    Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d", "NUM_PLAYER >= 1 && NUM_PLAYER <= 2",
          674);
  }
#line 676
  tmp = SDL_GetTicks();
#line 676
  tv_now = (unsigned int )tmp;
#line 676
  tv_start = tv_now;
#line 677
  tv_start += (Uint32 )(*seconds_remaining * 1000);
#line 679
  P = 0;
#line 679
  while (P < NUM_PLAYER) {
#line 680
    State[P].falling = 1;
#line 681
    State[P].fall_speed = 1;
#line 682
    State[P].tetris_handling = 0;
#line 683
    State[P].accept_input = 1;
#line 684
    State[P].limbo = 0;
#line 685
    State[P].draw = 1;
#line 686
    State[P].other_in_limbo = 0;
#line 687
    State[P].next_draw = 0U;
#line 688
    State[P].limbo_sent = 0;
#line 689
    State[P].cp = generate_piece(ps, *(cs + P), (unsigned int )seed);
#line 690
    State[P].np = generate_piece(ps, *(cs + P), (unsigned int )(seed + 1));
#line 691
    State[P].seed = seed + 2;
#line 692
    State[P].ready_for_fast = 1;
#line 693
    State[P].ready_for_rotate = 1;
#line 695
    draw_next_piece(screen___0, ps, *(cs + P), & State[P].cp, & State[P].np, P);
#line 697
    *(adjust + P) = -1;
#line 699
    if (Options.faster_levels) {
#line 699
      tmp___2 = *(level + P);
    } else {
#line 699
      tmp___2 = (*(level + P) + 1) / 2;
    }
#line 699
    if (tmp___2 <= 7) {
#line 700
      if (Options.faster_levels) {
#line 700
        tmp___0 = *(level + P);
      } else {
#line 700
        tmp___0 = (*(level + P) + 1) / 2;
      }
#line 700
      State[P].fall_event_interval = 45 - tmp___0 * 5;
    } else {
#line 702
      if (Options.faster_levels) {
#line 702
        tmp___1 = *(level + P);
      } else {
#line 702
        tmp___1 = (*(level + P) + 1) / 2;
      }
#line 702
      State[P].fall_event_interval = 16 - tmp___1;
    }
#line 703
    if (State[P].fall_event_interval < 1) {
#line 704
      State[P].fall_event_interval = 1;
    }
#line 706
    if (State[P].fall_event_interval < minimum_fall_event_interval) {
#line 707
      minimum_fall_event_interval = State[P].fall_event_interval;
    }
#line 709
    State[P].tv_next_fall = tv_now + (Uint32 )State[P].fall_event_interval;
#line 711
    tmp___3 = place_this_piece(P, blockWidth, g___0);
#line 711
    if (tmp___3) {
#line 713
      pos[P].old_x = (int )(g___0 + P)->board.x + (int )(g___0 + P)->board.w / 2;
#line 713
      pos[P].x = pos[P].old_x;
#line 714
      pos[P].old_y = (int )(g___0 + P)->board.y;
#line 714
      pos[P].y = pos[P].old_y;
#line 715
      pos[P].old_rot = 0;
#line 715
      pos[P].rot = pos[P].old_rot;
    }
#line 718
    if (State[P].ai) {
#line 719
      State[P].tv_next_ai_think = tv_now;
#line 720
      State[P].tv_next_ai_move = tv_now;
#line 721
      if ((int )gametype == 7) {
        goto _L;
      } else {
#line 721
        if ((int )gametype == 5) {
          goto _L;
        } else {
#line 721
          if ((*(AI + P))->delay_factor == 0) {
            _L: /* CIL Label */ 
#line 723
            State[P].ai_interval = State[P].fall_event_interval;
#line 724
            if (State[P].ai_interval > 15) {
#line 725
              State[P].ai_interval = 15;
            }
          } else {
#line 727
            if ((*(AI + P))->delay_factor < 1) {
#line 728
              (*(AI + P))->delay_factor = 1;
            }
#line 729
            if ((*(AI + P))->delay_factor > 100) {
#line 730
              (*(AI + P))->delay_factor = 100;
            }
#line 731
            State[P].ai_interval = (*(AI + P))->delay_factor;
          }
        }
      }
#line 733
      State[P].ai_state = (*((*(AI + P))->reset))(State[P].ai_state, g___0 + P);
    }
#line 679
    P ++;
  }
#line 740
  distract_grid[0] = generate_board((g___0 + 0)->w, (g___0 + 0)->h, (g___0 + 0)->h - 2);
#line 741
  distract_grid[0].board = (g___0 + 0)->board;
#line 743
  SeedRandom((unsigned int )seed);
#line 744
  i = 0;
#line 744
  while (i < (g___0 + 0)->w) {
#line 745
    j = 0;
#line 745
    while (j < (g___0 + 0)->h) {
#line 746
      tmp___4 = FastRandom((unsigned short )(*(cs + 0))->num_color);
#line 746
      *(distract_grid[0].changed + (i + j * distract_grid[0].w)) = (unsigned char )((int )*(distract_grid[0].changed + (i + j * distract_grid[0].w)) | ((int )*(distract_grid[0].contents + (i + j * distract_grid[0].w)) != (int )tmp___4));
#line 746
      tmp___5 = FastRandom((unsigned short )(*(cs + 0))->num_color);
#line 746
      *(distract_grid[0].contents + (i + j * distract_grid[0].w)) = (unsigned char )tmp___5;
#line 745
      j ++;
    }
#line 744
    i ++;
  }
#line 748
  if (NUM_PLAYER == 2) {
#line 749
    distract_grid[1] = generate_board((g___0 + 1)->w, (g___0 + 1)->h, (g___0 + 1)->h - 2);
#line 750
    distract_grid[1].board = (g___0 + 1)->board;
#line 751
    i = 0;
#line 751
    while (i < (g___0 + 1)->w) {
#line 752
      j = 0;
#line 752
      while (j < (g___0 + 1)->h) {
#line 753
        tmp___6 = FastRandom((unsigned short )(*(cs + 1))->num_color);
#line 753
        *(distract_grid[1].changed + (i + j * distract_grid[1].w)) = (unsigned char )((int )*(distract_grid[1].changed + (i + j * distract_grid[1].w)) | ((int )*(distract_grid[1].contents + (i + j * distract_grid[1].w)) != (int )tmp___6));
#line 753
        tmp___7 = FastRandom((unsigned short )(*(cs + 1))->num_color);
#line 753
        *(distract_grid[1].contents + (i + j * distract_grid[1].w)) = (unsigned char )tmp___7;
#line 752
        j ++;
      }
#line 751
      i ++;
    }
  }
#line 757
  if (sock) {
#line 758
    msg = (char )'c';
#line 759
    send(sock, (void const   *)(& msg), 1U, 0);
#line 760
    send(sock, (void const   *)(g___0 + 0)->contents, (sizeof(*((g___0 + 0)->contents)) * (unsigned int )(g___0 + 0)->h) * (unsigned int )(g___0 + 0)->w,
         0);
  }
#line 765
  draw_clock(0);
#line 767
  draw_grid(screen___0, *(cs + 0), g___0 + 0, 1);
#line 768
  draw_score(screen___0, 0);
#line 769
  if (NUM_PLAYER == 2) {
#line 770
    draw_grid(screen___0, *(cs + 1), g___0 + 1, 1);
#line 771
    draw_score(screen___0, 1);
  }
#line 773
  if (sock) {
#line 774
    draw_score(screen___0, 1);
  }
#line 780
  P = 0;
#line 782
  while (1) {
#line 784
    if (NUM_PLAYER == 2) {
#line 785
      P = ! P;
    }
#line 787
    tmp___8 = SDL_GetTicks();
#line 787
    tv_now = (unsigned int )tmp___8;
#line 790
    if (tv_start >= tv_now) {
#line 791
      *seconds_remaining = (int )((tv_start - tv_now) / 1000U);
    } else {
#line 793
      *seconds_remaining = (int )(- ((tv_now - tv_start) / 1000U));
    }
#line 795
    if (*seconds_remaining != last_seconds) {
#line 795
      if (! paused) {
#line 796
        last_seconds = *seconds_remaining;
#line 797
        draw_clock(*seconds_remaining);
#line 798
        if (last_seconds <= 30) {
#line 798
          if (last_seconds >= 0) {
#line 799
            play_sound_unless_already_playing(*(ss + 0), 6, 0);
#line 800
            if (NUM_PLAYER == 2) {
#line 801
              play_sound_unless_already_playing(*(ss + 1), 6, 0);
            }
          }
        }
      }
    }
#line 806
    if (*seconds_remaining < 0) {
#line 806
      if (time_is_hard_limit) {
#line 806
        if (! paused) {
#line 807
          play_sound(*(ss + 0), 4, 0);
#line 808
          *(adjust + 0) = 2;
#line 809
          if (NUM_PLAYER == 2) {
#line 810
            play_sound(*(ss + 1), 4, 0);
#line 811
            *(adjust + 1) = 2;
          }
#line 813
          stop_playing_sound(*(ss + 0), 6);
#line 814
          if (NUM_PLAYER == 2) {
#line 814
            stop_playing_sound(*(ss + 1), 6);
          }
#line 815
          return (0);
        }
      }
    }
#line 821
    if (! State[P].draw) {
#line 821
      if (tv_now > State[P].next_draw) {
#line 821
        if (! paused) {
#line 823
          State[P].draw = 1;
#line 824
          i___0 = 0;
#line 824
          while (i___0 < (g___0 + P)->w) {
#line 825
            j___0 = 0;
#line 825
            while (j___0 < (g___0 + P)->h) {
#line 826
              *((g___0 + P)->changed + (i___0 + j___0 * (g___0 + P)->w)) = (unsigned char)1;
#line 827
              if ((int )*((g___0 + P)->contents + (i___0 + j___0 * (g___0 + P)->w)) == 0) {
#line 828
                *((g___0 + P)->changed + (i___0 + j___0 * (g___0 + P)->w)) = (unsigned char )((int )*((g___0 + P)->changed + (i___0 + j___0 * (g___0 + P)->w)) | ((int )*((g___0 + P)->contents + (i___0 + j___0 * (g___0 + P)->w)) != 255));
#line 828
                *((g___0 + P)->contents + (i___0 + j___0 * (g___0 + P)->w)) = (unsigned char)255;
              }
#line 825
              j___0 ++;
            }
#line 824
            i___0 ++;
          }
#line 830
          draw_grid(screen___0, *(cs + P), g___0 + P, 1);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 831
      if (! State[P].draw) {
#line 832
        delta = (int )(State[P].next_draw - tv_now);
#line 833
        amt = (int )((Uint32 )(g___0 + P)->h - (Uint32 )((g___0 + P)->h * delta) / State[P].draw_timeout);
#line 835
        j___1 = amt - 1;
#line 836
        if (j___1 < 0) {
#line 836
          j___1 = 0;
        }
#line 837
        i___1 = 0;
#line 837
        while (i___1 < (g___0 + P)->w) {
#line 838
          *(distract_grid[P].changed + (i___1 + j___1 * distract_grid[P].w)) = (unsigned char)1;
#line 837
          i___1 ++;
        }
#line 839
        draw_grid(screen___0, *(cs + P), & distract_grid[P], 1);
      }
    }
#line 846
    if (State[P].falling) {
#line 846
      if (tv_now >= State[P].tv_next_fall) {
#line 846
        if (! paused) {
#line 848
          we_fell = 0;
#line 856
          while (1) {
#line 857
            State[P].tv_next_fall += (Uint32 )State[P].fall_event_interval;
#line 856
            if (! (State[P].tv_next_fall <= tv_now)) {
#line 856
              break;
            }
          }
#line 860
          try = State[P].fall_speed;
#line 860
          while (try > 0) {
#line 861
            tmp___9 = valid_screen_position(& State[P].cp, blockWidth, g___0 + P,
                                            pos[P].rot, pos[P].x, pos[P].y + try);
#line 861
            if (tmp___9) {
#line 862
              pos[P].y += try;
#line 863
              State[P].fall_speed = try;
#line 864
              try = 0;
#line 865
              we_fell = 1;
            }
#line 860
            try --;
          }
#line 867
          if (! we_fell) {
#line 868
            if (! State[P].collide_time) {
#line 869
              if (Options.long_settle_delay) {
#line 869
                tmp___10 = 400;
              } else {
#line 869
                tmp___10 = 200;
              }
#line 869
              State[P].collide_time = tv_now + (Uint32 )tmp___10;
#line 871
              continue;
            }
#line 873
            if (tv_now < State[P].collide_time) {
#line 874
              continue;
            }
          } else {
#line 876
            continue;
          }
#line 879
          State[P].collide_time = 0U;
#line 881
          play_sound(*(ss + P), 0, 0);
#line 885
          while (1) {
#line 885
            tmp___11 = valid_screen_position(& State[P].cp, blockWidth, g___0 + P,
                                             pos[P].rot, pos[P].x, pos[P].y);
#line 885
            if (tmp___11) {
#line 885
              break;
            } else {
#line 885
              if (! (pos[P].y > 0)) {
#line 885
                break;
              }
            }
#line 886
            (pos[P].y) --;
          }
#line 888
          if (State[P].draw) {
#line 889
            draw_play_piece(screen___0, *(cs + P), & State[P].cp, pos[P].old_x, pos[P].old_y,
                            pos[P].old_rot, & State[P].cp, pos[P].x, pos[P].y, pos[P].rot);
          }
#line 892
          if ((int )State[P].cp.special != -1) {
#line 895
            screen_to_exact_grid_coords(g___0 + P, blockWidth, pos[P].x, pos[P].y,
                                        & row, & col);
#line 897
            handle_special(& State[P].cp, row, col, pos[P].rot, g___0 + P, *(ss + P));
          } else {
#line 901
            screen_to_exact_grid_coords(g___0 + P, blockWidth, pos[P].x, pos[P].y,
                                        & row___0, & col___0);
#line 903
            paste_on_board(& State[P].cp, col___0, row___0, pos[P].rot, g___0 + P);
          }
#line 906
          if (sock) {
#line 907
            msg___0 = (char )'c';
#line 908
            send(sock, (void const   *)(& msg___0), 1U, 0);
#line 909
            send(sock, (void const   *)(g___0 + P)->contents, (sizeof(*((g___0 + P)->contents)) * (unsigned int )(g___0 + P)->h) * (unsigned int )(g___0 + P)->w,
                 0);
          }
#line 912
          draw_grid(screen___0, *(cs + P), g___0 + P, State[P].draw);
#line 915
          State[P].falling = 0;
#line 916
          State[P].fall_speed = 0;
#line 917
          State[P].tetris_handling = 1;
#line 918
          State[P].accept_input = 0;
#line 919
          State[P].tv_next_tetris = tv_now;
        }
      }
    }
#line 924
    if (State[P].tetris_handling != 0) {
#line 924
      if (tv_now >= State[P].tv_next_tetris) {
#line 924
        if (! paused) {
#line 925
          blank = 0;
#line 925
          garbage = 0;
#line 933
          State[P].tetris_handling = tetris_event(& State[P].tetris_event_interval,
                                                  State[P].tetris_handling, screen___0,
                                                  ps, *(cs + P), *(ss + P), g___0 + P,
                                                  *(level + P), minimum_fall_event_interval,
                                                  sock, State[P].draw, & blank, & garbage,
                                                  P);
#line 939
          if (NUM_PLAYER == 2) {
#line 940
            if (blank) {
#line 941
              do_blank(screen___0, ss, g___0, ! P);
            }
#line 942
            if (garbage) {
#line 943
              add_garbage(g___0 + ! P);
#line 944
              play_sound(*(ss + ! P), 5, 1);
#line 945
              draw_grid(screen___0, *(cs + ! P), g___0 + ! P, State[! P].draw);
            }
          }
#line 949
          tmp___12 = SDL_GetTicks();
#line 949
          tv_now = (unsigned int )tmp___12;
#line 950
          while (1) {
#line 951
            State[P].tv_next_tetris += (Uint32 )State[P].tetris_event_interval;
#line 950
            if (! (State[P].tv_next_tetris < tv_now)) {
#line 950
              break;
            }
          }
#line 954
          if (State[P].tetris_handling == 0) {
#line 959
            State[P].cp = State[P].np;
#line 960
            tmp___13 = State[P].seed;
#line 960
            (State[P].seed) ++;
#line 960
            State[P].np = generate_piece(ps, *(cs + P), (unsigned int )tmp___13);
#line 961
            draw_next_piece(screen___0, ps, *(cs + P), & State[P].cp, & State[P].np,
                            P);
#line 964
            tmp___15 = place_this_piece(P, blockWidth, g___0);
#line 964
            if (tmp___15) {
              you_lose: 
#line 967
              play_sound(*(ss + P), 4, 0);
#line 968
              *(adjust + P) = 2;
#line 969
              if (NUM_PLAYER == 2) {
#line 969
                if (! sock) {
#line 970
                  *(adjust + ! P) = 1;
                }
              }
#line 971
              if (sock == 0) {
#line 972
                stop_playing_sound(*(ss + 0), 6);
#line 973
                if (NUM_PLAYER == 2) {
#line 973
                  stop_playing_sound(*(ss + 1), 6);
                }
#line 974
                return (0);
              }
#line 979
              State[P].falling = 0;
#line 980
              State[P].fall_speed = 0;
#line 981
              State[P].tetris_handling = 0;
#line 982
              State[P].accept_input = 0;
#line 983
              State[P].limbo = 1;
            } else {
#line 985
              count = 0;
#line 986
              if (State[P].ai) {
#line 987
                State[P].ai_state = (*((*(AI + P))->reset))(State[P].ai_state, g___0 + P);
              }
#line 989
              y = 0;
#line 989
              while (y < g___0->h) {
#line 990
                x = 0;
#line 990
                while (x < g___0->w) {
#line 991
                  if ((int )*((g___0 + P)->contents + (x + y * (g___0 + P)->w)) == 1) {
#line 992
                    count ++;
                  }
#line 990
                  x ++;
                }
#line 989
                y ++;
              }
#line 993
              if (count == 0) {
                you_win: 
#line 995
                play_sound(*(ss + P), 3, 256);
#line 996
                if (*seconds_remaining <= 0) {
#line 997
                  *(adjust + P) = 1;
#line 998
                  if (NUM_PLAYER == 2) {
#line 998
                    if (! sock) {
#line 999
                      *(adjust + ! P) = 2;
                    }
                  }
                } else {
#line 1001
                  *(adjust + P) = 0;
#line 1002
                  if (NUM_PLAYER == 2) {
#line 1002
                    if (! sock) {
#line 1003
                      *(adjust + ! P) = 1;
                    }
                  }
                }
#line 1005
                if (sock == 0) {
#line 1006
                  stop_playing_sound(*(ss + 0), 6);
#line 1007
                  if (NUM_PLAYER == 2) {
#line 1007
                    stop_playing_sound(*(ss + 1), 6);
                  }
#line 1008
                  return (0);
                }
#line 1013
                State[P].falling = 0;
#line 1014
                State[P].fall_speed = 0;
#line 1015
                State[P].tetris_handling = 0;
#line 1016
                State[P].accept_input = 0;
#line 1017
                State[P].limbo = 1;
              } else {
#line 1020
                State[P].falling = 1;
#line 1021
                State[P].fall_speed = 1;
#line 1022
                State[P].tetris_handling = 0;
#line 1023
                State[P].accept_input = 1;
#line 1024
                tmp___14 = SDL_GetTicks();
#line 1024
                State[P].tv_next_fall = (unsigned int )(tmp___14 + (Uint32 __attribute__((__visibility__("default")))  )State[P].fall_event_interval);
              }
            }
          }
        }
      }
    }
#line 1034
    if (State[P].ai) {
#line 1034
      if (tv_now >= State[P].tv_next_ai_think) {
#line 1034
        if (! paused) {
#line 1040
          screen_to_grid_coords(g___0 + P, blockWidth, pos[P].x, pos[P].y, & row___1,
                                & col___1);
#line 1043
          if (State[P].draw) {
#line 1044
            (*((*(AI + P))->think))(State[P].ai_state, g___0 + P, & State[P].cp, & State[P].np,
                                    col___1, row___1, pos[P].rot);
          }
#line 1053
          while (1) {
#line 1054
            State[P].tv_next_ai_think += (Uint32 )State[P].ai_interval;
#line 1053
            if (! (State[P].tv_next_ai_think < tv_now)) {
#line 1053
              break;
            }
          }
        }
      }
    }
#line 1058
    if (State[P].ai) {
#line 1058
      if (State[P].accept_input) {
#line 1058
        if (tv_now >= State[P].tv_next_ai_move) {
#line 1058
          if (! paused) {
#line 1065
            screen_to_grid_coords(g___0 + P, blockWidth, pos[P].x, pos[P].y, & row___2,
                                  & col___2);
#line 1066
            pos[P].move = (*((*(AI + P))->move))(State[P].ai_state, g___0 + P, & State[P].cp,
                                                 & State[P].np, col___2, row___2,
                                                 pos[P].rot);
#line 1076
            while (1) {
#line 1077
              State[P].tv_next_ai_move += (Uint32 )(State[P].ai_interval * 5);
#line 1076
              if (! (State[P].tv_next_ai_move < tv_now)) {
#line 1076
                break;
              }
            }
          }
        }
      }
    }
#line 1086
    tmp___18 = SDL_PollEvent(& event);
#line 1086
    if (tmp___18) {
#line 1089
      if (handle) {
#line 1090
        tmp___16 = (*handle)((SDL_Event const   *)(& event));
#line 1090
        if (tmp___16) {
#line 1091
          return (-1);
        }
      } else {
#line 1093
        switch ((int )event.type) {
        case 3: 
#line 1097
        if ((int )event.key.keysym.sym == 274) {
#line 1098
          State[1].ready_for_fast = 1;
#line 1099
          if (NUM_KEYBOARD == 1) {
#line 1100
            State[0].ready_for_fast = 1;
          }
        } else {
#line 1102
          if ((int )event.key.keysym.sym == 273) {
#line 1103
            State[1].ready_for_rotate = 1;
#line 1104
            if (NUM_KEYBOARD == 1) {
#line 1105
              State[0].ready_for_rotate = 1;
            }
          } else {
#line 1107
            if ((int )event.key.keysym.sym == 119) {
#line 1108
              State[0].ready_for_rotate = 1;
            } else {
#line 1109
              if ((int )event.key.keysym.sym == 115) {
#line 1110
                State[0].ready_for_fast = 1;
              } else {
#line 1111
                if ((int )event.key.keysym.sym == 49) {
#line 1112
                  P = 0;
                  goto you_win;
                } else {
#line 1115
                  if ((int )event.key.keysym.sym == 50) {
#line 1116
                    P = 0;
                    goto you_lose;
                  } else {
#line 1119
                    if ((int )event.key.keysym.sym == 51) {
#line 1120
                      P = 1;
                      goto you_win;
                    } else {
#line 1123
                      if ((int )event.key.keysym.sym == 52) {
#line 1124
                        P = 1;
                        goto you_lose;
                      } else {
#line 1126
                        if ((int )event.key.keysym.sym == 112) {
#line 1126
                          if ((int )gametype != 7) {
#line 1128
                            tmp___17 = SDL_GetTicks();
#line 1128
                            tv_now = (unsigned int )tmp___17;
#line 1129
                            paused = ! paused;
#line 1130
                            if (sock) {
#line 1131
                              msg___1 = (char )'p';
#line 1132
                              send(sock, (void const   *)(& msg___1), 1U, 0);
                            }
#line 1134
                            do_pause(paused, tv_now, (int *)(& pause_begin_time),
                                     (int *)(& tv_start));
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 1137
        break;
        case 2: 
#line 1141
        ks = (int )event.key.keysym.sym;
#line 1142
        Q = -1;
#line 1145
        if (ks == 273) {
#line 1147
          Q = 1;
        } else {
#line 1145
          if (ks == 274) {
#line 1147
            Q = 1;
          } else {
#line 1145
            if (ks == 275) {
#line 1147
              Q = 1;
            } else {
#line 1145
              if (ks == 276) {
#line 1147
                Q = 1;
              } else {
#line 1148
                if (ks == 119) {
#line 1150
                  Q = 0;
                } else {
#line 1148
                  if (ks == 115) {
#line 1150
                    Q = 0;
                  } else {
#line 1148
                    if (ks == 97) {
#line 1150
                      Q = 0;
                    } else {
#line 1148
                      if (ks == 100) {
#line 1150
                        Q = 0;
                      } else {
#line 1151
                        if (ks == 113) {
#line 1152
                          if (sock == 0) {
#line 1153
                            *(adjust + 0) = -1;
#line 1154
                            if (NUM_PLAYER == 2) {
#line 1155
                              *(adjust + 1) = -1;
                            }
#line 1156
                            stop_playing_sound(*(ss + 0), 6);
#line 1157
                            if (NUM_PLAYER == 2) {
#line 1157
                              stop_playing_sound(*(ss + 1), 6);
                            }
#line 1158
                            return (-1);
                          } else {
#line 1163
                            State[0].falling = 0;
#line 1164
                            State[0].fall_speed = 0;
#line 1165
                            State[0].tetris_handling = 0;
#line 1166
                            State[0].accept_input = 0;
#line 1167
                            State[0].limbo = 1;
#line 1168
                            *(adjust + 0) = 2;
                          }
                        } else {
#line 1170
                          if (ks == 13) {
#line 1170
                            if ((int )event.key.keysym.mod & 64) {
#line 1173
                              SDL_WM_ToggleFullScreen(screen___0);
#line 1174
                              break;
                            } else {
#line 1170
                              if ((int )event.key.keysym.mod & 128) {
#line 1173
                                SDL_WM_ToggleFullScreen(screen___0);
#line 1174
                                break;
                              } else {
#line 1175
                                break;
                              }
                            }
                          } else {
#line 1175
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 1176
        if (NUM_KEYBOARD == 1) {
#line 1176
          Q = 0;
        } else {
#line 1177
          if (NUM_KEYBOARD < 1) {
#line 1177
            break;
          }
        }
#line 1180
        if (! (Q == 0)) {
#line 1180
          if (! (Q == 1)) {
#line 1180
            Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d",
                  "Q == 0 || Q == 1", 1180);
          }
        }
#line 1182
        if ((int )event.key.keysym.sym != 274) {
#line 1182
          if ((int )event.key.keysym.sym != 115) {
#line 1184
            State[Q].fall_speed = 1;
          }
        }
#line 1185
        if (! State[Q].accept_input) {
#line 1186
          break;
        }
#line 1189
        switch ((int )event.key.keysym.sym) {
        case 273: 
        case 119: 
#line 1191
        if (State[Q].ready_for_rotate) {
#line 1192
          pos[Q].move = 3;
        }
#line 1193
        break;
        case 274: 
        case 115: 
#line 1195
        if (State[Q].ready_for_fast) {
#line 1196
          pos[Q].move = 4;
        }
#line 1197
        break;
        case 276: 
        case 97: 
#line 1199
        pos[Q].move = 1;
#line 1199
        break;
        case 275: 
        case 100: 
#line 1201
        pos[Q].move = 2;
#line 1201
        break;
        default: 
#line 1203
        Panic("event_loop", "event.c", (char *)"unknown keypress");
        }
#line 1206
        break;
        case 12: 
#line 1208
        printf((char const   * __restrict  )"%-14.14s| ", "event_loop");
#line 1208
        printf((char const   * __restrict  )"Window-manager exit request.\n");
#line 1208
        fflush(stdout);
#line 1209
        *(adjust + 0) = -1;
#line 1210
        if (NUM_PLAYER == 2) {
#line 1211
          *(adjust + 1) = -1;
        }
#line 1212
        stop_playing_sound(*(ss + 0), 6);
#line 1213
        if (NUM_PLAYER == 2) {
#line 1213
          stop_playing_sound(*(ss + 1), 6);
        }
#line 1214
        return (-1);
        case 13: 
#line 1216
        break;
        }
      }
    }
#line 1223
    Q = 0;
#line 1223
    while (Q < NUM_PLAYER) {
#line 1224
      switch ((int )pos[Q].move) {
      case 3: 
#line 1226
      State[Q].ready_for_rotate = 0;
#line 1227
      tmp___23 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q, (pos[Q].rot + 1) % 4,
                                       pos[Q].x, pos[Q].y);
#line 1227
      if (tmp___23) {
#line 1228
        pos[Q].rot = (pos[Q].rot + 1) % 4;
#line 1229
        State[Q].collide_time = 0U;
      } else {
#line 1230
        tmp___22 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q, (pos[Q].rot + 1) % 4,
                                         pos[Q].x - blockWidth, pos[Q].y);
#line 1230
        if (tmp___22) {
#line 1232
          pos[Q].rot = (pos[Q].rot + 1) % 4;
#line 1233
          pos[Q].x -= blockWidth;
#line 1234
          State[Q].collide_time = 0U;
        } else {
#line 1235
          tmp___21 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q, (pos[Q].rot + 1) % 4,
                                           pos[Q].x + blockWidth, pos[Q].y);
#line 1235
          if (tmp___21) {
#line 1237
            pos[Q].rot = (pos[Q].rot + 1) % 4;
#line 1238
            pos[Q].x += blockWidth;
#line 1239
            State[Q].collide_time = 0U;
          } else {
#line 1240
            tmp___20 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q,
                                             (pos[Q].rot + 1) % 4, pos[Q].x, pos[Q].y + blockWidth);
#line 1240
            if (tmp___20) {
#line 1242
              pos[Q].rot = (pos[Q].rot + 1) % 4;
#line 1243
              pos[Q].y += blockWidth;
#line 1244
              State[Q].collide_time = 0U;
            } else {
#line 1245
              if (Options.upward_rotation) {
#line 1245
                tmp___19 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q,
                                                 (pos[Q].rot + 1) % 4, pos[Q].x, pos[Q].y - blockWidth);
#line 1245
                if (tmp___19) {
#line 1249
                  pos[Q].rot = (pos[Q].rot + 1) % 4;
#line 1250
                  pos[Q].y -= blockWidth;
#line 1251
                  State[Q].collide_time = 0U;
                }
              }
            }
          }
        }
      }
#line 1253
      pos[Q].move = 0;
#line 1254
      break;
      case 1: 
#line 1256
      i = 0;
#line 1256
      while (i < 10) {
#line 1257
        tmp___24 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q, pos[Q].rot,
                                         pos[Q].x - blockWidth, pos[Q].y + i);
#line 1257
        if (tmp___24) {
#line 1261
          pos[Q].x -= blockWidth;
#line 1262
          pos[Q].y += i;
#line 1263
          State[Q].collide_time = 0U;
#line 1264
          break;
        }
#line 1256
        i ++;
      }
#line 1266
      pos[Q].move = 0;
#line 1267
      break;
      case 2: 
#line 1269
      i = 0;
#line 1269
      while (i < 10) {
#line 1270
        tmp___25 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q, pos[Q].rot,
                                         pos[Q].x + blockWidth, pos[Q].y + i);
#line 1270
        if (tmp___25) {
#line 1272
          pos[Q].x += blockWidth;
#line 1273
          pos[Q].y += i;
#line 1274
          State[Q].collide_time = 0U;
#line 1275
          break;
        }
#line 1269
        i ++;
      }
#line 1277
      pos[Q].move = 0;
#line 1278
      break;
      case 4: 
#line 1280
      tmp___26 = valid_screen_position(& State[Q].cp, blockWidth, g___0 + Q, pos[Q].rot,
                                       pos[Q].x, pos[Q].y + blockWidth);
#line 1280
      if (tmp___26) {
#line 1282
        pos[Q].y += blockWidth;
      }
#line 1283
      State[Q].fall_speed = 20;
#line 1284
      State[Q].ready_for_fast = 0;
#line 1285
      pos[Q].move = 0;
#line 1286
      break;
      default: ;
#line 1288
      break;
      }
#line 1223
      Q ++;
    }
#line 1293
    if (State[P].falling) {
#line 1293
      if (! paused) {
#line 1294
        if (State[P].draw) {
#line 1295
          if (pos[P].old_x != pos[P].x) {
#line 1296
            draw_play_piece(screen___0, *(cs + P), & State[P].cp, pos[P].old_x, pos[P].old_y,
                            pos[P].old_rot, & State[P].cp, pos[P].x, pos[P].y, pos[P].rot);
#line 1298
            pos[P].old_x = pos[P].x;
#line 1298
            pos[P].old_y = pos[P].y;
#line 1298
            pos[P].old_rot = pos[P].rot;
          } else {
#line 1295
            if (pos[P].old_y != pos[P].y) {
#line 1296
              draw_play_piece(screen___0, *(cs + P), & State[P].cp, pos[P].old_x,
                              pos[P].old_y, pos[P].old_rot, & State[P].cp, pos[P].x,
                              pos[P].y, pos[P].rot);
#line 1298
              pos[P].old_x = pos[P].x;
#line 1298
              pos[P].old_y = pos[P].y;
#line 1298
              pos[P].old_rot = pos[P].rot;
            } else {
#line 1295
              if (pos[P].old_rot != pos[P].rot) {
#line 1296
                draw_play_piece(screen___0, *(cs + P), & State[P].cp, pos[P].old_x,
                                pos[P].old_y, pos[P].old_rot, & State[P].cp, pos[P].x,
                                pos[P].y, pos[P].rot);
#line 1298
                pos[P].old_x = pos[P].x;
#line 1298
                pos[P].old_y = pos[P].y;
#line 1298
                pos[P].old_rot = pos[P].rot;
              }
            }
          }
        }
      }
    }
#line 1303
    if (sock) {
#line 1305
      timeout.tv_sec = (__time_t )0;
#line 1305
      timeout.tv_usec = (__suseconds_t )0;
#line 1308
      if (! (P == 0)) {
#line 1308
        Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d",
              "P == 0", 1308);
      }
#line 1310
      while (1) {
#line 1311
        while (1) {
#line 1311
          __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& read_fds.fds_bits[0]): "memory");
#line 1311
          break;
        }
#line 1312
        __asm__  volatile   ("btsl %1,%0": "=m" (read_fds.fds_bits[(unsigned int )sock / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )sock % (8U * sizeof(__fd_mask ))): "cc",
                             "memory");
#line 1314
        retval = select(sock + 1, (fd_set * __restrict  )(& read_fds), (fd_set * __restrict  )((void *)0),
                        (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
#line 1319
        if (retval > 0) {
#line 1321
          tmp___28 = recv(sock, (void *)(& msg___2), 1U, 0);
#line 1321
          if (tmp___28 != 1) {
#line 1322
            printf((char const   * __restrict  )"%-14.14s| ", "event_loop");
#line 1322
            printf((char const   * __restrict  )"WARNING: Other player has left?\n");
#line 1322
            fflush(stdout);
#line 1323
            close(sock);
#line 1324
            sock = 0;
#line 1325
            retval = 0;
          } else {
#line 1327
            switch ((int )msg___2) {
            case 98: 
#line 1329
            do_blank(screen___0, ss, g___0, P);
#line 1330
            break;
            case 112: 
#line 1332
            paused = ! paused;
#line 1333
            tmp___27 = SDL_GetTicks();
#line 1333
            tv_now = (unsigned int )tmp___27;
#line 1334
            do_pause(paused, tv_now, (int *)(& pause_begin_time), (int *)(& tv_start));
#line 1335
            break;
            case 2: 
            case 1: 
            case 0: 
#line 1340
            State[P].other_in_limbo = 1;
#line 1341
            *(adjust + ! P) = (int )msg___2;
#line 1342
            break;
            case 103: 
#line 1345
            add_garbage(g___0 + P);
#line 1346
            play_sound(*(ss + P), 5, 1);
#line 1347
            draw_grid(screen___0, *(cs + P), g___0 + P, State[P].draw);
#line 1348
            break;
            case 115: 
#line 1350
            recv(sock, (void *)((char *)(& Score[1])), sizeof(Score[1]), 0);
#line 1351
            draw_score(screen___0, 1);
#line 1352
            break;
            case 99: 
#line 1354
            memcpy((void * __restrict  )(g___0 + ! P)->temp, (void const   * __restrict  )(g___0 + ! P)->contents,
                   (sizeof(*((g___0 + 0)->temp)) * (unsigned int )(g___0 + ! P)->w) * (unsigned int )(g___0 + ! P)->h);
#line 1357
            recv(sock, (void *)(g___0 + ! P)->contents, (sizeof(*((g___0 + ! P)->contents)) * (unsigned int )(g___0 + ! P)->w) * (unsigned int )(g___0 + ! P)->h,
                 0);
#line 1360
            i___2 = 0;
#line 1360
            while (i___2 < (g___0 + ! P)->w) {
#line 1361
              j___2 = 0;
#line 1361
              while (j___2 < (g___0 + ! P)->h) {
#line 1362
                if ((int )*((g___0 + ! P)->contents + (i___2 + j___2 * (g___0 + ! P)->w)) != (int )*((g___0 + 1)->temp + (i___2 + j___2 * (g___0 + 1)->w))) {
#line 1363
                  *((g___0 + ! P)->changed + (i___2 + j___2 * (g___0 + ! P)->w)) = (unsigned char)1;
#line 1364
                  if (i___2 > 0) {
#line 1364
                    *((g___0 + ! P)->changed + ((i___2 - 1) + j___2 * (g___0 + ! P)->w)) = (unsigned char)1;
                  }
#line 1365
                  if (j___2 > 0) {
#line 1365
                    *((g___0 + ! P)->changed + (i___2 + (j___2 - 1) * (g___0 + ! P)->w)) = (unsigned char)1;
                  }
#line 1366
                  if (i___2 < (g___0 + ! P)->w - 1) {
#line 1366
                    *((g___0 + ! P)->changed + ((i___2 + 1) + j___2 * (g___0 + ! P)->w)) = (unsigned char)1;
                  }
#line 1367
                  if (i___2 < (g___0 + ! P)->h - 1) {
#line 1367
                    *((g___0 + ! P)->changed + (i___2 + (j___2 + 1) * (g___0 + ! P)->w)) = (unsigned char)1;
                  }
#line 1368
                  if ((int )*((g___0 + ! P)->contents + (i___2 + j___2 * (g___0 + ! P)->w)) == 0) {
#line 1368
                    *((g___0 + ! P)->changed + (i___2 + j___2 * (g___0 + ! P)->w)) = (unsigned char )((int )*((g___0 + ! P)->changed + (i___2 + j___2 * (g___0 + ! P)->w)) | ((int )*((g___0 + ! P)->contents + (i___2 + j___2 * (g___0 + ! P)->w)) != 255));
#line 1368
                    *((g___0 + ! P)->contents + (i___2 + j___2 * (g___0 + ! P)->w)) = (unsigned char)255;
                  }
                }
#line 1361
                j___2 ++;
              }
#line 1360
              i___2 ++;
            }
#line 1370
            draw_grid(screen___0, *(cs + ! P), g___0 + ! P, 1);
#line 1372
            break;
            default: ;
#line 1373
            break;
            }
          }
        }
#line 1310
        if (retval > 0) {
#line 1310
          if (State[P].limbo) {
#line 1310
            if (State[P].other_in_limbo) {
#line 1310
              break;
            }
          }
        } else {
#line 1310
          break;
        }
      }
#line 1381
      if (State[P].limbo) {
#line 1381
        if (State[P].other_in_limbo) {
#line 1382
          if (*(adjust + 0) != -1) {
#line 1382
            if (! (*(adjust + 1) != -1)) {
#line 1382
              Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d",
                    "adjust[0] != -1 && adjust[1] != -1", 1382);
            }
          } else {
#line 1382
            Panic("event_loop", "event.c", (char *)"Failed assertion \"%s\" on line %d",
                  "adjust[0] != -1 && adjust[1] != -1", 1382);
          }
#line 1383
          stop_playing_sound(*(ss + 0), 6);
#line 1384
          if (NUM_PLAYER == 2) {
#line 1384
            stop_playing_sound(*(ss + 1), 6);
          }
#line 1385
          return (0);
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 1386
        if (State[P].limbo) {
#line 1386
          if (! State[P].other_in_limbo) {
#line 1386
            if (! State[P].limbo_sent) {
#line 1388
              msg___3 = (char )*(adjust + P);
#line 1389
              State[P].limbo_sent = 1;
#line 1390
              send(sock, (void const   *)(& msg___3), 1U, 0);
            } else {
              goto _L___4;
            }
          } else {
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 1391
          if (! State[P].limbo) {
#line 1391
            if (State[P].other_in_limbo) {
#line 1394
              if (*(adjust + ! P) == 0) {
                goto _L___2;
              } else {
#line 1394
                if (*(adjust + ! P) == 1) {
                  _L___2: /* CIL Label */ 
#line 1395
                  if (*seconds_remaining > 0) {
#line 1396
                    *(adjust + P) = 1;
                  } else {
#line 1398
                    *(adjust + P) = 2;
                  }
                } else {
#line 1399
                  if (*(adjust + ! P) == 2) {
#line 1400
                    *(adjust + P) = 1;
                  }
                }
              }
#line 1405
              State[P].falling = 0;
#line 1406
              State[P].fall_speed = 0;
#line 1407
              State[P].tetris_handling = 0;
#line 1408
              State[P].accept_input = 0;
#line 1409
              State[P].limbo = 1;
#line 1410
              State[P].limbo_sent = 1;
#line 1411
              msg___4 = (char )*(adjust + P);
#line 1412
              send(sock, (void const   *)(& msg___4), 1U, 0);
#line 1413
              stop_playing_sound(*(ss + 0), 6);
#line 1414
              if (NUM_PLAYER == 2) {
#line 1414
                stop_playing_sound(*(ss + 1), 6);
              }
#line 1415
              return (0);
            }
          }
        }
      }
    }
#line 1418
    if (paused) {
#line 1419
      atris_run_flame();
    }
#line 1422
    tmp___29 = SDL_GetTicks();
#line 1422
    tv_now = (unsigned int )tmp___29;
#line 1424
    least = State[0].tv_next_fall;
#line 1426
    if (State[0].tetris_handling) {
#line 1426
      if (State[0].tv_next_tetris < least) {
#line 1427
        least = State[0].tv_next_tetris;
      }
    }
#line 1428
    if (State[0].ai) {
#line 1428
      if (State[0].tv_next_ai_think < least) {
#line 1429
        least = State[0].tv_next_ai_think;
      }
    }
#line 1430
    if (State[0].ai) {
#line 1430
      if (State[0].tv_next_ai_move < least) {
#line 1431
        least = State[0].tv_next_ai_move;
      }
    }
#line 1432
    if (NUM_PLAYER == 2) {
#line 1433
      if (State[1].tv_next_fall < least) {
#line 1434
        least = State[1].tv_next_tetris;
      }
#line 1435
      if (State[1].tetris_handling) {
#line 1435
        if (State[1].tv_next_tetris < least) {
#line 1436
          least = State[1].tv_next_tetris;
        }
      }
#line 1437
      if (State[1].ai) {
#line 1437
        if (State[1].tv_next_ai_think < least) {
#line 1438
          least = State[1].tv_next_ai_think;
        }
      }
#line 1439
      if (State[1].ai) {
#line 1439
        if (State[1].tv_next_ai_move < least) {
#line 1440
          least = State[1].tv_next_ai_move;
        }
      }
    }
#line 1443
    if (least >= tv_now + 4U) {
#line 1443
      tmp___31 = SDL_PollEvent((SDL_Event *)((void *)0));
#line 1443
      if (tmp___31) {
        goto _L___7;
      } else {
#line 1445
        if (State[0].ai) {
          goto _L___6;
        } else {
#line 1445
          if (State[1].ai) {
            _L___6: /* CIL Label */ 
#line 1446
            SDL_Delay(1U);
#line 1447
            if (State[0].ai) {
#line 1447
              if (State[0].draw) {
#line 1449
                screen_to_grid_coords(g___0 + 0, blockWidth, pos[0].x, pos[0].y, & row___3,
                                      & col___3);
#line 1450
                (*((*(AI + 0))->think))(State[0].ai_state, g___0 + 0, & State[0].cp,
                                        & State[0].np, col___3, row___3, pos[0].rot);
              } else {
#line 1451
                SDL_Delay(1U);
              }
            } else {
#line 1451
              SDL_Delay(1U);
            }
#line 1452
            if (State[1].ai) {
#line 1452
              if (State[1].draw) {
#line 1454
                screen_to_grid_coords(g___0 + 1, blockWidth, pos[1].x, pos[1].y, & row___4,
                                      & col___4);
#line 1455
                (*((*(AI + 1))->think))(State[1].ai_state, g___0 + 1, & State[1].cp,
                                        & State[1].np, col___4, row___4, pos[1].rot);
              } else {
#line 1456
                SDL_Delay(1U);
              }
            } else {
#line 1456
              SDL_Delay(1U);
            }
          } else {
#line 1457
            SDL_Delay(2U);
          }
        }
      }
    } else {
      _L___7: /* CIL Label */ 
#line 1458
      if (least > tv_now) {
#line 1458
        tmp___30 = SDL_PollEvent((SDL_Event *)((void *)0));
#line 1458
        if (! tmp___30) {
#line 1459
          SDL_Delay(least - tv_now);
        }
      }
    }
  }
}
}
#line 1 "fastrand.o"
#pragma merger(0,"/tmp/cil-KlUCIUX6.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 498 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 500
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 10 "fastrand.c"
static Uint32 randomSeed  ;
#line 12 "fastrand.c"
void SeedRandom(Uint32 Seed ) 
{ time_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 14
  if (! Seed) {
#line 15
    tmp = time((time_t *)((void *)0));
#line 15
    srand((unsigned int )tmp);
#line 16
    tmp___0 = rand();
#line 16
    tmp___1 = rand();
#line 16
    Seed = (unsigned int )((tmp___0 % 65535 << 16) | tmp___1 % 65535);
  }
#line 18
  randomSeed = Seed;
#line 19
  return;
}
}
#line 21 "fastrand.c"
Uint32 GetRandSeed(void) 
{ 

  {
#line 23
  return (randomSeed);
}
}
#line 27 "fastrand.c"
Uint16 FastRandom(Uint16 range ) 
{ Uint16 result ;
  register Uint32 calc ;
  register Uint32 regD0 ;
  register Uint32 regD1 ;
  register Uint32 regD2 ;

  {
#line 35
  calc = randomSeed;
#line 36
  regD0 = 16807U;
#line 37
  regD2 = regD0;
#line 39
  regD0 *= calc & 65535U;
#line 40
  regD1 = regD0;
#line 42
  regD1 >>= 16;
#line 44
  regD2 *= calc >> 16;
#line 45
  regD2 += regD1;
#line 46
  regD1 = regD2;
#line 47
  regD1 += regD1;
#line 49
  regD1 >>= 16;
#line 51
  regD0 &= 65535U;
#line 52
  regD0 -= 2147483647U;
#line 54
  regD2 &= 32767U;
#line 55
  regD2 = (regD2 << 16) + (regD2 >> 16);
#line 57
  regD2 += regD1;
#line 58
  regD0 += regD2;
#line 67
  randomSeed = regD0;
#line 68
  if ((regD0 & 65535U) == 32768U) {
#line 69
    regD0 &= 4294901760U;
  }
#line 73
  regD1 = (unsigned int )range;
#line 74
  regD1 *= regD0 & 65535U;
#line 75
  regD1 >>= 16;
#line 77
  result = (unsigned short )regD1;
#line 79
  return (result);
}
}
#line 1 "gamemenu.o"
#pragma merger(0,"/tmp/cil-UZYaJbhe.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 10 ".protos/sound.pro"
void play_all_sounds(sound_style *ss ) ;
#line 12 ".protos/menu.pro"
void clear_radio(WalkRadio *wr ) ;
#line 52 "gamemenu.c"
static int start_playing  =    0;
#line 53 "gamemenu.c"
static sound_styles *_ss  ;
#line 54 "gamemenu.c"
static color_styles *_cs  ;
#line 55 "gamemenu.c"
static piece_styles *_ps  ;
#line 56 "gamemenu.c"
static WalkRadioGroup *wrg  =    (WalkRadioGroup *)((void *)0);
#line 58 "gamemenu.c"
static GT _local_gametype  ;
#line 62 "gamemenu.c"
static void updateMenu(int whichSubMenu , int choice ) 
{ 

  {
#line 64
  *((wrg->wr + 5)->label + whichSubMenu) = *((wrg->wr + whichSubMenu)->label + choice);
#line 65
  clear_radio(wrg->wr + 5);
#line 66
  setup_radio(wrg->wr + 5);
#line 67
  (wrg->wr + 5)->x = (screen->w / 3 - (int )(wrg->wr + 5)->area.w) / 2;
#line 68
  (wrg->wr + 5)->y = (screen->h - (int )(wrg->wr + 5)->area.h) / 2;
#line 69
  return;
}
}
#line 71 "gamemenu.c"
char key_repeat_label[16]  = 
#line 71
  {      (char )'K',      (char )'e',      (char )'y',      (char )' ', 
        (char )'R',      (char )'e',      (char )'p',      (char )'e', 
        (char )'a',      (char )'t',      (char )':',      (char )' ', 
        (char )'1',      (char )'6',      (char )' ',      (char )'\000'};
#line 73 "gamemenu.c"
static void OptionsMenu_setup(void) 
{ 

  {
#line 75
  *((wrg->wr + 4)->label + 0) = (char *)"Toggle Full Screen";
#line 76
  if (Options.flame_wanted) {
#line 77
    *((wrg->wr + 4)->label + 1) = (char *)"Background Flame: On";
  } else {
#line 79
    *((wrg->wr + 4)->label + 1) = (char *)"Background Flame: Off";
  }
#line 80
  if (Options.special_wanted) {
#line 81
    *((wrg->wr + 4)->label + 2) = (char *)"Power Pieces: On";
  } else {
#line 83
    *((wrg->wr + 4)->label + 2) = (char *)"Power Pieces: Off";
  }
#line 84
  if (Options.faster_levels) {
#line 85
    *((wrg->wr + 4)->label + 3) = (char *)"Double Difficulty: On";
  } else {
#line 87
    *((wrg->wr + 4)->label + 3) = (char *)"Double Difficulty: Off";
  }
#line 88
  if (Options.long_settle_delay) {
#line 89
    *((wrg->wr + 4)->label + 4) = (char *)"Long Settle Delay: On";
  } else {
#line 91
    *((wrg->wr + 4)->label + 4) = (char *)"Long Settle Delay: Off";
  }
#line 92
  if (Options.upward_rotation) {
#line 93
    *((wrg->wr + 4)->label + 5) = (char *)"Upward Rotation: On";
  } else {
#line 95
    *((wrg->wr + 4)->label + 5) = (char *)"Upward Rotation: Off";
  }
#line 97
  sprintf((char * __restrict  )(key_repeat_label), (char const   * __restrict  )"Key Repeat: %.2d",
          Options.key_repeat_delay);
#line 98
  *((wrg->wr + 4)->label + 6) = key_repeat_label;
#line 99
  return;
}
}
#line 101 "gamemenu.c"
static int OptionsMenu_action(WalkRadio *wr ) 
{ 

  {
#line 103
  switch (wr->defaultchoice) {
  case 0: 
#line 105
  SDL_WM_ToggleFullScreen(screen);
#line 106
  break;
  case 1: 
#line 107
  Options.flame_wanted = ! Options.flame_wanted;
#line 107
  break;
  case 2: 
#line 108
  Options.special_wanted = ! Options.special_wanted;
#line 108
  break;
  case 3: 
#line 109
  Options.faster_levels = ! Options.faster_levels;
#line 109
  break;
  case 4: 
#line 110
  Options.long_settle_delay = ! Options.long_settle_delay;
#line 110
  break;
  case 5: 
#line 111
  Options.upward_rotation = ! Options.upward_rotation;
#line 111
  break;
  case 6: 
#line 112
  Options.key_repeat_delay = pick_key_repeat(screen);
#line 112
  break;
  default: ;
#line 114
  break;
  }
#line 116
  OptionsMenu_setup();
#line 117
  clear_radio(wrg->wr + 4);
#line 118
  setup_radio(wrg->wr + 4);
#line 119
  return (0);
}
}
#line 122 "gamemenu.c"
static int ColorStyleMenu_action(WalkRadio *wr ) 
{ 

  {
#line 124
  _cs->choice = wr->defaultchoice;
#line 126
  updateMenu(0, wr->defaultchoice);
#line 127
  return (1);
}
}
#line 129 "gamemenu.c"
static int SoundStyleMenu_action(WalkRadio *wr ) 
{ 

  {
#line 131
  _ss->choice = wr->defaultchoice;
#line 132
  play_all_sounds(*(_ss->style + _ss->choice));
#line 134
  updateMenu(1, wr->defaultchoice);
#line 135
  return (1);
}
}
#line 137 "gamemenu.c"
static int PieceStyleMenu_action(WalkRadio *wr ) 
{ 

  {
#line 139
  _ps->choice = wr->defaultchoice;
#line 141
  updateMenu(2, wr->defaultchoice);
#line 142
  return (1);
}
}
#line 144 "gamemenu.c"
static int GameMenu_action(WalkRadio *wr ) 
{ 

  {
#line 146
  _local_gametype = (enum __anonenum_GT_50 )wr->defaultchoice;
#line 149
  updateMenu(3, wr->defaultchoice);
#line 150
  return (1);
}
}
#line 153 "gamemenu.c"
static int MainMenu_action(WalkRadio *wr ) 
{ int i ;

  {
#line 157
  switch (wr->defaultchoice) {
  case 0: 
  case 1: 
  case 2: 
  case 3: 
  case 4: 
#line 164
  i = 0;
#line 164
  while (i < 5) {
#line 165
    if ((wrg->wr + i)->inactive == 0) {
#line 166
      (wrg->wr + i)->inactive = 1;
#line 167
      clear_radio(wrg->wr + i);
    }
#line 164
    i ++;
  }
#line 170
  (wrg->wr + wr->defaultchoice)->inactive = 0;
#line 171
  wrg->cur = wr->defaultchoice;
#line 172
  break;
  case 5: 
#line 174
  start_playing = 1;
#line 175
  gametype = _local_gametype;
#line 176
  break;
  case 6: 
#line 178
  start_playing = 1;
#line 179
  gametype = 6;
#line 180
  break;
  default: 
#line 182
  printf((char const   * __restrict  )"%-14.14s| ", "MainMenu_action");
#line 182
  printf((char const   * __restrict  )"Invalid menu choice %d.\n", wr->defaultchoice);
#line 182
  fflush(stdout);
  }
#line 184
  return (1);
}
}
#line 191 "gamemenu.c"
static int menu_handler(SDL_Event const   *event ) 
{ int retval ;

  {
#line 195
  if ((int const   )event->type == 2) {
#line 196
    switch ((int )event->key.keysym.sym) {
    case 113: 
#line 198
    start_playing = 1;
#line 199
    gametype = 6;
#line 199
    _local_gametype = gametype;
#line 200
    return (1);
    case 13: 
#line 203
    if ((int const   )event->key.keysym.mod & 64) {
#line 205
      SDL_WM_ToggleFullScreen(screen);
#line 206
      return (1);
    } else {
#line 203
      if ((int const   )event->key.keysym.mod & 128) {
#line 205
        SDL_WM_ToggleFullScreen(screen);
#line 206
        return (1);
      }
    }
    default: ;
#line 210
    break;
    }
  }
#line 213
  retval = handle_radio_event(wrg, event);
#line 215
  if (retval != -1) {
#line 216
    return (1);
  }
#line 217
  return (0);
}
}
#line 224 "gamemenu.c"
static int play_MENU(color_styles cs , piece_styles ps , sound_styles ss , Grid *g___0 ,
                     int my_level , AI_Player *aip ) 
{ int curtimeleft ;
  int match ;
  int level[2] ;
  int adjustment[2] ;
  int my_adj[3] ;
  int result ;
  color_style *event_cs___0[2] ;
  sound_style *event_ss___0[2] ;
  AI_Player *event_ai___0[2] ;
  int i ;
  time_t tmp ;

  {
#line 231
  adjustment[0] = -1;
#line 231
  adjustment[1] = -1;
#line 239
  level[0] = my_level;
#line 240
  Score[1] = 0;
#line 240
  Score[0] = Score[1];
#line 241
  SeedRandom(0U);
#line 243
  while (1) {
#line 246
    curtimeleft = 300;
#line 247
    my_adj[0] = 0;
#line 247
    my_adj[1] = 1;
#line 247
    my_adj[2] = 2;
#line 249
    match = 0;
#line 249
    while (1) {
#line 249
      if (match < 3) {
#line 249
        if (! (curtimeleft > 0)) {
#line 249
          break;
        }
      } else {
#line 249
        break;
      }
#line 252
      *(g___0 + 0) = generate_board(10, 20, level[0]);
#line 253
      draw_background(screen, (*(cs.style + 0))->w, g___0, level, my_adj, (int *)((void *)0),
                      & aip->name);
#line 257
      i = 0;
#line 257
      while (i < 6) {
#line 258
        draw_radio(wrg->wr + i, i == wrg->cur);
#line 257
        i ++;
      }
#line 262
      event_cs___0[1] = *(cs.style + cs.choice);
#line 262
      event_cs___0[0] = event_cs___0[1];
#line 263
      event_ss___0[1] = *(ss.style + ss.choice);
#line 263
      event_ss___0[0] = event_ss___0[1];
#line 264
      event_ai___0[0] = aip;
#line 265
      event_ai___0[1] = (AI_Player *)((void *)0);
#line 267
      tmp = time((time_t *)((void *)0));
#line 267
      result = event_loop(screen, *(ps.style + ps.choice), (color_style **)(event_cs___0),
                          (sound_style **)(event_ss___0), g___0, (int *)(level), 0,
                          & curtimeleft, 1, adjustment, & menu_handler, (int )tmp,
                          2, 0, (AI_Player **)(event_ai___0));
#line 271
      if (result < 0) {
#line 272
        return (-1);
      }
#line 275
      my_adj[match] = adjustment[0];
#line 249
      match ++;
    }
  }
}
}
#line 286 "gamemenu.c"
int choose_gametype(piece_styles *ps , color_styles *cs , sound_styles *ss , AI_Players *ai ) 
{ int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  Grid g___0[2] ;
  Uint16 tmp___7 ;
  int tmp___8 ;

  {
#line 291
  _local_gametype = gametype;
#line 293
  if (! wrg) {
#line 294
    tmp = calloc(sizeof(*wrg), 1U);
#line 294
    wrg = (WalkRadioGroup *)tmp;
#line 294
    if (! wrg) {
#line 294
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for wrg",
            sizeof(*wrg));
    }
#line 295
    wrg->n = 6;
#line 296
    tmp___0 = calloc((unsigned int )wrg->n * sizeof(*(wrg->wr)), 1U);
#line 296
    wrg->wr = (WalkRadio *)tmp___0;
#line 296
    if (! wrg->wr) {
#line 296
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for wrg->wr",
            (unsigned int )wrg->n * sizeof(*(wrg->wr)));
    }
#line 297
    wrg->cur = 5;
#line 299
    (wrg->wr + 2)->n = ps->num_style;
#line 300
    tmp___1 = malloc(sizeof(char *) * (unsigned int )ps->num_style);
#line 300
    (wrg->wr + 2)->label = (char **)tmp___1;
#line 300
    if (! (wrg->wr + 2)->label) {
#line 300
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for wrg->wr[PieceStyleMenu].label",
            sizeof(char *) * (unsigned int )ps->num_style);
    }
#line 301
    i = 0;
#line 301
    while (i < ps->num_style) {
#line 302
      *((wrg->wr + 2)->label + i) = (*(ps->style + i))->name;
#line 301
      i ++;
    }
#line 303
    (wrg->wr + 2)->defaultchoice = ps->choice;
#line 304
    (wrg->wr + 2)->action = & PieceStyleMenu_action;
#line 306
    (wrg->wr + 0)->n = cs->num_style;
#line 307
    tmp___2 = malloc(sizeof(char *) * (unsigned int )cs->num_style);
#line 307
    (wrg->wr + 0)->label = (char **)tmp___2;
#line 307
    if (! (wrg->wr + 0)->label) {
#line 307
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for wrg->wr[ColorStyleMenu].label",
            sizeof(char *) * (unsigned int )cs->num_style);
    }
#line 308
    i = 0;
#line 308
    while (i < cs->num_style) {
#line 309
      *((wrg->wr + 0)->label + i) = (*(cs->style + i))->name;
#line 308
      i ++;
    }
#line 310
    (wrg->wr + 0)->defaultchoice = cs->choice;
#line 311
    (wrg->wr + 0)->action = & ColorStyleMenu_action;
#line 313
    (wrg->wr + 1)->n = ss->num_style;
#line 314
    tmp___3 = malloc(sizeof(char *) * (unsigned int )ss->num_style);
#line 314
    (wrg->wr + 1)->label = (char **)tmp___3;
#line 314
    if (! (wrg->wr + 1)->label) {
#line 314
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for wrg->wr[SoundStyleMenu].label",
            sizeof(char *) * (unsigned int )ss->num_style);
    }
#line 315
    i = 0;
#line 315
    while (i < ss->num_style) {
#line 316
      *((wrg->wr + 1)->label + i) = (*(ss->style + i))->name;
#line 315
      i ++;
    }
#line 317
    (wrg->wr + 1)->defaultchoice = ss->choice;
#line 318
    (wrg->wr + 1)->action = & SoundStyleMenu_action;
#line 320
    _ss = ss;
#line 321
    _cs = cs;
#line 322
    _ps = ps;
#line 324
    (wrg->wr + 3)->n = 6;
#line 325
    tmp___4 = malloc(sizeof(char *) * (unsigned int )(wrg->wr + 3)->n);
#line 325
    (wrg->wr + 3)->label = (char **)tmp___4;
#line 325
    if (! (wrg->wr + 3)->label) {
#line 325
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for wrg->wr[GameMenu].label",
            sizeof(char *) * (unsigned int )(wrg->wr + 3)->n);
    }
#line 326
    *((wrg->wr + 3)->label + 0) = (char *)"Solo Normal Game";
#line 327
    *((wrg->wr + 3)->label + 1) = (char *)"Solo Scoring Marathon";
#line 328
    *((wrg->wr + 3)->label + 2) = (char *)"Solo vs. Computer";
#line 329
    *((wrg->wr + 3)->label + 3) = (char *)"2 Players @ 1 Keyboard";
#line 330
    *((wrg->wr + 3)->label + 4) = (char *)"2 Players, Use Network";
#line 331
    *((wrg->wr + 3)->label + 5) = (char *)"Computer vs. Computer";
#line 332
    (wrg->wr + 3)->defaultchoice = 0;
#line 333
    (wrg->wr + 3)->action = & GameMenu_action;
#line 335
    (wrg->wr + 4)->n = 7;
#line 336
    tmp___5 = malloc(sizeof(char *) * (unsigned int )(wrg->wr + 4)->n);
#line 336
    (wrg->wr + 4)->label = (char **)tmp___5;
#line 336
    if (! (wrg->wr + 4)->label) {
#line 336
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for wrg->wr[OptionsMenu].label",
            sizeof(char *) * (unsigned int )(wrg->wr + 4)->n);
    }
#line 337
    OptionsMenu_setup();
#line 338
    (wrg->wr + 4)->defaultchoice = 0;
#line 339
    (wrg->wr + 4)->action = & OptionsMenu_action;
#line 342
    (wrg->wr + 5)->n = 7;
#line 343
    tmp___6 = malloc(sizeof(char *) * (unsigned int )(wrg->wr + 5)->n);
#line 343
    (wrg->wr + 5)->label = (char **)tmp___6;
#line 343
    if (! (wrg->wr + 5)->label) {
#line 343
      Panic("choose_gametype", "gamemenu.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for wrg->wr[MainMenu].label",
            sizeof(char *) * (unsigned int )(wrg->wr + 5)->n);
    }
#line 345
    *((wrg->wr + 5)->label + 0) = *((wrg->wr + 0)->label + (wrg->wr + 0)->defaultchoice);
#line 346
    *((wrg->wr + 5)->label + 1) = *((wrg->wr + 1)->label + (wrg->wr + 1)->defaultchoice);
#line 347
    *((wrg->wr + 5)->label + 2) = *((wrg->wr + 2)->label + (wrg->wr + 2)->defaultchoice);
#line 348
    *((wrg->wr + 5)->label + 3) = *((wrg->wr + 3)->label + (int )_local_gametype);
#line 349
    *((wrg->wr + 5)->label + 4) = (char *)"Special Options";
#line 350
    *((wrg->wr + 5)->label + 5) = (char *)"Play!";
#line 351
    *((wrg->wr + 5)->label + 6) = (char *)"Quit";
#line 352
    (wrg->wr + 5)->defaultchoice = 5;
#line 353
    (wrg->wr + 5)->action = & MainMenu_action;
#line 355
    i = 0;
#line 355
    while (i < 6) {
#line 356
      setup_radio(wrg->wr + i);
#line 355
      i ++;
    }
#line 359
    (wrg->wr + 0)->x = 2 * (screen->w / 3) + (screen->w / 3 - (int )(wrg->wr + 0)->area.w) / 2;
#line 361
    (wrg->wr + 0)->y = (screen->h - (int )(wrg->wr + 0)->area.h) / 2;
#line 363
    (wrg->wr + 0)->inactive = 1;
#line 365
    (wrg->wr + 1)->x = 2 * (screen->w / 3) + (screen->w / 3 - (int )(wrg->wr + 1)->area.w) / 2;
#line 367
    (wrg->wr + 1)->y = (screen->h - (int )(wrg->wr + 1)->area.h) / 2;
#line 369
    (wrg->wr + 1)->inactive = 1;
#line 371
    (wrg->wr + 4)->x = 2 * (screen->w / 3) + (screen->w / 3 - (int )(wrg->wr + 4)->area.w) / 2;
#line 373
    (wrg->wr + 4)->y = (screen->h - (int )(wrg->wr + 4)->area.h) / 2;
#line 375
    (wrg->wr + 4)->inactive = 1;
#line 377
    (wrg->wr + 2)->x = 2 * (screen->w / 3) + (screen->w / 3 - (int )(wrg->wr + 2)->area.w) / 2;
#line 379
    (wrg->wr + 2)->y = (screen->h - (int )(wrg->wr + 2)->area.h) / 2;
#line 381
    (wrg->wr + 2)->inactive = 1;
#line 383
    (wrg->wr + 3)->x = 2 * (screen->w / 3) + (screen->w / 3 - (int )(wrg->wr + 3)->area.w) / 2;
#line 385
    (wrg->wr + 3)->y = (screen->h - (int )(wrg->wr + 3)->area.h) / 2;
#line 387
    (wrg->wr + 3)->inactive = 1;
#line 389
    (wrg->wr + 5)->x = (screen->w / 3 - (int )(wrg->wr + 5)->area.w) / 2;
#line 390
    (wrg->wr + 5)->y = (screen->h - (int )(wrg->wr + 5)->area.h) / 2;
#line 391
    (wrg->wr + 5)->inactive = 0;
  }
#line 394
  clear_screen_to_flame();
#line 395
  SDL_EnableKeyRepeat(5000, 300);
#line 398
  start_playing = 0;
#line 399
  while (1) {
#line 401
    gametype = 7;
#line 402
    tmp___7 = FastRandom((unsigned short )ai->n);
#line 402
    if (Options.faster_levels) {
#line 402
      tmp___8 = 5;
    } else {
#line 402
      tmp___8 = 10;
    }
#line 402
    play_MENU(*cs, *ps, *ss, g___0, tmp___8, ai->player + tmp___7);
#line 404
    if (start_playing) {
#line 405
      return (0);
    }
  }
}
}
#line 1 "grid.o"
#pragma merger(0,"/tmp/cil-TnTVfGLO.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 22 "grid.c"
void cleanup_grid(Grid *g___0 ) 
{ int x ;
  int y ;

  {
#line 26
  y = g___0->h - 1;
#line 26
  while (y >= 0) {
#line 27
    x = g___0->w - 1;
#line 27
    while (x >= 0) {
#line 28
      if ((int )*(g___0->contents + (x + y * g___0->w)) == 255) {
#line 29
        *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->contents + (x + y * g___0->w)) != 0));
#line 29
        *(g___0->contents + (x + y * g___0->w)) = (unsigned char)0;
      }
#line 27
      x --;
    }
#line 26
    y --;
  }
#line 30
  return;
}
}
#line 36 "grid.c"
Grid generate_board(int w___1 , int h___1 , int level ) 
{ int i ;
  int j ;
  int r ;
  Grid retval ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int start_garbage ;
  Uint16 tmp___3 ;

  {
#line 43
  retval.w = w___1;
#line 44
  retval.h = h___1;
#line 46
  tmp = calloc((unsigned int )(w___1 * h___1) * sizeof(*(retval.contents)), 1U);
#line 46
  retval.contents = (unsigned char *)tmp;
#line 46
  if (! retval.contents) {
#line 46
    Panic("generate_board", "grid.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.contents",
          (unsigned int )(w___1 * h___1) * sizeof(*(retval.contents)));
  }
#line 47
  tmp___0 = calloc((unsigned int )(w___1 * h___1) * sizeof(*(retval.fall)), 1U);
#line 47
  retval.fall = (unsigned char *)tmp___0;
#line 47
  if (! retval.fall) {
#line 47
    Panic("generate_board", "grid.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.fall",
          (unsigned int )(w___1 * h___1) * sizeof(*(retval.fall)));
  }
#line 48
  tmp___1 = calloc((unsigned int )(w___1 * h___1) * sizeof(*(retval.changed)), 1U);
#line 48
  retval.changed = (unsigned char *)tmp___1;
#line 48
  if (! retval.changed) {
#line 48
    Panic("generate_board", "grid.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.changed",
          (unsigned int )(w___1 * h___1) * sizeof(*(retval.changed)));
  }
#line 49
  tmp___2 = calloc((unsigned int )(w___1 * h___1) * sizeof(*(retval.temp)), 1U);
#line 49
  retval.temp = (unsigned char *)tmp___2;
#line 49
  if (! retval.temp) {
#line 49
    Panic("generate_board", "grid.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.temp",
          (unsigned int )(w___1 * h___1) * sizeof(*(retval.temp)));
  }
#line 51
  if (level) {
#line 53
    if (Options.faster_levels) {
#line 53
      level = level;
    } else {
#line 53
      level /= 2;
    }
#line 54
    start_garbage = (h___1 - level) - 2;
#line 56
    if (start_garbage < 2) {
#line 56
      start_garbage = 2;
    } else {
#line 57
      if (start_garbage >= h___1) {
#line 57
        start_garbage = h___1 - 1;
      }
    }
#line 59
    j = start_garbage;
#line 59
    while (j < h___1) {
#line 60
      r = 0;
#line 60
      while (r < w___1 / 2) {
#line 61
        while (1) {
#line 62
          tmp___3 = FastRandom((unsigned short )w___1);
#line 62
          i = (int )tmp___3;
#line 61
          if (! ((int )*(retval.contents + (i + j * retval.w)) == 1)) {
#line 61
            break;
          }
        }
#line 64
        *(retval.changed + (i + j * retval.w)) = (unsigned char )((int )*(retval.changed + (i + j * retval.w)) | ((int )*(retval.contents + (i + j * retval.w)) != 1));
#line 64
        *(retval.contents + (i + j * retval.w)) = (unsigned char)1;
#line 60
        r ++;
      }
#line 59
      j ++;
    }
  }
#line 67
  return (retval);
}
}
#line 75 "grid.c"
void add_garbage(Grid *g___0 ) 
{ int i ;
  int j ;
  Uint16 tmp ;

  {
#line 79
  j = 0;
#line 79
  while (j < g___0->h - 1) {
#line 80
    i = 0;
#line 80
    while (i < g___0->w) {
#line 81
      *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->contents + (i + j * g___0->w)) != (int )*(g___0->contents + (i + (j + 1) * g___0->w))));
#line 81
      *(g___0->contents + (i + j * g___0->w)) = *(g___0->contents + (i + (j + 1) * g___0->w));
#line 82
      *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->fall + (i + j * g___0->w)) != 1));
#line 82
      *(g___0->fall + (i + j * g___0->w)) = (unsigned char)1;
#line 83
      if ((int )*(g___0->contents + (i + j * g___0->w)) == 0) {
#line 84
        *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->contents + (i + j * g___0->w)) != 255));
#line 84
        *(g___0->contents + (i + j * g___0->w)) = (unsigned char)255;
      }
#line 85
      *(g___0->changed + (i + j * g___0->w)) = (unsigned char)1;
#line 80
      i ++;
    }
#line 79
    j ++;
  }
#line 88
  j = g___0->h - 1;
#line 89
  i = 0;
#line 89
  while (i < g___0->w) {
#line 90
    tmp = FastRandom((unsigned short)100);
#line 90
    if ((int )tmp < 50) {
#line 91
      *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->contents + (i + j * g___0->w)) != 1));
#line 91
      *(g___0->contents + (i + j * g___0->w)) = (unsigned char)1;
#line 92
      if (*(g___0->contents + (i + (j - 1) * g___0->w))) {
#line 92
        if ((int )*(g___0->contents + (i + (j - 1) * g___0->w)) != 255) {
#line 94
          *(g___0->changed + (i + (j - 1) * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + (j - 1) * g___0->w)) | ((int )*(g___0->contents + (i + (j - 1) * g___0->w)) != 1));
#line 94
          *(g___0->contents + (i + (j - 1) * g___0->w)) = (unsigned char)1;
        }
      }
    } else {
#line 96
      *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->contents + (i + j * g___0->w)) != 255));
#line 96
      *(g___0->contents + (i + j * g___0->w)) = (unsigned char)255;
    }
#line 98
    *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->fall + (i + j * g___0->w)) != 1));
#line 98
    *(g___0->fall + (i + j * g___0->w)) = (unsigned char)1;
#line 99
    *(g___0->changed + (i + j * g___0->w)) = (unsigned char)1;
#line 89
    i ++;
  }
#line 102
  j = 0;
#line 102
  while (j < g___0->h) {
#line 103
    i = 0;
#line 103
    while (i < g___0->w) {
#line 104
      if (! *(g___0->changed + (i + j * g___0->w))) {
#line 104
        Panic("add_garbage", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
              "((*g).changed[(i) + ((j)*((*g).w))])", 104);
      }
#line 105
      if (! ((int )*(g___0->fall + (i + j * g___0->w)) == 1)) {
#line 105
        Panic("add_garbage", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
              "((*g).fall[(i) + ((j)*((*g).w))]) == 1", 105);
      }
#line 103
      i ++;
    }
#line 102
    j ++;
  }
#line 108
  return;
}
}
#line 120 "grid.c"
void draw_grid(SDL_Surface *screen___0 , color_style *cs , Grid *g___0 , int draw ) 
{ SDL_Rect r ;
  SDL_Rect s ;
  int i ;
  int j ;
  int mini ;
  int minj ;
  int maxi ;
  int maxj ;
  int c ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  int fall ;
  int that_precolor ;
  int tmp___0 ;
  int that_fall ;
  int tmp___1 ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  SDL_Rect *my_b___1 ;
  SDL_Rect *my_d___1 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  SDL_Rect *my_b___2 ;
  SDL_Rect *my_d___2 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  SDL_Rect *my_b___3 ;
  SDL_Rect *my_d___3 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  SDL_Rect *my_c ;

  {
#line 125
  mini = 20;
#line 125
  minj = 20;
#line 125
  maxi = -1;
#line 125
  maxj = -1;
#line 126
  j = g___0->h - 1;
#line 126
  while (j >= 0) {
#line 127
    i = g___0->w - 1;
#line 127
    while (i >= 0) {
#line 128
      c = (int )*(g___0->contents + (i + j * g___0->w));
#line 129
      if (draw) {
#line 129
        if (c) {
#line 129
          if (c != 255) {
#line 129
            if (*(g___0->changed + (i + j * g___0->w))) {
#line 130
              if (i < mini) {
#line 130
                mini = i;
              }
#line 130
              if (j < minj) {
#line 130
                minj = j;
              }
#line 131
              if (i > maxi) {
#line 131
                maxi = i;
              }
#line 131
              if (j > maxj) {
#line 131
                maxj = j;
              }
#line 134
              s.x = (short )((int )g___0->board.x + i * cs->w);
#line 135
              s.y = (short )((int )g___0->board.y + j * cs->h);
#line 136
              s.w = (unsigned short )cs->w;
#line 137
              s.h = (unsigned short )cs->h;
#line 139
              my_b = (SDL_Rect *)((void *)0);
#line 139
              my_d = & s;
#line 139
              if (my_b) {
#line 139
                if ((int )my_b->x < 0) {
#line 139
                  my_b->x = (short)0;
                }
#line 139
                if ((int )my_b->y < 0) {
#line 139
                  my_b->y = (short)0;
                }
#line 139
                if ((int )my_b->x + (int )my_b->w > 640) {
#line 139
                  my_b->w = (unsigned short )(640 - (int )my_b->x);
                }
#line 139
                if ((int )my_b->y + (int )my_b->h > 480) {
#line 139
                  my_b->h = (unsigned short )(480 - (int )my_b->y);
                }
              }
#line 139
              if (my_d) {
#line 139
                if ((int )my_d->x < 0) {
#line 139
                  my_d->x = (short)0;
                }
#line 139
                if ((int )my_d->y < 0) {
#line 139
                  my_d->y = (short)0;
                }
#line 139
                if ((int )my_d->x + (int )my_d->w > 640) {
#line 139
                  my_d->w = (unsigned short )(640 - (int )my_d->x);
                }
#line 139
                if ((int )my_d->y + (int )my_d->h > 480) {
#line 139
                  my_d->h = (unsigned short )(480 - (int )my_d->y);
                }
              }
#line 139
              tmp = SDL_UpperBlit(*(cs->color + c), my_b, screen___0, my_d);
#line 139
              if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 139
                Panic("draw_grid", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                      "SDL_UpperBlit(cs->color[c],my_b,screen,my_d) == 0", 139);
              }
#line 142
              fall = (int )*(g___0->fall + (i + j * g___0->w));
#line 144
              if (j == 0) {
#line 144
                tmp___0 = 0;
              } else {
#line 144
                tmp___0 = (int )*(g___0->contents + (i + (j - 1) * g___0->w));
              }
#line 144
              that_precolor = tmp___0;
#line 146
              if (j == 0) {
#line 146
                tmp___1 = -1;
              } else {
#line 146
                tmp___1 = (int )*(g___0->fall + (i + (j - 1) * g___0->w));
              }
#line 146
              that_fall = tmp___1;
#line 149
              if (that_precolor != c) {
                goto _L;
              } else {
#line 149
                if (that_fall != fall) {
                  _L: /* CIL Label */ 
#line 150
                  r.x = (short )((int )g___0->board.x + i * cs->w);
#line 151
                  r.y = (short )((int )g___0->board.y + j * cs->h);
#line 152
                  r.h = (unsigned short )(edge[0])->h;
#line 153
                  r.w = (unsigned short )(edge[0])->w;
#line 154
                  my_b___0 = (SDL_Rect *)((void *)0);
#line 154
                  my_d___0 = & r;
#line 154
                  if (my_b___0) {
#line 154
                    if ((int )my_b___0->x < 0) {
#line 154
                      my_b___0->x = (short)0;
                    }
#line 154
                    if ((int )my_b___0->y < 0) {
#line 154
                      my_b___0->y = (short)0;
                    }
#line 154
                    if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 154
                      my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
                    }
#line 154
                    if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 154
                      my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
                    }
                  }
#line 154
                  if (my_d___0) {
#line 154
                    if ((int )my_d___0->x < 0) {
#line 154
                      my_d___0->x = (short)0;
                    }
#line 154
                    if ((int )my_d___0->y < 0) {
#line 154
                      my_d___0->y = (short)0;
                    }
#line 154
                    if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 154
                      my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
                    }
#line 154
                    if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 154
                      my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
                    }
                  }
#line 154
                  tmp___2 = SDL_UpperBlit(edge[0], my_b___0, screen___0, my_d___0);
#line 154
                  if (! (tmp___2 == (int __attribute__((__visibility__("default")))  )0)) {
#line 154
                    Panic("draw_grid", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(edge[0],my_b,screen,my_d) == 0", 155);
                  }
                }
              }
#line 159
              if (i == 0) {
#line 159
                that_precolor = 0;
              } else {
#line 159
                that_precolor = (int )*(g___0->contents + ((i - 1) + j * g___0->w));
              }
#line 161
              if (i == 0) {
#line 161
                that_fall = -1;
              } else {
#line 161
                that_fall = (int )*(g___0->fall + ((i - 1) + j * g___0->w));
              }
#line 163
              if (that_precolor != c) {
                goto _L___0;
              } else {
#line 163
                if (that_fall != fall) {
                  _L___0: /* CIL Label */ 
#line 164
                  r.x = (short )((int )g___0->board.x + i * cs->w);
#line 165
                  r.y = (short )((int )g___0->board.y + j * cs->h);
#line 166
                  r.h = (unsigned short )(edge[1])->h;
#line 167
                  r.w = (unsigned short )(edge[1])->w;
#line 168
                  my_b___1 = (SDL_Rect *)((void *)0);
#line 168
                  my_d___1 = & r;
#line 168
                  if (my_b___1) {
#line 168
                    if ((int )my_b___1->x < 0) {
#line 168
                      my_b___1->x = (short)0;
                    }
#line 168
                    if ((int )my_b___1->y < 0) {
#line 168
                      my_b___1->y = (short)0;
                    }
#line 168
                    if ((int )my_b___1->x + (int )my_b___1->w > 640) {
#line 168
                      my_b___1->w = (unsigned short )(640 - (int )my_b___1->x);
                    }
#line 168
                    if ((int )my_b___1->y + (int )my_b___1->h > 480) {
#line 168
                      my_b___1->h = (unsigned short )(480 - (int )my_b___1->y);
                    }
                  }
#line 168
                  if (my_d___1) {
#line 168
                    if ((int )my_d___1->x < 0) {
#line 168
                      my_d___1->x = (short)0;
                    }
#line 168
                    if ((int )my_d___1->y < 0) {
#line 168
                      my_d___1->y = (short)0;
                    }
#line 168
                    if ((int )my_d___1->x + (int )my_d___1->w > 640) {
#line 168
                      my_d___1->w = (unsigned short )(640 - (int )my_d___1->x);
                    }
#line 168
                    if ((int )my_d___1->y + (int )my_d___1->h > 480) {
#line 168
                      my_d___1->h = (unsigned short )(480 - (int )my_d___1->y);
                    }
                  }
#line 168
                  tmp___3 = SDL_UpperBlit(edge[1], my_b___1, screen___0, my_d___1);
#line 168
                  if (! (tmp___3 == (int __attribute__((__visibility__("default")))  )0)) {
#line 168
                    Panic("draw_grid", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(edge[1],my_b,screen,my_d) == 0", 169);
                  }
                }
              }
#line 173
              if (j == g___0->h - 1) {
#line 173
                that_precolor = 0;
              } else {
#line 173
                that_precolor = (int )*(g___0->contents + (i + (j + 1) * g___0->w));
              }
#line 175
              if (j == g___0->h - 1) {
#line 175
                that_fall = -1;
              } else {
#line 175
                that_fall = (int )*(g___0->fall + (i + (j + 1) * g___0->w));
              }
#line 177
              if (that_precolor != c) {
                goto _L___1;
              } else {
#line 177
                if (that_fall != fall) {
                  _L___1: /* CIL Label */ 
#line 178
                  r.x = (short )((int )g___0->board.x + i * cs->w);
#line 179
                  r.y = (short )(((int )g___0->board.y + (j + 1) * cs->h) - (edge[2])->h);
#line 181
                  r.h = (unsigned short )(edge[2])->h;
#line 182
                  r.w = (unsigned short )(edge[2])->w;
#line 183
                  my_b___2 = (SDL_Rect *)((void *)0);
#line 183
                  my_d___2 = & r;
#line 183
                  if (my_b___2) {
#line 183
                    if ((int )my_b___2->x < 0) {
#line 183
                      my_b___2->x = (short)0;
                    }
#line 183
                    if ((int )my_b___2->y < 0) {
#line 183
                      my_b___2->y = (short)0;
                    }
#line 183
                    if ((int )my_b___2->x + (int )my_b___2->w > 640) {
#line 183
                      my_b___2->w = (unsigned short )(640 - (int )my_b___2->x);
                    }
#line 183
                    if ((int )my_b___2->y + (int )my_b___2->h > 480) {
#line 183
                      my_b___2->h = (unsigned short )(480 - (int )my_b___2->y);
                    }
                  }
#line 183
                  if (my_d___2) {
#line 183
                    if ((int )my_d___2->x < 0) {
#line 183
                      my_d___2->x = (short)0;
                    }
#line 183
                    if ((int )my_d___2->y < 0) {
#line 183
                      my_d___2->y = (short)0;
                    }
#line 183
                    if ((int )my_d___2->x + (int )my_d___2->w > 640) {
#line 183
                      my_d___2->w = (unsigned short )(640 - (int )my_d___2->x);
                    }
#line 183
                    if ((int )my_d___2->y + (int )my_d___2->h > 480) {
#line 183
                      my_d___2->h = (unsigned short )(480 - (int )my_d___2->y);
                    }
                  }
#line 183
                  tmp___4 = SDL_UpperBlit(edge[2], my_b___2, screen___0, my_d___2);
#line 183
                  if (! (tmp___4 == (int __attribute__((__visibility__("default")))  )0)) {
#line 183
                    Panic("draw_grid", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(edge[2],my_b,screen,my_d) == 0", 184);
                  }
                }
              }
#line 188
              if (i == g___0->w - 1) {
#line 188
                that_precolor = 0;
              } else {
#line 188
                that_precolor = (int )*(g___0->contents + ((i + 1) + j * g___0->w));
              }
#line 190
              if (i == g___0->w - 1) {
#line 190
                that_fall = -1;
              } else {
#line 190
                that_fall = (int )*(g___0->fall + ((i + 1) + j * g___0->w));
              }
#line 192
              if (that_precolor != c) {
                goto _L___2;
              } else {
#line 192
                if (that_fall != fall) {
                  _L___2: /* CIL Label */ 
#line 193
                  r.x = (short )(((int )g___0->board.x + (i + 1) * cs->w) - (edge[3])->w);
#line 195
                  r.y = (short )((int )g___0->board.y + j * cs->h);
#line 196
                  r.h = (unsigned short )(edge[3])->h;
#line 197
                  r.w = (unsigned short )(edge[3])->w;
#line 198
                  my_b___3 = (SDL_Rect *)((void *)0);
#line 198
                  my_d___3 = & r;
#line 198
                  if (my_b___3) {
#line 198
                    if ((int )my_b___3->x < 0) {
#line 198
                      my_b___3->x = (short)0;
                    }
#line 198
                    if ((int )my_b___3->y < 0) {
#line 198
                      my_b___3->y = (short)0;
                    }
#line 198
                    if ((int )my_b___3->x + (int )my_b___3->w > 640) {
#line 198
                      my_b___3->w = (unsigned short )(640 - (int )my_b___3->x);
                    }
#line 198
                    if ((int )my_b___3->y + (int )my_b___3->h > 480) {
#line 198
                      my_b___3->h = (unsigned short )(480 - (int )my_b___3->y);
                    }
                  }
#line 198
                  if (my_d___3) {
#line 198
                    if ((int )my_d___3->x < 0) {
#line 198
                      my_d___3->x = (short)0;
                    }
#line 198
                    if ((int )my_d___3->y < 0) {
#line 198
                      my_d___3->y = (short)0;
                    }
#line 198
                    if ((int )my_d___3->x + (int )my_d___3->w > 640) {
#line 198
                      my_d___3->w = (unsigned short )(640 - (int )my_d___3->x);
                    }
#line 198
                    if ((int )my_d___3->y + (int )my_d___3->h > 480) {
#line 198
                      my_d___3->h = (unsigned short )(480 - (int )my_d___3->y);
                    }
                  }
#line 198
                  tmp___5 = SDL_UpperBlit(edge[3], my_b___3, screen___0, my_d___3);
#line 198
                  if (! (tmp___5 == (int __attribute__((__visibility__("default")))  )0)) {
#line 198
                    Panic("draw_grid", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(edge[3],my_b,screen,my_d) == 0", 199);
                  }
                }
              }
#line 203
              *(g___0->changed + (i + j * g___0->w)) = (unsigned char)0;
            } else {
              goto _L___5;
            }
          } else {
            goto _L___5;
          }
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
#line 204
        if (c == 255) {
#line 205
          if (i < mini) {
#line 205
            mini = i;
          }
#line 205
          if (j < minj) {
#line 205
            minj = j;
          }
#line 206
          if (i > maxi) {
#line 206
            maxi = i;
          }
#line 206
          if (j > maxj) {
#line 206
            maxj = j;
          }
#line 207
          if (draw) {
#line 208
            s.x = (short )((int )g___0->board.x + i * cs->w);
#line 209
            s.y = (short )((int )g___0->board.y + j * cs->h);
#line 210
            s.w = (unsigned short )cs->w;
#line 211
            s.h = (unsigned short )cs->h;
#line 212
            SDL_FillRect(screen___0, & s, int_solid_black);
#line 213
            *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->contents + (i + j * g___0->w)) != 0));
#line 213
            *(g___0->contents + (i + j * g___0->w)) = (unsigned char)0;
#line 214
            *(g___0->changed + (i + j * g___0->w)) = (unsigned char)0;
          } else {
#line 216
            *(g___0->changed + (i + j * g___0->w)) = (unsigned char )((int )*(g___0->changed + (i + j * g___0->w)) | ((int )*(g___0->contents + (i + j * g___0->w)) != 0));
#line 216
            *(g___0->contents + (i + j * g___0->w)) = (unsigned char)0;
          }
        }
      }
#line 127
      i --;
    }
#line 126
    j --;
  }
#line 221
  s.x = (short )((int )g___0->board.x + mini * cs->w);
#line 222
  s.y = (short )((int )g___0->board.y + minj * cs->h);
#line 223
  s.w = (unsigned short )(((maxi - mini) + 1) * cs->w);
#line 224
  s.h = (unsigned short )(((maxj - minj) + 1) * cs->h);
#line 225
  if (draw) {
#line 225
    if (maxi > -1) {
#line 225
      my_c = & s;
#line 225
      if (! my_c) {
#line 225
        Panic("draw_grid", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
              "my_c", 225);
      }
#line 225
      if (my_c) {
#line 225
        if ((int )my_c->x < 0) {
#line 225
          my_c->x = (short)0;
        }
#line 225
        if ((int )my_c->y < 0) {
#line 225
          my_c->y = (short)0;
        }
#line 225
        if ((int )my_c->x + (int )my_c->w > 640) {
#line 225
          my_c->w = (unsigned short )(640 - (int )my_c->x);
        }
#line 225
        if ((int )my_c->y + (int )my_c->h > 480) {
#line 225
          my_c->h = (unsigned short )(480 - (int )my_c->y);
        }
      }
#line 225
      SDL_UpdateRects(screen___0, 1, & s);
    }
  }
#line 226
  return;
}
}
#line 235 "grid.c"
void draw_falling(SDL_Surface *screen___0 , int blockWidth , Grid *g___0 , int offset ) 
{ SDL_Rect s ;
  SDL_Rect r ;
  int i ;
  int j ;
  int mini ;
  int minj ;
  int maxi ;
  int maxj ;
  int cj ;
  int c ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  SDL_Rect *my_c ;

  {
#line 241
  mini = 100000;
#line 241
  minj = 100000;
#line 241
  maxi = -1;
#line 241
  maxj = -1;
#line 245
  memset((void *)g___0->temp, 0, (sizeof(*(g___0->temp)) * (unsigned int )g___0->w) * (unsigned int )g___0->h);
#line 247
  j = 0;
#line 247
  while (j < g___0->h) {
#line 248
    i = 0;
#line 248
    while (i < g___0->w) {
#line 249
      c = (int )*(g___0->contents + (i + j * g___0->w));
#line 250
      if (c) {
#line 250
        if ((int )*(g___0->fall + (i + j * g___0->w)) == 0) {
#line 250
          if ((int )*(g___0->temp + (i + j * g___0->w)) == 0) {
#line 253
            cj = j;
#line 253
            while (1) {
#line 253
              if (*(g___0->contents + (i + cj * g___0->w))) {
#line 253
                if (*(g___0->fall + (i + cj * g___0->w))) {
#line 253
                  if ((int )*(g___0->temp + (i + cj * g___0->w)) == 0) {
#line 253
                    if (! (cj < g___0->h)) {
#line 253
                      break;
                    }
                  } else {
#line 253
                    break;
                  }
                } else {
#line 253
                  break;
                }
              } else {
#line 253
                break;
              }
#line 257
              *(g___0->temp + (i + cj * g___0->w)) = (unsigned char)1;
#line 253
              cj ++;
            }
#line 260
            s.x = (short )((int )g___0->board.x + i * blockWidth);
#line 261
            s.y = (short )((((int )g___0->board.y + j * blockWidth) + offset) - 1);
#line 262
            s.w = (unsigned short )blockWidth;
#line 263
            s.h = (unsigned short )(blockWidth * ((cj - j) + 1));
#line 266
            r.x = (short )((int )g___0->board.x + i * blockWidth);
#line 267
            r.y = (short )(((int )g___0->board.y + j * blockWidth) + offset);
#line 268
            r.w = (unsigned short )blockWidth;
#line 269
            r.h = (unsigned short )(blockWidth * ((cj - j) + 1));
#line 272
            my_b = & s;
#line 272
            my_d = & r;
#line 272
            if (my_b) {
#line 272
              if ((int )my_b->x < 0) {
#line 272
                my_b->x = (short)0;
              }
#line 272
              if ((int )my_b->y < 0) {
#line 272
                my_b->y = (short)0;
              }
#line 272
              if ((int )my_b->x + (int )my_b->w > 640) {
#line 272
                my_b->w = (unsigned short )(640 - (int )my_b->x);
              }
#line 272
              if ((int )my_b->y + (int )my_b->h > 480) {
#line 272
                my_b->h = (unsigned short )(480 - (int )my_b->y);
              }
            }
#line 272
            if (my_d) {
#line 272
              if ((int )my_d->x < 0) {
#line 272
                my_d->x = (short)0;
              }
#line 272
              if ((int )my_d->y < 0) {
#line 272
                my_d->y = (short)0;
              }
#line 272
              if ((int )my_d->x + (int )my_d->w > 640) {
#line 272
                my_d->w = (unsigned short )(640 - (int )my_d->x);
              }
#line 272
              if ((int )my_d->y + (int )my_d->h > 480) {
#line 272
                my_d->h = (unsigned short )(480 - (int )my_d->y);
              }
            }
#line 272
            tmp = SDL_UpperBlit(screen___0, my_b, screen___0, my_d);
#line 272
            if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 272
              Panic("draw_falling", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                    "SDL_UpperBlit(screen,my_b,screen,my_d) == 0", 272);
            }
#line 274
            if ((int )s.x < mini) {
#line 274
              mini = (int )s.x;
            }
#line 275
            if ((int )s.y < minj) {
#line 275
              minj = (int )s.y;
            }
#line 276
            if ((int )s.x + (int )s.w > maxi) {
#line 276
              maxi = (int )s.x + (int )s.w;
            }
#line 277
            if ((int )s.y + (int )s.h > maxj) {
#line 277
              maxj = (int )s.y + (int )s.h;
            }
#line 280
            if (j == 0) {
              goto _L;
            } else {
#line 280
              if ((int )*(g___0->fall + (i + (j - 1) * g___0->w)) == 1) {
                goto _L;
              } else {
#line 280
                if ((int )*(g___0->contents + (i + (j - 1) * g___0->w)) == 0) {
                  _L: /* CIL Label */ 
#line 282
                  s.h = (unsigned short)1;
#line 283
                  my_b___0 = & s;
#line 283
                  my_d___0 = & s;
#line 283
                  if (my_b___0) {
#line 283
                    if ((int )my_b___0->x < 0) {
#line 283
                      my_b___0->x = (short)0;
                    }
#line 283
                    if ((int )my_b___0->y < 0) {
#line 283
                      my_b___0->y = (short)0;
                    }
#line 283
                    if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 283
                      my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
                    }
#line 283
                    if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 283
                      my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
                    }
                  }
#line 283
                  if (my_d___0) {
#line 283
                    if ((int )my_d___0->x < 0) {
#line 283
                      my_d___0->x = (short)0;
                    }
#line 283
                    if ((int )my_d___0->y < 0) {
#line 283
                      my_d___0->y = (short)0;
                    }
#line 283
                    if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 283
                      my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
                    }
#line 283
                    if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 283
                      my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
                    }
                  }
#line 283
                  tmp___0 = SDL_UpperBlit(widget_layer, my_b___0, screen___0, my_d___0);
#line 283
                  if (! (tmp___0 == (int __attribute__((__visibility__("default")))  )0)) {
#line 283
                    Panic("draw_falling", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                          "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 283);
                  }
                }
              }
            }
          }
        }
      }
#line 248
      i ++;
    }
#line 247
    j ++;
  }
#line 290
  s.x = (short )mini;
#line 291
  s.y = (short )minj;
#line 292
  s.w = (unsigned short )((maxi - mini) + 1);
#line 293
  s.h = (unsigned short )((maxj - minj) + 1);
#line 294
  if (maxi > -1) {
#line 294
    my_c = & s;
#line 294
    if (! my_c) {
#line 294
      Panic("draw_falling", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
            "my_c", 294);
    }
#line 294
    if (my_c) {
#line 294
      if ((int )my_c->x < 0) {
#line 294
        my_c->x = (short)0;
      }
#line 294
      if ((int )my_c->y < 0) {
#line 294
        my_c->y = (short)0;
      }
#line 294
      if ((int )my_c->x + (int )my_c->w > 640) {
#line 294
        my_c->w = (unsigned short )(640 - (int )my_c->x);
      }
#line 294
      if ((int )my_c->y + (int )my_c->h > 480) {
#line 294
        my_c->h = (unsigned short )(480 - (int )my_c->y);
      }
    }
#line 294
    SDL_UpdateRects(screen___0, 1, & s);
  }
#line 295
  return;
}
}
#line 302 "grid.c"
void fall_down(Grid *g___0 ) 
{ int x ;
  int y ;

  {
#line 306
  y = g___0->h - 1;
#line 306
  while (y >= 1) {
#line 307
    x = 0;
#line 307
    while (x < g___0->w) {
#line 308
      if ((int )*(g___0->fall + (x + (y - 1) * g___0->w)) == 0) {
#line 308
        if (*(g___0->contents + (x + (y - 1) * g___0->w))) {
#line 310
          if (! ((int )*(g___0->contents + (x + y * g___0->w)) == 0)) {
#line 310
            if (! ((int )*(g___0->contents + (x + y * g___0->w)) == 255)) {
#line 310
              Panic("fall_down", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                    "((*g).contents[(x) + ((y)*((*g).w))]) == 0 || ((*g).contents[(x) + ((y)*((*g).w))]) == 255",
                    311);
            }
          }
#line 312
          *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->contents + (x + y * g___0->w)) != (int )*(g___0->contents + (x + (y - 1) * g___0->w))));
#line 312
          *(g___0->contents + (x + y * g___0->w)) = *(g___0->contents + (x + (y - 1) * g___0->w));
#line 313
          *(g___0->changed + (x + (y - 1) * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + (y - 1) * g___0->w)) | ((int )*(g___0->contents + (x + (y - 1) * g___0->w)) != 255));
#line 313
          *(g___0->contents + (x + (y - 1) * g___0->w)) = (unsigned char)255;
#line 314
          *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->fall + (x + y * g___0->w)) != 0));
#line 314
          *(g___0->fall + (x + y * g___0->w)) = (unsigned char)0;
        }
      }
#line 307
      x ++;
    }
#line 306
    y --;
  }
#line 319
  return;
}
}
#line 326 "grid.c"
int determine_falling(Grid *g___0 ) 
{ int x ;
  int y ;

  {
#line 346
  y = 0;
#line 346
  while (y < g___0->h) {
#line 347
    x = 0;
#line 347
    while (x < g___0->w) {
#line 348
      if (*(g___0->contents + (x + y * g___0->w))) {
#line 348
        if ((int )*(g___0->fall + (x + y * g___0->w)) == 0) {
#line 349
          return (1);
        }
      }
#line 347
      x ++;
    }
#line 346
    y ++;
  }
#line 350
  return (0);
}
}
#line 364 "grid.c"
int run_gravity(Grid *g___0 ) 
{ int falling_pieces_settled ;
  int x ;
  int y ;
  int c ;
  int f___0 ;
  int X ;
  int Y ;
  int YY ;
  int S ;
  int lowest_y ;
  int garbage_on_row[21] ;
  char UP_QUEUE[2000] ;
  char UP_POS ;
  int c___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 370
  lowest_y = 0;
#line 374
  UP_POS = (char)0;
#line 380
  falling_pieces_settled = 0;
#line 381
  y = 0;
#line 381
  while (y < g___0->h) {
#line 382
    garbage_on_row[y] = 0;
#line 383
    x = 0;
#line 383
    while (x < g___0->w) {
#line 384
      c___0 = (int )*(g___0->contents + (x + y * g___0->w));
#line 385
      if (! lowest_y) {
#line 385
        if (c___0) {
#line 386
          lowest_y = y;
        }
      }
#line 387
      if (c___0 == 1) {
#line 388
        garbage_on_row[y] = 1;
      }
#line 389
      if ((int )*(g___0->fall + (x + y * g___0->w)) == 1) {
#line 390
        *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->fall + (x + y * g___0->w)) != 254));
#line 390
        *(g___0->fall + (x + y * g___0->w)) = (unsigned char)254;
      }
#line 383
      x ++;
    }
#line 381
    y ++;
  }
#line 393
  garbage_on_row[20] = 1;
#line 395
  y = g___0->h - 1;
#line 395
  while (y >= lowest_y) {
#line 396
    x = 0;
#line 396
    while (x < g___0->w) {
#line 397
      c = (int )*(g___0->contents + (x + y * g___0->w));
#line 398
      if (! c) {
        goto __Cont;
      } else {
#line 399
        if (c != 1) {
#line 399
          if (y < g___0->h - 1) {
            goto __Cont;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 400
          if (c == 1) {
#line 400
            if (! garbage_on_row[y + 1]) {
#line 404
              garbage_on_row[y] = 0;
              goto __Cont;
            }
          }
        }
      }
#line 407
      f___0 = (int )*(g___0->fall + (x + y * g___0->w));
#line 408
      if (f___0 == 1) {
        goto __Cont;
      } else {
#line 409
        if (f___0 == 0) {
#line 410
          falling_pieces_settled = 1;
        }
      }
#line 414
      if (y >= 1) {
#line 415
        Y = y;
#line 416
        while (1) {
#line 416
          c = (int )*(g___0->contents + (x + Y * g___0->w));
#line 416
          if (c) {
#line 416
            if (! ((int )*(g___0->fall + (x + Y * g___0->w)) != 1)) {
#line 416
              break;
            }
          } else {
#line 416
            break;
          }
#line 419
          f___0 = (int )*(g___0->fall + (x + Y * g___0->w));
#line 420
          if (f___0 == 0) {
#line 421
            falling_pieces_settled = 1;
          }
#line 423
          *(g___0->changed + (x + Y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + Y * g___0->w)) | ((int )*(g___0->fall + (x + Y * g___0->w)) != 1));
#line 423
          *(g___0->fall + (x + Y * g___0->w)) = (unsigned char)1;
#line 425
          if (x >= 1) {
#line 425
            if ((int )*(g___0->contents + ((x - 1) + Y * g___0->w)) == c) {
#line 425
              if ((int )*(g___0->fall + ((x - 1) + Y * g___0->w)) != 1) {
#line 427
                UP_QUEUE[(int )UP_POS * 3] = (char )(x - 1);
#line 427
                UP_QUEUE[(int )UP_POS * 3 + 1] = (char )Y;
#line 428
                if (f___0 == 0) {
#line 428
                  tmp = 1;
                } else {
#line 428
                  if (c == 1) {
#line 428
                    tmp = 1;
                  } else {
#line 428
                    tmp = 0;
                  }
                }
#line 428
                UP_QUEUE[(int )UP_POS * 3 + 2] = (char )tmp;
#line 428
                UP_POS = (char )((int )UP_POS + 1);
              }
            }
          }
#line 430
          if (x < g___0->w - 1) {
#line 430
            if ((int )*(g___0->contents + ((x + 1) + Y * g___0->w)) == c) {
#line 430
              if ((int )*(g___0->fall + ((x + 1) + Y * g___0->w)) != 1) {
#line 432
                UP_QUEUE[(int )UP_POS * 3] = (char )(x + 1);
#line 432
                UP_QUEUE[(int )UP_POS * 3 + 1] = (char )Y;
#line 433
                if (f___0 == 0) {
#line 433
                  tmp___0 = 1;
                } else {
#line 433
                  if (c == 1) {
#line 433
                    tmp___0 = 1;
                  } else {
#line 433
                    tmp___0 = 0;
                  }
                }
#line 433
                UP_QUEUE[(int )UP_POS * 3 + 2] = (char )tmp___0;
#line 433
                UP_POS = (char )((int )UP_POS + 1);
              }
            }
          }
#line 435
          if (Y < g___0->h - 1) {
#line 435
            if ((int )*(g___0->contents + (x + (Y + 1) * g___0->w)) == c) {
#line 435
              if ((int )*(g___0->fall + (x + (Y + 1) * g___0->w)) != 1) {
#line 437
                UP_QUEUE[(int )UP_POS * 3] = (char )x;
#line 437
                UP_QUEUE[(int )UP_POS * 3 + 1] = (char )(Y + 1);
#line 438
                if (f___0 == 0) {
#line 438
                  tmp___1 = 1;
                } else {
#line 438
                  if (c == 1) {
#line 438
                    tmp___1 = 1;
                  } else {
#line 438
                    tmp___1 = 0;
                  }
                }
#line 438
                UP_QUEUE[(int )UP_POS * 3 + 2] = (char )tmp___1;
#line 438
                UP_POS = (char )((int )UP_POS + 1);
              }
            }
          }
#line 440
          Y --;
        }
      } else {
#line 444
        *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->fall + (x + y * g___0->w)) != 1));
#line 444
        *(g___0->fall + (x + y * g___0->w)) = (unsigned char)1;
      }
#line 448
      while ((int )UP_POS > 0) {
#line 449
        UP_POS = (char )((int )UP_POS - 1);
#line 450
        X = (int )UP_QUEUE[(int )UP_POS * 3];
#line 451
        Y = (int )UP_QUEUE[(int )UP_POS * 3 + 1];
#line 452
        S = (int )UP_QUEUE[(int )UP_POS * 3 + 2];
#line 453
        c = (int )*(g___0->contents + (X + Y * g___0->w));
#line 454
        if (! c) {
#line 454
          Panic("run_gravity", "grid.c", (char *)"Failed assertion \"%s\" on line %d",
                "c", 454);
        }
#line 455
        f___0 = (int )*(g___0->fall + (X + Y * g___0->w));
#line 456
        if (f___0 == 1) {
#line 456
          continue;
        } else {
#line 457
          if (f___0 == 0) {
#line 457
            if (! S) {
#line 457
              continue;
            }
          }
        }
#line 459
        if (Y >= 1) {
#line 460
          YY = Y;
#line 461
          while (1) {
#line 461
            c = (int )*(g___0->contents + (X + YY * g___0->w));
#line 461
            if (c) {
#line 461
              if (! ((int )*(g___0->fall + (X + YY * g___0->w)) != 1)) {
#line 461
                break;
              }
            } else {
#line 461
              break;
            }
#line 464
            f___0 = (int )*(g___0->fall + (X + YY * g___0->w));
#line 465
            if (f___0 == 0) {
#line 465
              falling_pieces_settled = 1;
            }
#line 466
            *(g___0->changed + (X + YY * g___0->w)) = (unsigned char )((int )*(g___0->changed + (X + YY * g___0->w)) | ((int )*(g___0->fall + (X + YY * g___0->w)) != 1));
#line 466
            *(g___0->fall + (X + YY * g___0->w)) = (unsigned char)1;
#line 468
            if (X >= 1) {
#line 468
              if ((int )*(g___0->contents + ((X - 1) + YY * g___0->w)) == c) {
#line 468
                if ((int )*(g___0->fall + ((X - 1) + YY * g___0->w)) != 1) {
#line 470
                  UP_QUEUE[(int )UP_POS * 3] = (char )(X - 1);
#line 470
                  UP_QUEUE[(int )UP_POS * 3 + 1] = (char )YY;
#line 471
                  if (f___0 == 0) {
#line 471
                    tmp___2 = 1;
                  } else {
#line 471
                    if (c == 1) {
#line 471
                      tmp___2 = 1;
                    } else {
#line 471
                      tmp___2 = 0;
                    }
                  }
#line 471
                  UP_QUEUE[(int )UP_POS * 3 + 2] = (char )tmp___2;
#line 471
                  UP_POS = (char )((int )UP_POS + 1);
                }
              }
            }
#line 473
            if (X < g___0->w - 1) {
#line 473
              if ((int )*(g___0->contents + ((X + 1) + YY * g___0->w)) == c) {
#line 473
                if ((int )*(g___0->fall + ((X + 1) + YY * g___0->w)) != 1) {
#line 475
                  UP_QUEUE[(int )UP_POS * 3] = (char )(X + 1);
#line 475
                  UP_QUEUE[(int )UP_POS * 3 + 1] = (char )YY;
#line 476
                  if (f___0 == 0) {
#line 476
                    tmp___3 = 1;
                  } else {
#line 476
                    if (c == 1) {
#line 476
                      tmp___3 = 1;
                    } else {
#line 476
                      tmp___3 = 0;
                    }
                  }
#line 476
                  UP_QUEUE[(int )UP_POS * 3 + 2] = (char )tmp___3;
#line 476
                  UP_POS = (char )((int )UP_POS + 1);
                }
              }
            }
#line 478
            if (YY < g___0->h - 1) {
#line 478
              if ((int )*(g___0->contents + (X + (YY + 1) * g___0->w)) == c) {
#line 478
                if ((int )*(g___0->fall + (X + (YY + 1) * g___0->w)) != 1) {
#line 480
                  UP_QUEUE[(int )UP_POS * 3] = (char )X;
#line 480
                  UP_QUEUE[(int )UP_POS * 3 + 1] = (char )(YY + 1);
#line 481
                  if (f___0 == 0) {
#line 481
                    tmp___4 = 1;
                  } else {
#line 481
                    if (c == 1) {
#line 481
                      tmp___4 = 1;
                    } else {
#line 481
                      tmp___4 = 0;
                    }
                  }
#line 481
                  UP_QUEUE[(int )UP_POS * 3 + 2] = (char )tmp___4;
#line 481
                  UP_POS = (char )((int )UP_POS + 1);
                }
              }
            }
#line 483
            YY --;
          }
        } else {
#line 486
          *(g___0->changed + (X + Y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (X + Y * g___0->w)) | ((int )*(g___0->fall + (X + Y * g___0->w)) != 1));
#line 486
          *(g___0->fall + (X + Y * g___0->w)) = (unsigned char)1;
        }
      }
      __Cont: /* CIL Label */ 
#line 396
      x ++;
    }
#line 395
    y --;
  }
#line 491
  y = g___0->h - 1;
#line 491
  while (y >= 0) {
#line 492
    x = 0;
#line 492
    while (x < g___0->w) {
#line 493
      if ((int )*(g___0->fall + (x + y * g___0->w)) == 254) {
#line 494
        *(g___0->fall + (x + y * g___0->w)) = (unsigned char)0;
      }
#line 492
      x ++;
    }
#line 491
    y --;
  }
#line 496
  return (falling_pieces_settled);
}
}
#line 505 "grid.c"
int check_tetris(Grid *g___0 ) 
{ int tetris_count ;
  int x ;
  int y ;
  int c ;

  {
#line 508
  tetris_count = 0;
#line 510
  y = g___0->h - 1;
#line 510
  while (y >= 0) {
#line 511
    c = 0;
#line 512
    x = 0;
#line 512
    while (x < g___0->w) {
#line 513
      if (*(g___0->contents + (x + y * g___0->w))) {
#line 514
        c ++;
      }
#line 512
      x ++;
    }
#line 515
    if (c == g___0->w) {
#line 516
      tetris_count ++;
#line 517
      x = 0;
#line 517
      while (x < g___0->w) {
#line 518
        *(g___0->changed + (x + y * g___0->w)) = (unsigned char )((int )*(g___0->changed + (x + y * g___0->w)) | ((int )*(g___0->contents + (x + y * g___0->w)) != 255));
#line 518
        *(g___0->contents + (x + y * g___0->w)) = (unsigned char)255;
#line 517
        x ++;
      }
    }
#line 510
    y --;
  }
#line 521
  return (tetris_count);
}
}
#line 1 "highscore.o"
#pragma merger(0,"/tmp/cil-0jzqHBjE.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 200 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 236
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 26 "highscore.c"
static char loaded  =    (char)0;
#line 27 "highscore.c"
static int high_scores[10]  ;
#line 28 "highscore.c"
static char *high_names[10]  ;
#line 29 "highscore.c"
static char *high_dates[10]  ;
#line 31 "highscore.c"
static SDL_Rect hs  ;
#line 31 "highscore.c"
static SDL_Rect hs_border  ;
#line 32 "highscore.c"
static int score_height  ;
#line 40 "highscore.c"
static void prep_hs_bg(void) 
{ 

  {
#line 43
  hs.x = (short )(screen->w / 20);
#line 43
  hs.y = (short )(screen->h / 20);
#line 44
  hs.w = (unsigned short )((9 * screen->w) / 10);
#line 44
  hs.h = (unsigned short )((18 * screen->h) / 20);
#line 46
  draw_bordered_rect(& hs, & hs_border, 2);
#line 47
  return;
}
}
#line 53 "highscore.c"
static void save_high_scores(void) 
{ FILE *fout ;
  int i ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 59
  if (! loaded) {
#line 60
    return;
  }
#line 62
  fout = fopen((char const   * __restrict  )"Atris.Scores", (char const   * __restrict  )"wt");
#line 63
  if (! fout) {
#line 64
    printf((char const   * __restrict  )"%-14.14s| ", "save_high_scores");
#line 64
    tmp = __errno_location();
#line 64
    tmp___0 = strerror(*tmp);
#line 64
    printf((char const   * __restrict  )"Unable to write High Score file [Atris.Scores]: %s\n",
           tmp___0);
#line 64
    fflush(stdout);
#line 65
    return;
  }
#line 68
  fprintf((FILE * __restrict  )fout, (char const   * __restrict  )"# Alizarin Tetris High Score File\n");
#line 69
  i = 0;
#line 69
  while (i < 10) {
#line 70
    fprintf((FILE * __restrict  )fout, (char const   * __restrict  )"%04d|%s|%s\n",
            high_scores[i], high_dates[i], high_names[i]);
#line 69
    i ++;
  }
#line 71
  fclose(fout);
#line 72
  return;
}
}
#line 79 "highscore.c"
static void load_high_scores(void) 
{ FILE *fin ;
  int i ;
  char buf[2048] ;
  char *tmp___8 ;
  char *tmp___18 ;
  char *p ;
  char *q ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___22 ;
  char *tmp___24 ;
  char *tmp___26 ;
  char *tmp___28 ;
  char *tmp___38 ;
  char *tmp___48 ;
  int tmp___49 ;

  {
#line 83
  i = 0;
#line 86
  if (! loaded) {
#line 89
    i = 0;
#line 89
    while (i < 10) {
#line 90
      tmp___8 = __strdup("No one yet...");
#line 90
      high_names[i] = tmp___8;
#line 90
      if (! high_names[i]) {
#line 90
        Panic("load_high_scores", "highscore.c", (char *)"Failed assertion \"%s\" on line %d",
              "high_names[i]", 90);
      }
#line 91
      tmp___18 = __strdup("Never");
#line 91
      high_dates[i] = tmp___18;
#line 91
      if (! high_dates[i]) {
#line 91
        Panic("load_high_scores", "highscore.c", (char *)"Failed assertion \"%s\" on line %d",
              "high_dates[i]", 91);
      }
#line 92
      high_scores[i] = 0;
#line 89
      i ++;
    }
#line 94
    loaded = (char)1;
  }
#line 97
  fin = fopen((char const   * __restrict  )"Atris.Scores", (char const   * __restrict  )"r");
#line 98
  if (fin) {
#line 100
    i = 0;
#line 100
    while (1) {
#line 100
      tmp___49 = feof(fin);
#line 100
      if (tmp___49) {
#line 100
        break;
      } else {
#line 100
        if (! (i < 10)) {
#line 100
          break;
        }
      }
#line 103
      while (1) {
#line 104
        fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 103
        tmp___19 = feof(fin);
#line 103
        if (tmp___19) {
#line 103
          break;
        } else {
#line 103
          if (! ((int )buf[0] == 10)) {
#line 103
            if (! ((int )buf[0] == 35)) {
#line 103
              break;
            }
          }
        }
      }
#line 107
      tmp___20 = feof(fin);
#line 107
      if (tmp___20) {
#line 107
        break;
      }
#line 109
      tmp___24 = __builtin_strchr(buf, '\n');
#line 109
      if (tmp___24) {
#line 110
        tmp___22 = __builtin_strchr(buf, '\n');
#line 110
        *tmp___22 = (char)0;
      }
#line 113
      sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%d",
             & high_scores[i]);
#line 114
      tmp___26 = __builtin_strchr(buf, '|');
#line 114
      p = tmp___26;
#line 115
      if (! p) {
#line 115
        break;
      }
#line 116
      p ++;
#line 117
      tmp___28 = __builtin_strchr(p, '|');
#line 117
      q = tmp___28;
#line 118
      if (! q) {
#line 118
        break;
      }
#line 119
      free((void *)high_dates[i]);
#line 119
      high_dates[i] = (char *)((void *)0);
#line 119
      free((void *)high_names[i]);
#line 119
      high_names[i] = (char *)((void *)0);
#line 120
      *q = (char)0;
#line 121
      tmp___38 = __strdup((char const   *)p);
#line 121
      high_dates[i] = tmp___38;
#line 121
      if (! high_dates[i]) {
#line 121
        Panic("load_high_scores", "highscore.c", (char *)"Failed assertion \"%s\" on line %d",
              "high_dates[i]", 121);
      }
#line 122
      q ++;
#line 123
      tmp___48 = __strdup((char const   *)q);
#line 123
      high_names[i] = tmp___48;
#line 123
      if (! high_names[i]) {
#line 123
        Panic("load_high_scores", "highscore.c", (char *)"Failed assertion \"%s\" on line %d",
              "high_names[i]", 123);
      }
#line 100
      i ++;
    }
#line 125
    fclose(fin);
  }
#line 127
  return;
}
}
#line 133 "highscore.c"
static void show_high_scores(void) 
{ char buf[256] ;
  int i ;
  int base ;
  int delta ;

  {
#line 140
  if (! loaded) {
#line 140
    load_high_scores();
  }
#line 141
  prep_hs_bg();
#line 143
  draw_string((char *)"Alizarin Tetris High Scores", color_purple, screen->w / 2,
              (int )hs.y, ((1 << 6) | (1 << 3)) | 1);
#line 146
  base = (int )hs.y + 60;
#line 148
  i = 0;
#line 148
  while (i < 10) {
#line 150
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%-2d)", i + 1);
#line 151
    delta = draw_string(buf, color_blue, (3 * screen->w) / 40, base, 1 << 3);
#line 153
    score_height = delta + 3;
#line 155
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%-20s", high_names[i]);
#line 156
    draw_string(buf, color_red, (3 * screen->w) / 20, base, 1 << 3);
#line 158
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%.4d", high_scores[i]);
#line 159
    draw_string(buf, color_blue, (11 * screen->w) / 20, base, 1 << 3);
#line 161
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s", high_dates[i]);
#line 162
    draw_string(buf, color_red, (7 * screen->w) / 10, base, 1 << 3);
#line 164
    base += score_height;
#line 148
    i ++;
  }
#line 166
  return;
}
}
#line 173 "highscore.c"
static int is_high_score(int score ) 
{ 

  {
#line 176
  if (! loaded) {
#line 176
    load_high_scores();
  }
#line 177
  return (score >= high_scores[9]);
}
}
#line 185 "highscore.c"
static void update_high_scores(int score ) 
{ unsigned int i ;
  unsigned int j ;
  char buf[256] ;
  struct tm  const  *tm ;
  time_t t ;
  int tmp ;
  struct tm *tmp___0 ;
  char *tmp___10 ;

  {
#line 195
  tmp = is_high_score(score);
#line 195
  if (! tmp) {
#line 195
    return;
  }
#line 196
  if (! loaded) {
#line 196
    load_high_scores();
  }
#line 198
  i = 0U;
#line 198
  while (i < 10U) {
#line 200
    if (score >= high_scores[i]) {
#line 202
      prep_hs_bg();
#line 205
      free((void *)high_names[9]);
#line 205
      high_names[9] = (char *)((void *)0);
#line 206
      free((void *)high_dates[9]);
#line 206
      high_dates[9] = (char *)((void *)0);
#line 208
      j = 9U;
#line 208
      while (j > i) {
#line 210
        high_scores[j] = high_scores[j - 1U];
#line 211
        high_names[j] = high_names[j - 1U];
#line 212
        high_dates[j] = high_dates[j - 1U];
#line 208
        j --;
      }
#line 216
      t = time((time_t *)((void *)0));
#line 216
      tmp___0 = localtime((time_t const   *)(& t));
#line 216
      tm = (struct tm  const  *)tmp___0;
#line 217
      strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%b %d %H:%M",
               (struct tm  const  * __restrict  )tm);
#line 218
      tmp___10 = __strdup((char const   *)(buf));
#line 218
      high_dates[i] = tmp___10;
#line 224
      high_scores[i] = score;
#line 226
      high_names[i] = (char *)" ";
#line 227
      show_high_scores();
#line 230
      draw_string((char *)"Enter your name!", color_purple, screen->w / 2, ((int )hs.y + (int )hs.h) - 10,
                  (1 | (1 << 1)) | (1 << 3));
#line 233
      high_names[i] = input_string(screen, (3 * screen->w) / 20, (int )((unsigned int )((int )hs.y + 60) + (unsigned int )score_height * i),
                                   1);
#line 235
      break;
    }
#line 198
    i ++;
  }
#line 238
  save_high_scores();
#line 239
  return;
}
}
#line 245 "highscore.c"
void high_score_check(int level , int new_score ) 
{ SDL_Event event ;
  int __attribute__((__visibility__("default")))  tmp ;
  char buf[256] ;
  int tmp___0 ;

  {
#line 249
  clear_screen_to_flame();
#line 251
  if (level < 0) {
#line 252
    return;
  }
#line 256
  while (1) {
#line 256
    tmp = SDL_PollEvent(& event);
#line 256
    if (! tmp) {
#line 256
      break;
    }
#line 257
    poll_and_flame(& event);
  }
#line 261
  tmp___0 = is_high_score(new_score);
#line 261
  if (tmp___0) {
#line 262
    update_high_scores(new_score);
#line 263
    show_high_scores();
  } else {
#line 267
    show_high_scores();
#line 268
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"Your score: %d",
            new_score);
#line 270
    draw_string(buf, color_purple, screen->w / 2, ((int )hs.y + (int )hs.h) - 10,
                (1 | (1 << 1)) | (1 << 3));
  }
#line 275
  while (1) {
#line 276
    poll_and_flame(& event);
#line 275
    if (! ((int )event.type != 2)) {
#line 275
      break;
    }
  }
#line 278
  return;
}
}
#line 1 "identity.o"
#pragma merger(0,"/tmp/cil-fwHtJbxG.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 666 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 26 "identity.c"
char *input_string(SDL_Surface *screen___0 , int x , int y , int opaque ) 
{ int pos___0 ;
  char c ;
  char retval[1024] ;
  SDL_Surface *text ;
  SDL_Surface *ctext ;
  SDL_Color tc ;
  SDL_Color cc ;
  SDL_Rect rect ;
  SDL_Event event ;
  Uint32 text_color ;
  Uint32 cursor_color ;
  Uint32 our_black ;
  Uint32 tmp ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___0 ;
  int changed ;
  int blink ;
  Uint32 flip_when ;
  Uint32 __attribute__((__visibility__("default")))  tmp___1 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___2 ;
  SDL_Rect *my_c ;
  SDL_Rect *my_c___0 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___3 ;
  Uint32 __attribute__((__visibility__("default")))  tmp___4 ;
  char *tmp___14 ;
  SDL_Rect *my_c___1 ;
  SDL_Rect *my_c___2 ;
  int tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  unsigned short const   **tmp___19 ;
  int __attribute__((__visibility__("default")))  tmp___20 ;

  {
#line 36
  text_color = int_blue;
#line 37
  cursor_color = int_purple;
#line 38
  if (opaque) {
#line 38
    tmp = int_solid_black;
  } else {
#line 38
    tmp = int_black;
  }
#line 38
  our_black = tmp;
#line 40
  memset((void *)(retval), 0, sizeof(retval));
#line 41
  retval[0] = (char )' ';
#line 42
  pos___0 = 1;
#line 44
  SDL_GetRGB(text_color, screen___0->format, & tc.r, & tc.g, & tc.b);
#line 45
  SDL_GetRGB(cursor_color, screen___0->format, & cc.r, & cc.g, & cc.b);
#line 47
  tmp___0 = TTF_RenderText_Blended(font, "_", cc);
#line 47
  ctext = (SDL_Surface *)tmp___0;
#line 47
  if (! ctext) {
#line 47
    Panic("input_string", "identity.c", (char *)"Failed assertion \"%s\" on line %d",
          "ctext", 47);
  }
#line 49
  while (1) {
#line 50
    changed = 0;
#line 51
    blink = 1;
#line 52
    tmp___1 = SDL_GetTicks();
#line 52
    flip_when = (Uint32 )tmp___1;
#line 55
    tmp___2 = TTF_RenderText_Blended(font, (char const   *)(retval), tc);
#line 55
    text = (SDL_Surface *)tmp___2;
#line 55
    if (! text) {
#line 55
      Panic("input_string", "identity.c", (char *)"Failed assertion \"%s\" on line %d",
            "text", 55);
    }
#line 57
    rect.x = (short )x;
#line 58
    rect.y = (short )y;
#line 59
    rect.w = (unsigned short )text->w;
#line 60
    rect.h = (unsigned short )text->h;
#line 62
    SDL_UpperBlit(text, (SDL_Rect *)((void *)0), widget_layer, & rect);
#line 64
    SDL_UpperBlit(text, (SDL_Rect *)((void *)0), screen___0, & rect);
#line 65
    my_c = & rect;
#line 65
    if (! my_c) {
#line 65
      Panic("input_string", "identity.c", (char *)"Failed assertion \"%s\" on line %d",
            "my_c", 65);
    }
#line 65
    if (my_c) {
#line 65
      if ((int )my_c->x < 0) {
#line 65
        my_c->x = (short)0;
      }
#line 65
      if ((int )my_c->y < 0) {
#line 65
        my_c->y = (short)0;
      }
#line 65
      if ((int )my_c->x + (int )my_c->w > 640) {
#line 65
        my_c->w = (unsigned short )(640 - (int )my_c->x);
      }
#line 65
      if ((int )my_c->y + (int )my_c->h > 480) {
#line 65
        my_c->h = (unsigned short )(480 - (int )my_c->y);
      }
    }
#line 65
    SDL_UpdateRects(screen___0, 1, & rect);
#line 67
    rect.x = (short )((int )rect.x + (int )rect.w);
#line 68
    rect.w = (unsigned short )ctext->w;
#line 69
    rect.h = (unsigned short )ctext->h;
#line 71
    changed = 0;
#line 72
    while (! changed) {
#line 73
      tmp___4 = SDL_GetTicks();
#line 73
      if (tmp___4 > (Uint32 __attribute__((__visibility__("default")))  )flip_when) {
#line 74
        if (blink) {
#line 75
          SDL_UpperBlit(ctext, (SDL_Rect *)((void *)0), screen___0, & rect);
#line 76
          SDL_UpperBlit(ctext, (SDL_Rect *)((void *)0), widget_layer, & rect);
        } else {
#line 78
          SDL_FillRect(widget_layer, & rect, our_black);
#line 79
          SDL_FillRect(screen___0, & rect, our_black);
#line 80
          SDL_UpperBlit(flame_layer, & rect, screen___0, & rect);
#line 81
          SDL_UpperBlit(widget_layer, & rect, screen___0, & rect);
        }
#line 83
        my_c___0 = & rect;
#line 83
        if (! my_c___0) {
#line 83
          Panic("input_string", "identity.c", (char *)"Failed assertion \"%s\" on line %d",
                "my_c", 83);
        }
#line 83
        if (my_c___0) {
#line 83
          if ((int )my_c___0->x < 0) {
#line 83
            my_c___0->x = (short)0;
          }
#line 83
          if ((int )my_c___0->y < 0) {
#line 83
            my_c___0->y = (short)0;
          }
#line 83
          if ((int )my_c___0->x + (int )my_c___0->w > 640) {
#line 83
            my_c___0->w = (unsigned short )(640 - (int )my_c___0->x);
          }
#line 83
          if ((int )my_c___0->y + (int )my_c___0->h > 480) {
#line 83
            my_c___0->h = (unsigned short )(480 - (int )my_c___0->y);
          }
        }
#line 83
        SDL_UpdateRects(screen___0, 1, & rect);
#line 84
        tmp___3 = SDL_GetTicks();
#line 84
        flip_when = (unsigned int )(tmp___3 + (Uint32 __attribute__((__visibility__("default")))  )400);
#line 85
        blink = ! blink;
      }
#line 87
      tmp___20 = SDL_PollEvent(& event);
#line 87
      if (tmp___20) {
#line 88
        if ((int )event.type == 2) {
#line 89
          changed = 1;
#line 90
          switch ((int )event.key.keysym.sym) {
          case 13: 
#line 92
          tmp___14 = __strdup((char const   *)(retval + 1));
#line 92
          return (tmp___14);
          case 8: 
#line 95
          if (pos___0 > 1) {
#line 95
            pos___0 --;
          }
#line 96
          retval[pos___0] = (char)0;
#line 98
          rect.x = (short )x;
#line 99
          rect.w = (unsigned short )(text->w + ctext->w);
#line 100
          SDL_FillRect(widget_layer, & rect, our_black);
#line 101
          SDL_FillRect(screen___0, & rect, our_black);
#line 102
          SDL_UpperBlit(flame_layer, & rect, screen___0, & rect);
#line 103
          SDL_UpperBlit(widget_layer, & rect, screen___0, & rect);
#line 104
          my_c___1 = & rect;
#line 104
          if (! my_c___1) {
#line 104
            Panic("input_string", "identity.c", (char *)"Failed assertion \"%s\" on line %d",
                  "my_c", 104);
          }
#line 104
          if (my_c___1) {
#line 104
            if ((int )my_c___1->x < 0) {
#line 104
              my_c___1->x = (short)0;
            }
#line 104
            if ((int )my_c___1->y < 0) {
#line 104
              my_c___1->y = (short)0;
            }
#line 104
            if ((int )my_c___1->x + (int )my_c___1->w > 640) {
#line 104
              my_c___1->w = (unsigned short )(640 - (int )my_c___1->x);
            }
#line 104
            if ((int )my_c___1->y + (int )my_c___1->h > 480) {
#line 104
              my_c___1->h = (unsigned short )(480 - (int )my_c___1->y);
            }
          }
#line 104
          SDL_UpdateRects(screen___0, 1, & rect);
#line 105
          break;
          default: 
#line 108
          c = (char )event.key.keysym.unicode;
#line 109
          if ((int )c == 0) {
#line 109
            break;
          }
#line 111
          SDL_FillRect(widget_layer, & rect, our_black);
#line 112
          SDL_FillRect(screen___0, & rect, our_black);
#line 113
          SDL_UpperBlit(flame_layer, & rect, screen___0, & rect);
#line 114
          SDL_UpperBlit(widget_layer, & rect, screen___0, & rect);
#line 115
          my_c___2 = & rect;
#line 115
          if (! my_c___2) {
#line 115
            Panic("input_string", "identity.c", (char *)"Failed assertion \"%s\" on line %d",
                  "my_c", 115);
          }
#line 115
          if (my_c___2) {
#line 115
            if ((int )my_c___2->x < 0) {
#line 115
              my_c___2->x = (short)0;
            }
#line 115
            if ((int )my_c___2->y < 0) {
#line 115
              my_c___2->y = (short)0;
            }
#line 115
            if ((int )my_c___2->x + (int )my_c___2->w > 640) {
#line 115
              my_c___2->w = (unsigned short )(640 - (int )my_c___2->x);
            }
#line 115
            if ((int )my_c___2->y + (int )my_c___2->h > 480) {
#line 115
              my_c___2->h = (unsigned short )(480 - (int )my_c___2->y);
            }
          }
#line 115
          SDL_UpdateRects(screen___0, 1, & rect);
#line 117
          tmp___16 = __ctype_b_loc();
#line 117
          if ((int const   )*(*tmp___16 + (int )c) & 1024) {
#line 118
            tmp___15 = pos___0;
#line 118
            pos___0 ++;
#line 118
            retval[tmp___15] = c;
          } else {
#line 117
            tmp___17 = __ctype_b_loc();
#line 117
            if ((int const   )*(*tmp___17 + (int )c) & 2048) {
#line 118
              tmp___15 = pos___0;
#line 118
              pos___0 ++;
#line 118
              retval[tmp___15] = c;
            } else {
#line 117
              tmp___18 = __ctype_b_loc();
#line 117
              if ((int const   )*(*tmp___18 + (int )c) & 8192) {
#line 118
                tmp___15 = pos___0;
#line 118
                pos___0 ++;
#line 118
                retval[tmp___15] = c;
              } else {
#line 117
                tmp___19 = __ctype_b_loc();
#line 117
                if ((int const   )*(*tmp___19 + (int )c) & 4) {
#line 118
                  tmp___15 = pos___0;
#line 118
                  pos___0 ++;
#line 118
                  retval[tmp___15] = c;
                }
              }
            }
          }
#line 119
          break;
          }
        }
      } else {
#line 122
        atris_run_flame();
      }
    }
#line 124
    SDL_FreeSurface(text);
  }
}
}
#line 132 "identity.c"
identity *load_identity_file(void) 
{ identity *retval ;
  char buf[2048] ;
  FILE *fin ;
  FILE *tmp ;
  int count ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___5 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *p ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___13 ;
  char *tmp___15 ;
  char *tmp___17 ;
  char *tmp___27 ;
  int tmp___28 ;

  {
#line 138
  tmp = fopen((char const   * __restrict  )"Atris.Players", (char const   * __restrict  )"rt");
#line 138
  fin = tmp;
#line 139
  count = 0;
#line 142
  if (! fin) {
#line 143
    printf((char const   * __restrict  )"%-14.14s| ", "load_identity_file");
#line 143
    printf((char const   * __restrict  )"fopen(%s)\n", "Atris.Players");
#line 143
    fflush(stdout);
#line 144
    printf((char const   * __restrict  )"%-14.14s| ", "load_identity_file");
#line 144
    printf((char const   * __restrict  )"Cannot open Identity File.\n");
#line 144
    fflush(stdout);
#line 146
    tmp___0 = calloc(sizeof(identity ), 1U);
#line 146
    retval = (identity *)tmp___0;
#line 146
    if (! retval) {
#line 146
      Panic("load_identity_file", "identity.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
            sizeof(identity ));
    }
#line 147
    return (retval);
  }
#line 149
  tmp___1 = calloc(sizeof(identity ), 1U);
#line 149
  retval = (identity *)tmp___1;
#line 149
  if (! retval) {
#line 149
    Panic("load_identity_file", "identity.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
          sizeof(identity ));
  }
#line 151
  while (1) {
#line 151
    tmp___8 = feof(fin);
#line 151
    if (tmp___8) {
#line 151
      break;
    }
#line 152
    while (1) {
#line 153
      fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 152
      tmp___2 = feof(fin);
#line 152
      if (tmp___2) {
#line 152
        break;
      } else {
#line 152
        if (! ((int )buf[0] == 10)) {
#line 152
          if (! ((int )buf[0] == 35)) {
#line 152
            break;
          }
        }
      }
    }
#line 156
    tmp___3 = feof(fin);
#line 156
    if (tmp___3) {
#line 156
      break;
    }
#line 157
    tmp___7 = __builtin_strchr(buf, '\n');
#line 157
    if (tmp___7) {
#line 158
      tmp___5 = __builtin_strchr(buf, '\n');
#line 158
      *tmp___5 = (char)0;
    }
#line 159
    count ++;
  }
#line 161
  rewind(fin);
#line 163
  retval->n = count;
#line 165
  if (! (! count)) {
#line 168
    tmp___9 = calloc(sizeof(person ) * (unsigned int )count, 1U);
#line 168
    retval->p = (person *)tmp___9;
#line 168
    if (! retval->p) {
#line 168
      Panic("load_identity_file", "identity.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval->p",
            sizeof(person ) * (unsigned int )count);
    }
#line 169
    i = 0;
#line 170
    while (1) {
#line 170
      tmp___28 = feof(fin);
#line 170
      if (tmp___28) {
#line 170
        break;
      }
#line 172
      while (1) {
#line 173
        fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 172
        tmp___10 = feof(fin);
#line 172
        if (tmp___10) {
#line 172
          break;
        } else {
#line 172
          if (! ((int )buf[0] == 10)) {
#line 172
            if (! ((int )buf[0] == 35)) {
#line 172
              break;
            }
          }
        }
      }
#line 176
      tmp___11 = feof(fin);
#line 176
      if (tmp___11) {
#line 176
        break;
      }
#line 177
      tmp___15 = __builtin_strchr(buf, '\n');
#line 177
      if (tmp___15) {
#line 178
        tmp___13 = __builtin_strchr(buf, '\n');
#line 178
        *tmp___13 = (char)0;
      }
#line 180
      sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%d",
             & (retval->p + i)->level);
#line 181
      tmp___17 = __builtin_strchr(buf, ' ');
#line 181
      p = tmp___17;
#line 182
      if (! p) {
#line 183
        (retval->p + i)->name = (char *)"-garbled-";
      } else {
#line 185
        tmp___27 = __strdup((char const   *)(p + 1));
#line 185
        (retval->p + i)->name = tmp___27;
      }
#line 187
      i ++;
    }
  }
#line 190
  fclose(fin);
#line 192
  printf((char const   * __restrict  )"%-14.14s| ", "load_identity_file");
#line 192
  printf((char const   * __restrict  )"Identity File [%s] loaded (%d players).\n",
         "Atris.Players", count);
#line 192
  fflush(stdout);
#line 194
  return (retval);
}
}
#line 201 "identity.c"
void save_identity_file(identity *id , char *new_name , int new_level ) 
{ FILE *fin ;
  FILE *tmp ;
  int i ;

  {
#line 204
  tmp = fopen((char const   * __restrict  )"Atris.Players", (char const   * __restrict  )"wt");
#line 204
  fin = tmp;
#line 206
  if (! fin) {
#line 207
    printf((char const   * __restrict  )"%-14.14s| ", "save_identity_file");
#line 207
    printf((char const   * __restrict  )"fopen(%s): cannot write Identity File.\n",
           "Atris.Players");
#line 207
    fflush(stdout);
#line 208
    return;
  }
#line 210
  fprintf((FILE * __restrict  )fin, (char const   * __restrict  )"# Alizarin Tetris Identity File\n#\n# Format:\n#[level] [name] (no space before level, one space after)\n");
#line 215
  i = 0;
#line 215
  while (i < id->n) {
#line 216
    fprintf((FILE * __restrict  )fin, (char const   * __restrict  )"%d %s\n", (id->p + i)->level,
            (id->p + i)->name);
#line 215
    i ++;
  }
#line 218
  if (new_name) {
#line 219
    fprintf((FILE * __restrict  )fin, (char const   * __restrict  )"%d %s\n", new_level,
            new_name);
  }
#line 226
  fclose(fin);
#line 227
  return;
}
}
#line 234 "identity.c"
static int network_choice_action(WalkRadio *wr ) 
{ char *tmp ;

  {
#line 237
  if (wr->defaultchoice == 0) {
#line 239
    clear_screen_to_flame();
#line 240
    draw_string((char *)"Who is the Server?", color_blue, screen->w / 2, screen->h / 2,
                (1 << 2) | (1 << 3));
#line 242
    tmp = input_string(screen, screen->w / 2, screen->h / 2, 0);
#line 242
    wr->data = (void *)tmp;
  } else {
#line 243
    if (wr->data) {
#line 244
      free(wr->data);
#line 244
      wr->data = (void *)0;
    } else {
#line 246
      wr->data = (void *)0;
    }
  }
#line 247
  return (1);
}
}
#line 257 "identity.c"
static WalkRadioGroup *wrg___0  =    (WalkRadioGroup *)((void *)0);
#line 254 "identity.c"
char *network_choice(SDL_Surface *screen___0 ) 
{ SDL_Event event ;
  int retval ;

  {
#line 260
  if (! wrg___0) {
#line 261
    wrg___0 = create_single_wrg(2);
#line 262
    *((wrg___0->wr + 0)->label + 0) = (char *)"I am the Client. I will specify a server.";
#line 263
    *((wrg___0->wr + 0)->label + 1) = (char *)"I will be the Server.";
#line 265
    setup_radio(wrg___0->wr + 0);
#line 266
    (wrg___0->wr + 0)->x = (screen___0->w - (int )(wrg___0->wr + 0)->area.w) / 2;
#line 267
    (wrg___0->wr + 0)->y = (screen___0->h - (int )(wrg___0->wr + 0)->area.h) / 2;
#line 268
    (wrg___0->wr + 0)->action = & network_choice_action;
  }
#line 271
  clear_screen_to_flame();
#line 273
  draw_string((char *)"Who is the Server?", color_blue, screen___0->w / 2, (wrg___0->wr + 0)->y,
              (1 | (1 << 3)) | (1 << 1));
#line 276
  draw_radio(wrg___0->wr + 0, 1);
#line 278
  while (1) {
#line 280
    poll_and_flame(& event);
#line 281
    retval = handle_radio_event(wrg___0, (SDL_Event const   *)(& event));
#line 282
    if (retval != -1) {
#line 283
      return ((char *)(wrg___0->wr + 0)->data);
    }
  }
}
}
#line 292 "identity.c"
static void new_player(SDL_Surface *screen___0 , identity **id ) 
{ char *new_name ;
  char *new_level ;
  int level ;
  size_t tmp ;

  {
#line 297
  clear_screen_to_flame();
#line 299
  draw_string((char *)"Enter your name:", color_blue, screen___0->w / 2, screen___0->h / 2,
              (1 << 4) | (1 << 2));
#line 302
  new_name = input_string(screen___0, screen___0->w / 2, screen___0->h / 2, 0);
#line 304
  tmp = strlen((char const   *)new_name);
#line 304
  if (tmp) {
#line 305
    clear_screen_to_flame();
#line 306
    draw_string((char *)"Welcome ", color_purple, screen___0->w / 2, screen___0->h / 2,
                (((1 << 4) | (1 << 2)) | (1 << 6)) | (1 << 1));
#line 308
    draw_string(new_name, color_purple, screen___0->w / 2, screen___0->h / 2, ((1 << 4) | (1 << 6)) | (1 << 1));
#line 310
    draw_string((char *)"Starting level (2-10):", color_blue, screen___0->w / 2, screen___0->h / 2,
                (1 << 4) | (1 << 2));
#line 312
    new_level = input_string(screen___0, screen___0->w / 2, screen___0->h / 2, 0);
#line 313
    level = 0;
#line 314
    sscanf((char const   * __restrict  )new_level, (char const   * __restrict  )"%d",
           & level);
#line 315
    if (level < 2) {
#line 315
      level = 2;
    }
#line 316
    if (level > 10) {
#line 316
      level = 10;
    }
#line 318
    save_identity_file(*id, new_name, level);
#line 320
    *id = load_identity_file();
#line 322
    free((void *)new_level);
  }
#line 324
  free((void *)new_name);
#line 325
  return;
}
}
#line 333 "identity.c"
int who_are_you(SDL_Surface *screen___0 , identity **id , int taken , int p ) 
{ WalkRadioGroup *wrg___1 ;
  int i ;
  int retval ;
  SDL_Event event ;
  char buf[1024] ;
  char *tmp___8 ;

  {
#line 336
  wrg___1 = (WalkRadioGroup *)((void *)0);
  restart: 
#line 343
  wrg___1 = create_single_wrg((*id)->n + 2);
#line 344
  i = 0;
#line 344
  while (i < (*id)->n) {
#line 345
    if (i == taken) {
#line 346
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s (already taken!)",
              ((*id)->p + i)->name);
    } else {
#line 348
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%s (Level %d)",
              ((*id)->p + i)->name, ((*id)->p + i)->level);
    }
#line 349
    tmp___8 = __strdup((char const   *)(buf));
#line 349
    *((wrg___1->wr + 0)->label + i) = tmp___8;
#line 344
    i ++;
  }
#line 351
  *((wrg___1->wr + 0)->label + (*id)->n) = (char *)"-- New Player --";
#line 352
  *((wrg___1->wr + 0)->label + ((*id)->n + 1)) = (char *)"-- Cancel --";
#line 354
  setup_radio(wrg___1->wr + 0);
#line 355
  (wrg___1->wr + 0)->x = (screen___0->w - (int )(wrg___1->wr + 0)->area.w) / 2;
#line 356
  (wrg___1->wr + 0)->y = (screen___0->h - (int )(wrg___1->wr + 0)->area.h) / 2;
#line 357
  (wrg___1->wr + 0)->action = (int (*)(struct _WalkRadio * ))((void *)0);
#line 359
  clear_screen_to_flame();
#line 361
  if (p == 1) {
#line 362
    draw_string((char *)"Left = A  Rotate = W  Right = D  Drop = S", color_blue, screen___0->w / 2,
                0, 1 | (1 << 3));
#line 364
    draw_string((char *)"Player 1: Who Are You?", color_blue, screen___0->w / 2, (wrg___1->wr + 0)->y - 30,
                1 | (1 << 3));
  } else {
#line 367
    draw_string((char *)"Use the Arrow keys. Rotate = Up  Drop = Down", color_blue,
                screen___0->w / 2, 0, 1 | (1 << 3));
#line 369
    draw_string((char *)"Player 2: Who Are You?", color_blue, screen___0->w / 2, (wrg___1->wr + 0)->y - 30,
                1 | (1 << 3));
  }
#line 373
  draw_radio(wrg___1->wr + 0, 1);
#line 375
  while (1) {
#line 376
    poll_and_flame(& event);
#line 378
    retval = handle_radio_event(wrg___1, (SDL_Event const   *)(& event));
#line 379
    if (retval == -1) {
#line 380
      continue;
    } else {
#line 379
      if (retval == taken) {
#line 380
        continue;
      }
    }
#line 381
    if (retval == (*id)->n) {
#line 382
      new_player(screen___0, id);
      goto restart;
    }
#line 385
    if (retval == (*id)->n + 1) {
#line 386
      return (-1);
    }
#line 387
    return (retval);
  }
#line 389
  return (0);
}
}
#line 1 "menu.o"
#pragma merger(0,"/tmp/cil-hAWW2ll5.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 2 ".protos/menu.pro"
ATMenu *menu(int nButtons , char **strings , int defaultchoice , Uint32 face_color0 ,
             Uint32 text_color0 , Uint32 face_color1 , Uint32 text_color1 , int x ,
             int y ) ;
#line 5
void show_menu(ATMenu *am ) ;
#line 6
int check_menu(ATMenu *am , int x , int y ) ;
#line 7
void delete_menu(ATMenu *am ) ;
#line 10
int check_radio(WalkRadio *wr , int x , int y ) ;
#line 19 "menu.c"
ATMenu *menu(int nButtons , char **strings , int defaultchoice , Uint32 face_color0 ,
             Uint32 text_color0 , Uint32 face_color1 , Uint32 text_color1 , int x ,
             int y ) 
{ int i ;
  int yp ;
  ATMenu *am ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 24
  tmp = malloc(sizeof(ATMenu ));
#line 24
  am = (ATMenu *)tmp;
#line 24
  if (! am) {
#line 24
    __assert_fail("am", "menu.c", 24U, "menu");
  }
#line 27
  tmp___0 = malloc((unsigned int )nButtons * sizeof(ATButton *));
#line 27
  am->buttons = (ATButton **)tmp___0;
#line 28
  if (! am->buttons) {
#line 28
    __assert_fail("am->buttons", "menu.c", 28U, "menu");
  }
#line 29
  tmp___1 = malloc((unsigned int )nButtons * sizeof(char ));
#line 29
  am->clicked = (char *)tmp___1;
#line 29
  if (! am->clicked) {
#line 29
    __assert_fail("am->clicked", "menu.c", 29U, "menu");
  }
#line 30
  am->nButtons = nButtons;
#line 31
  am->x = x;
#line 31
  am->y = y;
#line 32
  am->defaultchoice = defaultchoice;
#line 34
  yp = y;
#line 36
  if (! (nButtons >= 0)) {
#line 36
    Panic("menu", "menu.c", (char *)"Failed assertion \"%s\" on line %d", "nButtons >= 0",
          36);
  }
#line 38
  i = 0;
#line 38
  while (i < nButtons) {
#line 41
    *(am->buttons + i) = button(*(strings + i), face_color0, text_color0, face_color1,
                                text_color1, x, yp);
#line 43
    yp += (int )(*(am->buttons + i))->area.h;
#line 44
    *(am->clicked + i) = (char)0;
#line 38
    i ++;
  }
#line 47
  am->w = (int )(*(am->buttons + 0))->area.w;
#line 48
  am->h = ((int )(*(am->buttons + (nButtons - 1)))->area.y - (int )(*(am->buttons + 0))->area.y) + (int )(*(am->buttons + (nButtons - 1)))->area.h;
#line 51
  if (defaultchoice >= 0) {
#line 51
    *(am->clicked + defaultchoice) = (char)1;
  }
#line 53
  return (am);
}
}
#line 60 "menu.c"
void show_menu(ATMenu *am ) 
{ int i ;

  {
#line 63
  i = 0;
#line 63
  while (i < am->nButtons) {
#line 64
    show_button(*(am->buttons + i), (int )*(am->clicked + i));
#line 63
    i ++;
  }
#line 65
  return;
}
}
#line 71 "menu.c"
int check_menu(ATMenu *am , int x , int y ) 
{ int i ;
  int j ;
  char tmp ;

  {
#line 74
  i = 0;
#line 74
  while (i < am->nButtons) {
#line 75
    tmp = check_button(*(am->buttons + i), x, y);
#line 75
    if (tmp) {
#line 78
      if (*(am->clicked + i)) {
#line 80
        *(am->clicked + i) = (char)0;
#line 82
        *(am->clicked + am->defaultchoice) = (char)1;
#line 83
        show_button(*(am->buttons + am->defaultchoice), (int )*(am->clicked + am->defaultchoice));
      } else {
#line 89
        j = 0;
#line 89
        while (j < am->nButtons) {
#line 90
          if (i != j) {
#line 90
            if (*(am->clicked + j)) {
#line 92
              *(am->clicked + j) = (char)0;
#line 93
              show_button(*(am->buttons + j), (int )*(am->clicked + j));
            }
          }
#line 89
          j ++;
        }
#line 95
        *(am->clicked + i) = (char)1;
      }
#line 98
      show_button(*(am->buttons + i), (int )*(am->clicked + i));
#line 99
      printf((char const   * __restrict  )"%-14.14s| ", "check_menu");
#line 99
      printf((char const   * __restrict  )"Button %d was clicked.\n", i);
#line 99
      fflush(stdout);
#line 100
      return (i);
    }
#line 74
    i ++;
  }
#line 102
  return (-1);
}
}
#line 109 "menu.c"
void delete_menu(ATMenu *am ) 
{ int i ;

  {
#line 112
  i = 0;
#line 112
  while (i < am->nButtons) {
#line 113
    free((void *)*(am->buttons + i));
#line 113
    *(am->buttons + i) = (ATButton *)((void *)0);
#line 112
    i ++;
  }
#line 114
  free((void *)am);
#line 114
  am = (ATMenu *)((void *)0);
#line 115
  return;
}
}
#line 126 "menu.c"
void setup_radio(WalkRadio *wr ) 
{ int i ;
  int our_height ;
  void *tmp ;
  void *tmp___0 ;
  SDL_Color sc ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___1 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___2 ;

  {
#line 132
  wr->face_color[0] = int_solid_black;
#line 133
  wr->face_color[1] = int_dark_blue;
#line 134
  wr->text_color[0] = int_purple;
#line 135
  wr->text_color[1] = int_white;
#line 136
  wr->border_color[0] = int_solid_black;
#line 137
  wr->border_color[1] = int_grey;
#line 139
  tmp = malloc(sizeof(SDL_Surface *) * (unsigned int )wr->n);
#line 139
  wr->bitmap0 = (SDL_Surface **)tmp;
#line 139
  if (! wr->bitmap0) {
#line 139
    Panic("setup_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d", "wr->bitmap0",
          139);
  }
#line 140
  tmp___0 = malloc(sizeof(SDL_Surface *) * (unsigned int )wr->n);
#line 140
  wr->bitmap1 = (SDL_Surface **)tmp___0;
#line 140
  if (! wr->bitmap1) {
#line 140
    Panic("setup_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d", "wr->bitmap1",
          140);
  }
#line 141
  wr->w = 0;
#line 142
  wr->h = 0;
#line 144
  i = 0;
#line 144
  while (i < wr->n) {
#line 147
    SDL_GetRGB(wr->text_color[0], screen->format, & sc.r, & sc.g, & sc.b);
#line 148
    tmp___1 = TTF_RenderText_Blended(sfont, (char const   *)*(wr->label + i), sc);
#line 148
    *(wr->bitmap0 + i) = (SDL_Surface *)tmp___1;
#line 149
    if (! *(wr->bitmap0 + i)) {
#line 149
      Panic("setup_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d",
            "wr->bitmap0[i]", 149);
    }
#line 151
    SDL_GetRGB(wr->text_color[1], screen->format, & sc.r, & sc.g, & sc.b);
#line 152
    tmp___2 = TTF_RenderText_Blended(sfont, (char const   *)*(wr->label + i), sc);
#line 152
    *(wr->bitmap1 + i) = (SDL_Surface *)tmp___2;
#line 153
    if (! *(wr->bitmap1 + i)) {
#line 153
      Panic("setup_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d",
            "wr->bitmap1[i]", 153);
    }
#line 155
    if ((*(wr->bitmap0 + i))->w + 4 > wr->w) {
#line 156
      wr->w = (*(wr->bitmap0 + i))->w + 4;
    }
#line 157
    if ((*(wr->bitmap0 + i))->h > wr->h) {
#line 157
      wr->h = (*(wr->bitmap0 + i))->h;
    }
#line 144
    i ++;
  }
#line 159
  wr->w += 5;
#line 160
  wr->h += 10;
#line 161
  wr->area.w = (unsigned short )(wr->w + 8);
#line 163
  our_height = 12;
#line 164
  if (wr->n < our_height) {
#line 164
    our_height = wr->n;
  }
#line 166
  wr->area.h = (unsigned short )(wr->h * our_height + 8);
#line 167
  return;
}
}
#line 174 "menu.c"
int check_radio(WalkRadio *wr , int x , int y ) 
{ int start ;
  int stop ;
  int c ;

  {
#line 177
  if (wr->inactive) {
#line 177
    return (0);
  }
#line 179
  if (x >= (int )wr->area.x) {
#line 179
    if (x <= (int )wr->area.x + (int )wr->area.w) {
#line 179
      if (y >= (int )wr->area.y) {
#line 179
        if (y <= (int )wr->area.y + (int )wr->area.h) {
#line 186
          if (wr->n < 12) {
#line 187
            start = 0;
#line 188
            stop = wr->n;
          } else {
#line 190
            start = wr->defaultchoice - 6;
#line 191
            if (start < 0) {
#line 191
              start = 0;
            }
#line 192
            stop = start + 12;
#line 193
            if (stop > wr->n) {
#line 194
              start -= stop - wr->n;
#line 195
              stop = wr->n;
            }
          }
#line 198
          c = (y - (int )wr->area.y) / wr->h;
#line 199
          c += start;
#line 200
          if (c < 0) {
#line 200
            c = 0;
          }
#line 201
          if (c >= wr->n) {
#line 201
            c = wr->n - 1;
          }
#line 202
          wr->defaultchoice = c;
#line 203
          return (1);
        }
      }
    }
  }
#line 205
  return (0);
}
}
#line 212 "menu.c"
void clear_radio(WalkRadio *wr ) 
{ SDL_Rect *my_c ;

  {
#line 215
  SDL_FillRect(widget_layer, & wr->area, int_black);
#line 216
  SDL_FillRect(screen, & wr->area, int_black);
#line 217
  SDL_UpperBlit(flame_layer, & wr->area, screen, & wr->area);
#line 218
  SDL_UpperBlit(widget_layer, & wr->area, screen, & wr->area);
#line 219
  my_c = & wr->area;
#line 219
  if (! my_c) {
#line 219
    Panic("clear_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d", "my_c",
          219);
  }
#line 219
  if (my_c) {
#line 219
    if ((int )my_c->x < 0) {
#line 219
      my_c->x = (short)0;
    }
#line 219
    if ((int )my_c->y < 0) {
#line 219
      my_c->y = (short)0;
    }
#line 219
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 219
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 219
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 219
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 219
  SDL_UpdateRects(screen, 1, & wr->area);
#line 220
  return;
}
}
#line 229 "menu.c"
void draw_radio(WalkRadio *wr , int state ) 
{ int start ;
  int stop ;
  int i ;
  SDL_Rect draw ;
  int on ;
  SDL_Rect text ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  SDL_Rect *my_c ;

  {
#line 235
  if (wr->inactive) {
#line 235
    return;
  }
#line 237
  wr->area.x = (short )wr->x;
#line 238
  wr->area.y = (short )wr->y;
#line 240
  SDL_FillRect(widget_layer, & wr->area, wr->border_color[state]);
#line 242
  if (wr->n < 12) {
#line 243
    start = 0;
#line 244
    stop = wr->n;
  } else {
#line 246
    start = wr->defaultchoice - 6;
#line 247
    if (start < 0) {
#line 247
      start = 0;
    }
#line 248
    stop = start + 12;
#line 249
    if (stop > wr->n) {
#line 250
      start -= stop - wr->n;
#line 251
      stop = wr->n;
    }
  }
#line 255
  draw.x = (short )(wr->x + 4);
#line 256
  draw.y = (short )(wr->y + 4);
#line 257
  draw.w = (unsigned short )wr->w;
#line 258
  draw.h = (unsigned short )wr->h;
#line 260
  i = start;
#line 260
  while (i < stop) {
#line 261
    on = wr->defaultchoice == i;
#line 264
    SDL_FillRect(widget_layer, & draw, wr->text_color[on]);
#line 265
    draw.x = (short )((int )draw.x + 2);
#line 265
    draw.y = (short )((int )draw.y + 2);
#line 265
    draw.w = (unsigned short )((int )draw.w - 4);
#line 265
    draw.h = (unsigned short )((int )draw.h - 4);
#line 266
    if (state) {
#line 267
      SDL_FillRect(widget_layer, & draw, wr->face_color[on]);
    } else {
#line 266
      if (on) {
#line 267
        SDL_FillRect(widget_layer, & draw, wr->face_color[on]);
      } else {
#line 269
        SDL_FillRect(widget_layer, & draw, wr->border_color[on]);
      }
    }
#line 270
    draw.x = (short )((int )draw.x + 3);
#line 270
    draw.y = (short )((int )draw.y + 3);
#line 270
    draw.w = (unsigned short )((int )draw.w - 6);
#line 270
    draw.h = (unsigned short )((int )draw.h - 6);
#line 272
    text.x = draw.x;
#line 272
    text.y = draw.y;
#line 273
    text.w = (unsigned short )(*(wr->bitmap0 + i))->w;
#line 274
    text.h = (unsigned short )(*(wr->bitmap0 + i))->h;
#line 275
    text.x = (short )((int )text.x + ((int )draw.w - (int )text.w) / 2);
#line 277
    if (on) {
#line 278
      my_b = (SDL_Rect *)((void *)0);
#line 278
      my_d = & text;
#line 278
      if (my_b) {
#line 278
        if ((int )my_b->x < 0) {
#line 278
          my_b->x = (short)0;
        }
#line 278
        if ((int )my_b->y < 0) {
#line 278
          my_b->y = (short)0;
        }
#line 278
        if ((int )my_b->x + (int )my_b->w > 640) {
#line 278
          my_b->w = (unsigned short )(640 - (int )my_b->x);
        }
#line 278
        if ((int )my_b->y + (int )my_b->h > 480) {
#line 278
          my_b->h = (unsigned short )(480 - (int )my_b->y);
        }
      }
#line 278
      if (my_d) {
#line 278
        if ((int )my_d->x < 0) {
#line 278
          my_d->x = (short)0;
        }
#line 278
        if ((int )my_d->y < 0) {
#line 278
          my_d->y = (short)0;
        }
#line 278
        if ((int )my_d->x + (int )my_d->w > 640) {
#line 278
          my_d->w = (unsigned short )(640 - (int )my_d->x);
        }
#line 278
        if ((int )my_d->y + (int )my_d->h > 480) {
#line 278
          my_d->h = (unsigned short )(480 - (int )my_d->y);
        }
      }
#line 278
      tmp = SDL_UpperBlit(*(wr->bitmap1 + i), my_b, widget_layer, my_d);
#line 278
      if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 278
        Panic("draw_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d",
              "SDL_UpperBlit(wr->bitmap1[i],my_b,widget_layer,my_d) == 0", 278);
      }
    } else {
#line 280
      my_b___0 = (SDL_Rect *)((void *)0);
#line 280
      my_d___0 = & text;
#line 280
      if (my_b___0) {
#line 280
        if ((int )my_b___0->x < 0) {
#line 280
          my_b___0->x = (short)0;
        }
#line 280
        if ((int )my_b___0->y < 0) {
#line 280
          my_b___0->y = (short)0;
        }
#line 280
        if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 280
          my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
        }
#line 280
        if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 280
          my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
        }
      }
#line 280
      if (my_d___0) {
#line 280
        if ((int )my_d___0->x < 0) {
#line 280
          my_d___0->x = (short)0;
        }
#line 280
        if ((int )my_d___0->y < 0) {
#line 280
          my_d___0->y = (short)0;
        }
#line 280
        if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 280
          my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
        }
#line 280
        if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 280
          my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
        }
      }
#line 280
      tmp___0 = SDL_UpperBlit(*(wr->bitmap0 + i), my_b___0, widget_layer, my_d___0);
#line 280
      if (! (tmp___0 == (int __attribute__((__visibility__("default")))  )0)) {
#line 280
        Panic("draw_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d",
              "SDL_UpperBlit(wr->bitmap0[i],my_b,widget_layer,my_d) == 0", 280);
      }
    }
#line 282
    draw.x = (short )((int )draw.x - 5);
#line 282
    draw.y = (short )((int )draw.y - 5);
#line 282
    draw.w = (unsigned short )((int )draw.w + 10);
#line 282
    draw.h = (unsigned short )((int )draw.h + 10);
#line 284
    draw.y = (short )((int )draw.y + (int )draw.h);
#line 260
    i ++;
  }
#line 287
  SDL_UpperBlit(flame_layer, & wr->area, screen, & wr->area);
#line 288
  SDL_UpperBlit(widget_layer, & wr->area, screen, & wr->area);
#line 289
  my_c = & wr->area;
#line 289
  if (! my_c) {
#line 289
    Panic("draw_radio", "menu.c", (char *)"Failed assertion \"%s\" on line %d", "my_c",
          289);
  }
#line 289
  if (my_c) {
#line 289
    if ((int )my_c->x < 0) {
#line 289
      my_c->x = (short)0;
    }
#line 289
    if ((int )my_c->y < 0) {
#line 289
      my_c->y = (short)0;
    }
#line 289
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 289
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 289
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 289
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 289
  SDL_UpdateRects(screen, 1, & wr->area);
#line 290
  return;
}
}
#line 297 "menu.c"
WalkRadioGroup *create_single_wrg(int n ) 
{ WalkRadioGroup *wrg___1 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 302
  tmp = calloc(sizeof(*wrg___1), 1U);
#line 302
  wrg___1 = (WalkRadioGroup *)tmp;
#line 302
  if (! wrg___1) {
#line 302
    Panic("create_single_wrg", "menu.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for wrg",
          sizeof(*wrg___1));
  }
#line 303
  wrg___1->n = 1;
#line 304
  tmp___0 = calloc((unsigned int )wrg___1->n * sizeof(*(wrg___1->wr)), 1U);
#line 304
  wrg___1->wr = (WalkRadio *)tmp___0;
#line 304
  if (! wrg___1->wr) {
#line 304
    Panic("create_single_wrg", "menu.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for wrg->wr",
          (unsigned int )wrg___1->n * sizeof(*(wrg___1->wr)));
  }
#line 305
  (wrg___1->wr + 0)->n = n;
#line 306
  tmp___1 = calloc((unsigned int )(wrg___1->wr + 0)->n * sizeof(*((wrg___1->wr + 0)->label)),
                   1U);
#line 306
  (wrg___1->wr + 0)->label = (char **)tmp___1;
#line 306
  if (! (wrg___1->wr + 0)->label) {
#line 306
    Panic("create_single_wrg", "menu.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for wrg->wr[0].label",
          (unsigned int )(wrg___1->wr + 0)->n * sizeof(*((wrg___1->wr + 0)->label)));
  }
#line 307
  return (wrg___1);
}
}
#line 315 "menu.c"
int handle_radio_event(WalkRadioGroup *wrg___1 , SDL_Event const   *ev ) 
{ int i ;
  int ret ;
  int tmp ;

  {
#line 319
  if ((int const   )ev->type == 5) {
#line 320
    i = 0;
#line 320
    while (i < wrg___1->n) {
#line 321
      tmp = check_radio(wrg___1->wr + i, (int )ev->button.x, (int )ev->button.y);
#line 321
      if (tmp) {
#line 322
        if (i != wrg___1->cur) {
#line 323
          draw_radio(wrg___1->wr + wrg___1->cur, 0);
        }
#line 325
        draw_radio(wrg___1->wr + i, 1);
#line 326
        if ((wrg___1->wr + i)->action) {
#line 327
          ret = (*((wrg___1->wr + i)->action))(wrg___1->wr + i);
#line 328
          return (ret);
        } else {
#line 330
          return ((wrg___1->wr + i)->defaultchoice);
        }
      }
#line 320
      i ++;
    }
  } else {
#line 333
    if ((int const   )ev->type == 2) {
#line 334
      switch ((int )ev->key.keysym.sym) {
      case 13: 
#line 336
      if ((wrg___1->wr + wrg___1->cur)->action) {
#line 337
        ret = (*((wrg___1->wr + wrg___1->cur)->action))(wrg___1->wr + wrg___1->cur);
#line 338
        return (ret);
      } else {
#line 340
        return ((wrg___1->wr + wrg___1->cur)->defaultchoice);
      }
#line 341
      return (1);
      case 273: 
#line 344
      ((wrg___1->wr + wrg___1->cur)->defaultchoice) --;
#line 345
      if ((wrg___1->wr + wrg___1->cur)->defaultchoice < 0) {
#line 346
        (wrg___1->wr + wrg___1->cur)->defaultchoice = (wrg___1->wr + wrg___1->cur)->n - 1;
      }
#line 347
      draw_radio(wrg___1->wr + wrg___1->cur, 1);
#line 348
      return (-1);
#line 349
      break;
      case 274: 
#line 352
      ((wrg___1->wr + wrg___1->cur)->defaultchoice) ++;
#line 353
      if ((wrg___1->wr + wrg___1->cur)->defaultchoice >= (wrg___1->wr + wrg___1->cur)->n) {
#line 354
        (wrg___1->wr + wrg___1->cur)->defaultchoice = 0;
      }
#line 355
      draw_radio(wrg___1->wr + wrg___1->cur, 1);
#line 356
      return (-1);
      case 276: 
#line 359
      draw_radio(wrg___1->wr + wrg___1->cur, 0);
#line 360
      while (1) {
#line 361
        (wrg___1->cur) --;
#line 362
        if (wrg___1->cur < 0) {
#line 363
          wrg___1->cur = wrg___1->n - 1;
        }
#line 360
        if (! (wrg___1->wr + wrg___1->cur)->inactive) {
#line 360
          break;
        }
      }
#line 365
      draw_radio(wrg___1->wr + wrg___1->cur, 1);
#line 366
      return (-1);
      case 275: 
#line 369
      draw_radio(wrg___1->wr + wrg___1->cur, 0);
#line 370
      while (1) {
#line 371
        (wrg___1->cur) ++;
#line 372
        if (wrg___1->cur >= wrg___1->n) {
#line 373
          wrg___1->cur = 0;
        }
#line 370
        if (! (wrg___1->wr + wrg___1->cur)->inactive) {
#line 370
          break;
        }
      }
#line 375
      draw_radio(wrg___1->wr + wrg___1->cur, 1);
#line 376
      return (-1);
      default: ;
#line 379
      return (-1);
      }
    }
  }
#line 382
  return (-1);
}
}
#line 1 "network.o"
#pragma merger(0,"/tmp/cil-iWZW4KkH.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 192
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 131 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 138
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 36 "network.c"
char *error_msg  =    (char *)((void *)0);
#line 46 "network.c"
static struct sockaddr_in addr  ;
#line 47 "network.c"
static struct hostent *host  ;
#line 48 "network.c"
static int sockListen  =    0;
#line 49 "network.c"
static int addrLen  ;
#line 43 "network.c"
int Server_AwaitConnection(int port ) 
{ int val1 ;
  struct linger val2 ;
  int sock ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  fd_set read_fds ;
  struct timeval timeout ;
  int retval ;
  int __d0 ;
  int __d1 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
#line 54
  if (sockListen == 0) {
#line 55
    memset((void *)(& addr), 0, sizeof(addr));
#line 56
    addr.sin_family = (unsigned short)2;
#line 57
    __x = 0U;
#line 57
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 57
    addr.sin_addr.s_addr = __v;
#line 58
    __x___0 = (unsigned short )port;
#line 58
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 58
    addr.sin_port = __v___0;
#line 59
    sockListen = socket(2, 1, 0);
#line 61
    error_msg = (char *)0;
#line 63
    if (sockListen < 0) {
#line 64
      printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 64
      tmp = __errno_location();
#line 64
      error_msg = strerror(*tmp);
#line 64
      printf((char const   * __restrict  )"unable to create socket: %s\n", error_msg);
#line 64
      fflush(stdout);
#line 65
      return (-1);
    }
#line 68
    val1 = 1;
#line 71
    tmp___1 = fcntl(sockListen, 4, 2048);
#line 71
    if (tmp___1) {
#line 72
      printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 72
      tmp___0 = __errno_location();
#line 72
      error_msg = strerror(*tmp___0);
#line 72
      printf((char const   * __restrict  )"unable to make socket non-blocking: %s\n",
             error_msg);
#line 72
      fflush(stdout);
#line 73
      return (-1);
    }
#line 77
    tmp___2 = setsockopt(sockListen, 1, 2, (void const   *)((void *)(& val1)), sizeof(val1));
#line 77
    if (tmp___2) {
#line 79
      printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 79
      printf((char const   * __restrict  )"WARNING: setsockopt(...,SO_REUSEADDR) failed. You may have to wait a\n\tfew minutes before you can try to be the server again.\n");
#line 79
      fflush(stdout);
    }
#line 82
    tmp___4 = bind(sockListen, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                   sizeof(addr));
#line 82
    if (tmp___4) {
#line 83
      printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 83
      tmp___3 = __errno_location();
#line 83
      error_msg = strerror(*tmp___3);
#line 83
      printf((char const   * __restrict  )"unable to bind socket (for listening): %s\n",
             error_msg);
#line 83
      fflush(stdout);
#line 84
      return (-1);
    }
#line 86
    tmp___6 = listen(sockListen, 16);
#line 86
    if (tmp___6) {
#line 87
      printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 87
      tmp___5 = __errno_location();
#line 87
      error_msg = strerror(*tmp___5);
#line 87
      printf((char const   * __restrict  )"unable to listen on socket: %s\n", error_msg);
#line 87
      fflush(stdout);
#line 88
      return (-1);
    }
#line 91
    addrLen = (int )sizeof(addr);
#line 93
    printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 93
    printf((char const   * __restrict  )"accepting connections on port %d, socketfd %d\n",
           port, sockListen);
#line 93
    fflush(stdout);
  }
#line 100
  timeout.tv_sec = (__time_t )0;
#line 100
  timeout.tv_usec = (__suseconds_t )0;
#line 103
  while (1) {
#line 103
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& read_fds.fds_bits[0]): "memory");
#line 103
    break;
  }
#line 104
  __asm__  volatile   ("btsl %1,%0": "=m" (read_fds.fds_bits[(unsigned int )sockListen / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )sockListen % (8U * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 106
  retval = select(sockListen + 1, (fd_set * __restrict  )(& read_fds), (fd_set * __restrict  )((void *)0),
                  (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
#line 108
  if (retval <= 0) {
#line 110
    return (-1);
  }
#line 114
  sock = accept(sockListen, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                (socklen_t * __restrict  )(& addrLen));
#line 115
  if (sock < 0) {
#line 116
    tmp___8 = __errno_location();
#line 116
    if (*tmp___8 == 11) {
#line 121
      return (-1);
    } else {
#line 116
      tmp___9 = __errno_location();
#line 116
      if (*tmp___9 == 11) {
#line 121
        return (-1);
      } else {
#line 123
        printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 123
        tmp___7 = __errno_location();
#line 123
        error_msg = strerror(*tmp___7);
#line 123
        printf((char const   * __restrict  )"unable to accept on listening socket: %s\n",
               error_msg);
#line 123
        fflush(stdout);
#line 124
        return (-1);
      }
    }
  }
#line 128
  val2.l_onoff = 0;
#line 128
  val2.l_linger = 0;
#line 129
  tmp___10 = setsockopt(sock, 1, 13, (void const   *)((void *)(& val2)), sizeof(val2));
#line 129
  if (tmp___10) {
#line 130
    printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 130
    printf((char const   * __restrict  )"WARNING: setsockopt(...,SO_LINGER) failed. You may have to wait a few\n\tminutes before you can try to be the server again.\n");
#line 130
    fflush(stdout);
  }
#line 133
  host = gethostbyaddr((void const   *)((void *)(& addr.sin_addr)), sizeof(struct in_addr ),
                       2);
#line 134
  if (! host) {
#line 135
    printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 135
    printf((char const   * __restrict  )"connection from some unresolvable IP address, socketfd %d.\n",
           sock);
#line 135
    fflush(stdout);
  } else {
#line 137
    printf((char const   * __restrict  )"%-14.14s| ", "Server_AwaitConnection");
#line 137
    printf((char const   * __restrict  )"connection from %s, socketfd %d.\n", host->h_name,
           sock);
#line 137
    fflush(stdout);
  }
#line 138
  return (sock);
}
}
#line 148 "network.c"
int Client_Connect(char *hoststr , int lport ) 
{ struct sockaddr_in addr___0 ;
  struct hostent *host___0 ;
  int mySock ;
  short port ;
  int retval ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 154
  port = (short )lport;
#line 157
  error_msg = (char *)((void *)0);
#line 159
  host___0 = gethostbyname((char const   *)hoststr);
#line 160
  if (! host___0) {
#line 161
    printf((char const   * __restrict  )"%-14.14s| ", "Client_Connect");
#line 161
    printf((char const   * __restrict  )"unable to resolve [%s]: unknown hostname\n",
           hoststr);
#line 161
    fflush(stdout);
#line 162
    error_msg = (char *)"unknown hostname";
#line 163
    return (-1);
  }
#line 166
  printf((char const   * __restrict  )"%-14.14s| ", "Client_Connect");
#line 166
  printf((char const   * __restrict  )"connecting to %s:%d ...\n", host___0->h_name,
         port);
#line 166
  fflush(stdout);
#line 168
  memset((void *)(& addr___0), 0, sizeof(addr___0));
#line 169
  addr___0.sin_family = (unsigned short)2;
#line 170
  memcpy((void * __restrict  )(& addr___0.sin_addr), (void const   * __restrict  )*(host___0->h_addr_list + 0),
         (unsigned int )host___0->h_length);
#line 171
  __x = (unsigned short )port;
#line 171
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 171
  addr___0.sin_port = __v;
#line 172
  mySock = socket(2, 1, 0);
#line 173
  if (mySock < 0) {
#line 174
    printf((char const   * __restrict  )"%-14.14s| ", "Client_Connect");
#line 174
    tmp = __errno_location();
#line 174
    error_msg = strerror(*tmp);
#line 174
    printf((char const   * __restrict  )"unable to create socket: %s\n", error_msg);
#line 174
    fflush(stdout);
#line 175
    return (-1);
  }
#line 178
  retval = connect(mySock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr___0)),
                   sizeof(addr___0));
#line 180
  if (retval < 0) {
#line 181
    printf((char const   * __restrict  )"%-14.14s| ", "Client_Connect");
#line 181
    tmp___0 = __errno_location();
#line 181
    error_msg = strerror(*tmp___0);
#line 181
    printf((char const   * __restrict  )"unable to connect: %s\n", error_msg);
#line 181
    fflush(stdout);
#line 182
    close(mySock);
#line 183
    return (-1);
  }
#line 186
  printf((char const   * __restrict  )"%-14.14s| ", "Client_Connect");
#line 186
  printf((char const   * __restrict  )"connected to %s:%d, socketfd %d.\n", host___0->h_name,
         port, mySock);
#line 186
  fflush(stdout);
#line 187
  return (mySock);
}
}
#line 195 "network.c"
int Network_Init(void) 
{ 

  {
#line 210
  return (0);
}
}
#line 217 "network.c"
void Network_Quit(void) 
{ 

  {
#line 229
  return;
}
}
#line 1 "piece.o"
#pragma merger(0,"/tmp/cil-bs9JQact.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 405 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 586 "/usr/include/SDL/SDL_video.h"
extern int __attribute__((__visibility__("default")))  SDL_SetAlpha(SDL_Surface *surface ,
                                                                    Uint32 flag ,
                                                                    Uint8 alpha ) ;
#line 40 "piece.c"
static piece_style *load_piece_style(char const   *filename ) 
{ piece_style *retval ;
  char buf[2048] ;
  FILE *fin ;
  FILE *tmp ;
  int i ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  char *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  int x ;
  int y ;
  int rot ;
  int counter ;
  int tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 45
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rt");
#line 45
  fin = tmp;
#line 48
  if (! fin) {
#line 49
    printf((char const   * __restrict  )"%-14.14s| ", "load_piece_style");
#line 49
    printf((char const   * __restrict  )"fopen(%s)\n", filename);
#line 49
    fflush(stdout);
#line 50
    return ((piece_style *)((void *)0));
  }
#line 52
  tmp___0 = calloc(sizeof(piece_style ), 1U);
#line 52
  retval = (piece_style *)tmp___0;
#line 52
  if (! retval) {
#line 52
    Panic("load_piece_style", "piece.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
          sizeof(piece_style ));
  }
#line 54
  fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 55
  tmp___1 = feof(fin);
#line 55
  if (tmp___1) {
#line 56
    printf((char const   * __restrict  )"%-14.14s| ", "load_piece_style");
#line 56
    printf((char const   * __restrict  )"unexpected EOF after name in [%s]\n", filename);
#line 56
    fflush(stdout);
#line 57
    free((void *)retval);
#line 58
    return ((piece_style *)((void *)0));
  }
#line 61
  tmp___5 = __builtin_strchr(buf, '\n');
#line 61
  if (tmp___5) {
#line 62
    tmp___3 = __builtin_strchr(buf, '\n');
#line 62
    *tmp___3 = (char)0;
  }
#line 63
  tmp___15 = __strdup((char const   *)(buf));
#line 63
  retval->name = tmp___15;
#line 65
  tmp___16 = fscanf((FILE * __restrict  )fin, (char const   * __restrict  )"%d", & retval->num_piece);
#line 65
  if (tmp___16 != 1) {
#line 66
    printf((char const   * __restrict  )"%-14.14s| ", "load_piece_style");
#line 66
    printf((char const   * __restrict  )"malformed piece count in [%s]\n", filename);
#line 66
    fflush(stdout);
#line 67
    free((void *)retval->name);
#line 68
    free((void *)retval);
#line 69
    return ((piece_style *)((void *)0));
  }
#line 72
  tmp___17 = calloc((unsigned int )retval->num_piece * sizeof(piece ), 1U);
#line 72
  retval->shape = (piece *)tmp___17;
#line 72
  if (! retval->shape) {
#line 72
    Panic("load_piece_style", "piece.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval->shape",
          (unsigned int )retval->num_piece * sizeof(piece ));
  }
#line 74
  i = 0;
#line 74
  while (i < retval->num_piece) {
#line 76
    while (1) {
#line 77
      fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 78
      tmp___18 = feof(fin);
#line 78
      if (tmp___18) {
#line 79
        Panic("load_piece_style", "piece.c", (char *)"unexpected EOF in [%s], before piece %d",
              filename, i + 1);
      }
#line 76
      if (! ((int )buf[0] == 10)) {
#line 76
        break;
      }
    }
#line 81
    tmp___19 = strlen((char const   *)(buf));
#line 81
    (retval->shape + i)->dim = (int )(tmp___19 - 1U);
#line 82
    if ((retval->shape + i)->dim <= 0) {
#line 83
      Panic("load_piece_style", "piece.c", (char *)"piece %d malformed height/width in [%s]",
            i, filename);
    }
#line 88
    rot = 0;
#line 88
    while (rot < 4) {
#line 89
      tmp___20 = malloc((unsigned int )((retval->shape + i)->dim * (retval->shape + i)->dim));
#line 89
      (retval->shape + i)->bitmap[rot] = (unsigned char *)tmp___20;
#line 89
      if (! (retval->shape + i)->bitmap[rot]) {
#line 89
        Panic("load_piece_style", "piece.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for retval->shape[i].bitmap[rot]",
              (retval->shape + i)->dim * (retval->shape + i)->dim);
      }
#line 88
      rot ++;
    }
#line 92
    counter = 1;
#line 93
    y = 0;
#line 93
    while (y < (retval->shape + i)->dim) {
#line 94
      x = 0;
#line 94
      while (x < (retval->shape + i)->dim) {
#line 95
        if ((int )buf[x] != 46) {
#line 95
          tmp___22 = counter;
#line 95
          counter ++;
#line 95
          *((retval->shape + i)->bitmap[0] + ((retval->shape + i)->dim * y + x)) = (unsigned char )tmp___22;
        } else {
#line 95
          *((retval->shape + i)->bitmap[0] + ((retval->shape + i)->dim * y + x)) = (unsigned char)0;
        }
#line 94
        x ++;
      }
#line 98
      if (y != (retval->shape + i)->dim - 1) {
#line 98
        while (1) {
#line 99
          fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 100
          tmp___23 = feof(fin);
#line 100
          if (tmp___23) {
#line 101
            Panic("load_piece_style", "piece.c", (char *)"unexpected EOF in [%s]",
                  filename);
          }
#line 98
          if (! ((int )buf[0] == 10)) {
#line 98
            break;
          }
        }
      }
#line 93
      y ++;
    }
#line 104
    (retval->shape + i)->num_color = counter - 1;
#line 106
    rot = 1;
#line 106
    while (rot < 4) {
#line 107
      y = 0;
#line 107
      while (y < (retval->shape + i)->dim) {
#line 108
        x = 0;
#line 108
        while (x < (retval->shape + i)->dim) {
#line 109
          *((retval->shape + i)->bitmap[rot] + ((retval->shape + i)->dim * y + x)) = *((retval->shape + i)->bitmap[rot - 1] + ((retval->shape + i)->dim * x + (((retval->shape + i)->dim - 1) - y)));
#line 108
          x ++;
        }
#line 107
        y ++;
      }
#line 106
      rot ++;
    }
#line 74
    i ++;
  }
#line 130
  printf((char const   * __restrict  )"%-14.14s| ", "load_piece_style");
#line 130
  printf((char const   * __restrict  )"Piece Style [%s] loaded (%d pieces).\n", retval->name,
         retval->num_piece);
#line 130
  fflush(stdout);
#line 132
  return (retval);
}
}
#line 140 "piece.c"
static int piece_Select(struct dirent  const  *d ) 
{ char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 143
  tmp = strstr((char const   *)(d->d_name), ".Piece");
#line 143
  if (tmp) {
#line 143
    tmp___0 = strlen((char const   *)(d->d_name));
#line 143
    tmp___1 = strstr((char const   *)(d->d_name), ".Piece");
#line 143
    if ((int )tmp___0 == (tmp___1 - (char *)(d->d_name)) + 6) {
#line 146
      return (1);
    } else {
#line 148
      return (0);
    }
  } else {
#line 148
    return (0);
  }
}
}
#line 155 "piece.c"
piece_styles load_piece_styles(void) 
{ piece_styles retval ;
  int i ;
  DIR *my_dir ;
  char filespec[2048] ;
  struct dirent *this_file ;
  struct dirent *tmp ;
  int tmp___0 ;
  int j ;
  void *tmp___1 ;
  struct dirent *this_file___0 ;
  struct dirent *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 159
  i = 0;
#line 163
  memset((void *)(& retval), 0, sizeof(retval));
#line 165
  my_dir = opendir("styles");
#line 166
  if (my_dir) {
#line 167
    while (1) {
#line 168
      tmp = readdir(my_dir);
#line 168
      this_file = tmp;
#line 169
      if (! this_file) {
#line 169
        break;
      }
#line 170
      tmp___0 = piece_Select((struct dirent  const  *)this_file);
#line 170
      if (tmp___0) {
#line 171
        i ++;
      }
    }
#line 173
    closedir(my_dir);
  } else {
#line 175
    Panic("load_piece_styles", "piece.c", (char *)"Cannot read directory [styles/]");
  }
#line 177
  my_dir = opendir("styles");
#line 178
  if (my_dir) {
#line 179
    if (i > 0) {
#line 181
      tmp___1 = calloc(sizeof(*(retval.style)) * (unsigned int )i, 1U);
#line 181
      retval.style = (piece_style **)tmp___1;
#line 181
      if (! retval.style) {
#line 181
        Panic("load_piece_styles", "piece.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.style",
              sizeof(*(retval.style)) * (unsigned int )i);
      }
#line 182
      retval.num_style = i;
#line 183
      j = 0;
#line 184
      while (j < i) {
#line 185
        tmp___2 = readdir(my_dir);
#line 185
        this_file___0 = tmp___2;
#line 186
        tmp___3 = piece_Select((struct dirent  const  *)this_file___0);
#line 186
        if (! tmp___3) {
#line 186
          continue;
        }
#line 187
        sprintf((char * __restrict  )(filespec), (char const   * __restrict  )"styles/%s",
                this_file___0->d_name);
#line 188
        *(retval.style + j) = load_piece_style((char const   *)(filespec));
#line 189
        tmp___4 = strstr((char const   *)(*(retval.style + j))->name, "Default");
#line 189
        if (tmp___4) {
#line 190
          retval.choice = j;
        }
#line 191
        j ++;
      }
#line 193
      closedir(my_dir);
#line 194
      return (retval);
    } else {
#line 196
      Panic("load_piece_styles", "piece.c", (char *)"No piece styles [styles/*.Piece] found.\n");
    }
  } else {
#line 199
    Panic("load_piece_styles", "piece.c", (char *)"Cannot read directory [styles/]");
  }
#line 201
  return (retval);
}
}
#line 208 "piece.c"
static color_style *load_color_style(SDL_Surface *screen___0 , char const   *filename ) 
{ color_style *retval ;
  char buf[2048] ;
  FILE *fin ;
  FILE *tmp ;
  int i ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  char *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  SDL_Surface *imagebmp ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___21 ;
  char *tmp___23 ;
  SDL_RWops __attribute__((__visibility__("default")))  *tmp___24 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___25 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___26 ;

  {
#line 213
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rt");
#line 213
  fin = tmp;
#line 216
  if (! fin) {
#line 217
    printf((char const   * __restrict  )"%-14.14s| ", "load_color_style");
#line 217
    printf((char const   * __restrict  )"fopen(%s)\n", filename);
#line 217
    fflush(stdout);
#line 218
    return ((color_style *)((void *)0));
  }
#line 220
  tmp___0 = calloc(sizeof(*retval), 1U);
#line 220
  retval = (color_style *)tmp___0;
#line 220
  if (! retval) {
#line 220
    Panic("load_color_style", "piece.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
          sizeof(*retval));
  }
#line 222
  fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 223
  tmp___1 = feof(fin);
#line 223
  if (tmp___1) {
#line 224
    printf((char const   * __restrict  )"%-14.14s| ", "load_color_style");
#line 224
    printf((char const   * __restrict  )"unexpected EOF after name in [%s]\n", filename);
#line 224
    fflush(stdout);
#line 225
    free((void *)retval);
#line 226
    return ((color_style *)((void *)0));
  }
#line 228
  tmp___5 = __builtin_strchr(buf, '\n');
#line 228
  if (tmp___5) {
#line 229
    tmp___3 = __builtin_strchr(buf, '\n');
#line 229
    *tmp___3 = (char)0;
  }
#line 230
  tmp___15 = __strdup((char const   *)(buf));
#line 230
  retval->name = tmp___15;
#line 232
  tmp___16 = fscanf((FILE * __restrict  )fin, (char const   * __restrict  )"%d\n",
                    & retval->num_color);
#line 232
  if (tmp___16 != 1) {
#line 233
    printf((char const   * __restrict  )"%-14.14s| ", "load_color_style");
#line 233
    printf((char const   * __restrict  )"malformed color count in [%s]\n", filename);
#line 233
    fflush(stdout);
#line 234
    free((void *)retval->name);
#line 235
    free((void *)retval);
#line 236
    return ((color_style *)((void *)0));
  }
#line 239
  tmp___17 = malloc((unsigned int )(retval->num_color + 1) * sizeof(*(retval->color + 0)));
#line 239
  retval->color = (SDL_Surface **)tmp___17;
#line 239
  if (! retval->color) {
#line 239
    Panic("load_color_style", "piece.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for retval->color",
          (unsigned int )(retval->num_color + 1) * sizeof(*(retval->color + 0)));
  }
#line 242
  i = 1;
#line 242
  while (i <= retval->num_color) {
#line 245
    while (1) {
#line 246
      buf[0] = (char)0;
#line 247
      fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 245
      tmp___18 = feof(fin);
#line 245
      if (tmp___18) {
#line 245
        break;
      } else {
#line 245
        if (! ((int )buf[0] == 10)) {
#line 245
          if (! ((int )buf[0] == 35)) {
#line 245
            break;
          }
        }
      }
    }
#line 250
    tmp___19 = feof(fin);
#line 250
    if (tmp___19) {
#line 250
      Panic("load_color_style", "piece.c", (char *)"unexpected EOF in color style [%s]",
            retval->name);
    }
#line 251
    tmp___23 = __builtin_strchr(buf, '\n');
#line 251
    if (tmp___23) {
#line 252
      tmp___21 = __builtin_strchr(buf, '\n');
#line 252
      *tmp___21 = (char)0;
    }
#line 254
    tmp___24 = SDL_RWFromFile((char const   *)(buf), "rb");
#line 254
    tmp___25 = SDL_LoadBMP_RW((SDL_RWops *)tmp___24, 1);
#line 254
    imagebmp = (SDL_Surface *)tmp___25;
#line 255
    if (! imagebmp) {
#line 256
      Panic("load_color_style", "piece.c", (char *)"cannot load [%s] in color style [%s]",
            buf, retval->name);
    }
#line 258
    if ((unsigned int )(imagebmp->format)->palette != (unsigned int )((void *)0)) {
#line 259
      SDL_SetColors(screen___0, ((imagebmp->format)->palette)->colors, 0, ((imagebmp->format)->palette)->ncolors);
    }
#line 264
    tmp___26 = SDL_DisplayFormat(imagebmp);
#line 264
    *(retval->color + i) = (SDL_Surface *)tmp___26;
#line 265
    SDL_FreeSurface(imagebmp);
#line 266
    if (! *(retval->color + i)) {
#line 267
      Panic("load_color_style", "piece.c", (char *)"could not convert [%s] in color style [%s]",
            buf, retval->name);
    }
#line 269
    if (i == 1) {
#line 270
      retval->h = (*(retval->color + i))->h;
#line 271
      retval->w = (*(retval->color + i))->w;
    } else {
#line 273
      if (retval->h != (*(retval->color + i))->h) {
#line 275
        Panic("load_color_style", "piece.c", (char *)"[%s] has the wrong size in color style [%s]",
              buf, retval->name);
      } else {
#line 273
        if (retval->w != (*(retval->color + i))->w) {
#line 275
          Panic("load_color_style", "piece.c", (char *)"[%s] has the wrong size in color style [%s]",
                buf, retval->name);
        }
      }
    }
#line 242
    i ++;
  }
#line 280
  *(retval->color + 0) = *(retval->color + 1);
#line 282
  printf((char const   * __restrict  )"%-14.14s| ", "load_color_style");
#line 282
  printf((char const   * __restrict  )"Color Style [%s] loaded (%d colors).\n", retval->name,
         retval->num_color);
#line 282
  fflush(stdout);
#line 285
  return (retval);
}
}
#line 293 "piece.c"
static int color_Select(struct dirent  const  *d ) 
{ char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 296
  tmp = strstr((char const   *)(d->d_name), ".Color");
#line 296
  if (tmp) {
#line 296
    tmp___0 = strlen((char const   *)(d->d_name));
#line 296
    tmp___1 = strstr((char const   *)(d->d_name), ".Color");
#line 296
    if ((int )tmp___0 == (tmp___1 - (char *)(d->d_name)) + 6) {
#line 299
      return (1);
    } else {
#line 301
      return (0);
    }
  } else {
#line 301
    return (0);
  }
}
}
#line 308 "piece.c"
static void load_special(void) 
{ int i ;
  char *filename[6] ;
  void *tmp ;
  SDL_Surface *imagebmp ;
  SDL_RWops __attribute__((__visibility__("default")))  *tmp___0 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___1 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___2 ;

  {
#line 313
  filename[0] = (char *)"graphics/Special-Bomb.bmp";
#line 313
  filename[1] = (char *)"graphics/Special-Drip.bmp";
#line 313
  filename[2] = (char *)"graphics/Special-DownArrow.bmp";
#line 313
  filename[3] = (char *)"graphics/Special-Skull.bmp";
#line 313
  filename[4] = (char *)"graphics/Special-X.bmp";
#line 313
  filename[5] = (char *)"graphics/Special-YinYang.bmp";
#line 321
  special_style.name = (char *)"Special Pieces";
#line 322
  special_style.num_color = 6;
#line 323
  tmp = malloc(6U * sizeof(SDL_Surface *));
#line 323
  special_style.color = (SDL_Surface **)tmp;
#line 323
  if (! special_style.color) {
#line 323
    Panic("load_special", "piece.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for special_style.color",
          6U * sizeof(SDL_Surface *));
  }
#line 324
  special_style.w = 20;
#line 325
  special_style.h = 20;
#line 327
  i = 0;
#line 327
  while (i < 6) {
#line 330
    tmp___0 = SDL_RWFromFile((char const   *)filename[i], "rb");
#line 330
    tmp___1 = SDL_LoadBMP_RW((SDL_RWops *)tmp___0, 1);
#line 330
    imagebmp = (SDL_Surface *)tmp___1;
#line 331
    if (! imagebmp) {
#line 332
      Panic("load_special", "piece.c", (char *)"cannot load [%s], a required special piece",
            filename[i]);
    }
#line 333
    if ((unsigned int )(imagebmp->format)->palette != (unsigned int )((void *)0)) {
#line 334
      SDL_SetColors(screen, ((imagebmp->format)->palette)->colors, 0, ((imagebmp->format)->palette)->ncolors);
    }
#line 339
    tmp___2 = SDL_DisplayFormat(imagebmp);
#line 339
    *(special_style.color + i) = (SDL_Surface *)tmp___2;
#line 340
    SDL_FreeSurface(imagebmp);
#line 341
    if (! *(special_style.color + i)) {
#line 342
      Panic("load_special", "piece.c", (char *)"could not convert [%s], a required special piece",
            filename[i]);
    }
#line 327
    i ++;
  }
#line 344
  return;
}
}
#line 351 "piece.c"
static void load_edges(void) 
{ int i ;
  char *filename[4] ;
  SDL_Surface *imagebmp ;
  SDL_RWops __attribute__((__visibility__("default")))  *tmp ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___0 ;
  SDL_Surface __attribute__((__visibility__("default")))  *tmp___1 ;

  {
#line 355
  filename[0] = (char *)"graphics/Horiz-Light.bmp";
#line 355
  filename[1] = (char *)"graphics/Vert-Light.bmp";
#line 355
  filename[2] = (char *)"graphics/Horiz-Dark.bmp";
#line 355
  filename[3] = (char *)"graphics/Vert-Dark.bmp";
#line 361
  i = 0;
#line 361
  while (i < 4) {
#line 364
    tmp = SDL_RWFromFile((char const   *)filename[i], "rb");
#line 364
    tmp___0 = SDL_LoadBMP_RW((SDL_RWops *)tmp, 1);
#line 364
    imagebmp = (SDL_Surface *)tmp___0;
#line 365
    if (! imagebmp) {
#line 366
      Panic("load_edges", "piece.c", (char *)"cannot load [%s], a required edge",
            filename[i]);
    }
#line 368
    if ((unsigned int )(imagebmp->format)->palette != (unsigned int )((void *)0)) {
#line 369
      SDL_SetColors(screen, ((imagebmp->format)->palette)->colors, 0, ((imagebmp->format)->palette)->ncolors);
    }
#line 374
    tmp___1 = SDL_DisplayFormat(imagebmp);
#line 374
    edge[i] = (SDL_Surface *)tmp___1;
#line 375
    SDL_FreeSurface(imagebmp);
#line 376
    if (! edge[i]) {
#line 377
      Panic("load_edges", "piece.c", (char *)"could not convert [%s], a required edge",
            filename[i]);
    }
#line 379
    SDL_SetAlpha(edge[i], 81920U, (unsigned char)48);
#line 361
    i ++;
  }
#line 381
  return;
}
}
#line 389 "piece.c"
color_styles load_color_styles(SDL_Surface *screen___0 ) 
{ color_styles retval ;
  int i ;
  DIR *my_dir ;
  char filespec[2048] ;
  struct dirent *this_file ;
  struct dirent *tmp ;
  int tmp___0 ;
  int j ;
  void *tmp___1 ;
  struct dirent *this_file___0 ;
  struct dirent *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 393
  i = 0;
#line 397
  load_edges();
#line 398
  load_special();
#line 400
  memset((void *)(& retval), 0, sizeof(retval));
#line 402
  my_dir = opendir("styles");
#line 403
  if (my_dir) {
#line 404
    while (1) {
#line 405
      tmp = readdir(my_dir);
#line 405
      this_file = tmp;
#line 406
      if (! this_file) {
#line 406
        break;
      }
#line 407
      tmp___0 = color_Select((struct dirent  const  *)this_file);
#line 407
      if (tmp___0) {
#line 408
        i ++;
      }
    }
#line 410
    closedir(my_dir);
  } else {
#line 412
    Panic("load_color_styles", "piece.c", (char *)"Cannot read directory [styles/]");
  }
#line 414
  my_dir = opendir("styles");
#line 415
  if (my_dir) {
#line 416
    if (i > 0) {
#line 418
      tmp___1 = calloc(sizeof(*(retval.style)) * (unsigned int )i, 1U);
#line 418
      retval.style = (color_style **)tmp___1;
#line 418
      if (! retval.style) {
#line 418
        Panic("load_color_styles", "piece.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.style",
              sizeof(*(retval.style)) * (unsigned int )i);
      }
#line 419
      retval.num_style = i;
#line 420
      j = 0;
#line 421
      while (j < i) {
#line 422
        tmp___2 = readdir(my_dir);
#line 422
        this_file___0 = tmp___2;
#line 423
        tmp___3 = color_Select((struct dirent  const  *)this_file___0);
#line 423
        if (! tmp___3) {
#line 423
          continue;
        }
#line 424
        sprintf((char * __restrict  )(filespec), (char const   * __restrict  )"styles/%s",
                this_file___0->d_name);
#line 425
        *(retval.style + j) = load_color_style(screen___0, (char const   *)(filespec));
#line 426
        tmp___4 = strstr((char const   *)(*(retval.style + j))->name, "Default");
#line 426
        if (tmp___4) {
#line 427
          retval.choice = j;
        }
#line 428
        j ++;
      }
#line 430
      closedir(my_dir);
#line 431
      return (retval);
    } else {
#line 433
      Panic("load_color_styles", "piece.c", (char *)"No piece styles [styles/*.Color] found.\n");
    }
  } else {
#line 436
    Panic("load_color_styles", "piece.c", (char *)"Cannot read directory [styles/]");
  }
#line 438
  return (retval);
}
}
#line 448 "piece.c"
play_piece generate_piece(piece_style *ps , color_style *cs , unsigned int seq ) 
{ unsigned int p ;
  unsigned int q ;
  unsigned int r ;
  unsigned int c ;
  play_piece retval ;
  Uint16 tmp ;
  Uint16 tmp___0 ;
  Uint16 tmp___1 ;
  Uint16 tmp___2 ;
  Uint16 tmp___3 ;
  Uint16 tmp___4 ;

  {
#line 454
  SeedRandom(seq);
#line 456
  tmp = FastRandom((unsigned short )ps->num_piece);
#line 456
  p = (unsigned int )tmp;
#line 457
  tmp___0 = FastRandom((unsigned short )(cs->num_color - 1));
#line 457
  q = (unsigned int )(2 + (int )tmp___0);
#line 458
  tmp___1 = FastRandom((unsigned short )(cs->num_color - 1));
#line 458
  r = (unsigned int )(2 + (int )tmp___1);
#line 459
  retval.base = ps->shape + p;
#line 461
  retval.special = -1;
#line 462
  if (Options.special_wanted) {
#line 462
    tmp___3 = FastRandom((unsigned short)10000);
#line 462
    if ((int )tmp___3 < 2000) {
#line 463
      tmp___2 = FastRandom((unsigned short)4);
#line 463
      switch ((int )tmp___2) {
      case 0: 
#line 464
      retval.special = 0;
#line 465
      break;
      case 1: 
#line 466
      retval.special = 1;
#line 467
      break;
      case 2: 
#line 468
      retval.special = 2;
#line 469
      break;
      case 3: 
#line 470
      retval.special = 3;
#line 471
      break;
      }
    }
  }
#line 474
  if ((int )retval.special != -1) {
#line 475
    c = 1U;
#line 475
    while (c <= (unsigned int )(ps->shape + p)->num_color) {
#line 476
      retval.colormap[c] = (unsigned char )retval.special;
#line 475
      c ++;
    }
  } else {
#line 478
    c = 1U;
#line 478
    while (c <= (unsigned int )(ps->shape + p)->num_color) {
#line 479
      tmp___4 = FastRandom((unsigned short)100);
#line 479
      if ((int )tmp___4 < 25) {
#line 480
        retval.colormap[c] = (unsigned char )q;
      } else {
#line 482
        retval.colormap[c] = (unsigned char )r;
      }
#line 483
      if (! ((int )retval.colormap[c] > 1)) {
#line 483
        Panic("generate_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
              "retval.colormap[c] > 1", 483);
      }
#line 478
      c ++;
    }
  }
#line 485
  return (retval);
}
}
#line 497 "piece.c"
void draw_play_piece(SDL_Surface *screen___0 , color_style *cs , play_piece *o_pp ,
                     int o_x , int o_y , int o_rot , play_piece *pp , int x , int y ,
                     int rot ) 
{ SDL_Rect dstrect ;
  int i ;
  int j ;
  int w___1 ;
  int h___1 ;
  int what ;
  SDL_Rect *my_b ;
  SDL_Rect *my_d ;
  int __attribute__((__visibility__("default")))  tmp ;
  int this_precolor ;
  int this_color ;
  SDL_Rect *my_b___0 ;
  SDL_Rect *my_d___0 ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int that_precolor ;
  int tmp___1 ;
  SDL_Rect *my_b___1 ;
  SDL_Rect *my_d___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  SDL_Rect *my_b___2 ;
  SDL_Rect *my_d___2 ;
  int __attribute__((__visibility__("default")))  tmp___3 ;
  SDL_Rect *my_b___3 ;
  SDL_Rect *my_d___3 ;
  int __attribute__((__visibility__("default")))  tmp___4 ;
  SDL_Rect *my_b___4 ;
  SDL_Rect *my_d___4 ;
  int __attribute__((__visibility__("default")))  tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  SDL_Rect *my_c ;

  {
#line 506
  if ((int )pp->special != -1) {
#line 507
    cs = & special_style;
  }
#line 509
  w___1 = cs->w;
#line 510
  h___1 = cs->h;
#line 512
  j = 0;
#line 512
  while (j < (o_pp->base)->dim) {
#line 513
    i = 0;
#line 513
    while (i < (o_pp->base)->dim) {
#line 516
      what = (int )*((o_pp->base)->bitmap[o_rot] + ((o_pp->base)->dim * j + i));
#line 516
      if (what) {
#line 517
        dstrect.x = (short )(o_x + i * w___1);
#line 518
        dstrect.y = (short )(o_y + j * h___1);
#line 519
        dstrect.w = (unsigned short )w___1;
#line 520
        dstrect.h = (unsigned short )h___1;
#line 521
        my_b = & dstrect;
#line 521
        my_d = & dstrect;
#line 521
        if (my_b) {
#line 521
          if ((int )my_b->x < 0) {
#line 521
            my_b->x = (short)0;
          }
#line 521
          if ((int )my_b->y < 0) {
#line 521
            my_b->y = (short)0;
          }
#line 521
          if ((int )my_b->x + (int )my_b->w > 640) {
#line 521
            my_b->w = (unsigned short )(640 - (int )my_b->x);
          }
#line 521
          if ((int )my_b->y + (int )my_b->h > 480) {
#line 521
            my_b->h = (unsigned short )(480 - (int )my_b->y);
          }
        }
#line 521
        if (my_d) {
#line 521
          if ((int )my_d->x < 0) {
#line 521
            my_d->x = (short)0;
          }
#line 521
          if ((int )my_d->y < 0) {
#line 521
            my_d->y = (short)0;
          }
#line 521
          if ((int )my_d->x + (int )my_d->w > 640) {
#line 521
            my_d->w = (unsigned short )(640 - (int )my_d->x);
          }
#line 521
          if ((int )my_d->y + (int )my_d->h > 480) {
#line 521
            my_d->h = (unsigned short )(480 - (int )my_d->y);
          }
        }
#line 521
        tmp = SDL_UpperBlit(widget_layer, my_b, screen___0, my_d);
#line 521
        if (! (tmp == (int __attribute__((__visibility__("default")))  )0)) {
#line 521
          Panic("draw_play_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
                "SDL_UpperBlit(widget_layer,my_b,screen,my_d) == 0", 521);
        }
      }
#line 513
      i ++;
    }
#line 512
    j ++;
  }
#line 524
  j = 0;
#line 524
  while (j < (pp->base)->dim) {
#line 525
    i = 0;
#line 525
    while (i < (pp->base)->dim) {
#line 528
      this_precolor = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + i));
#line 528
      if (this_precolor) {
#line 529
        this_color = (int )pp->colormap[this_precolor];
#line 530
        dstrect.x = (short )(x + i * w___1);
#line 531
        dstrect.y = (short )(y + j * h___1);
#line 532
        dstrect.w = (unsigned short )w___1;
#line 533
        dstrect.h = (unsigned short )h___1;
#line 534
        my_b___0 = (SDL_Rect *)((void *)0);
#line 534
        my_d___0 = & dstrect;
#line 534
        if (my_b___0) {
#line 534
          if ((int )my_b___0->x < 0) {
#line 534
            my_b___0->x = (short)0;
          }
#line 534
          if ((int )my_b___0->y < 0) {
#line 534
            my_b___0->y = (short)0;
          }
#line 534
          if ((int )my_b___0->x + (int )my_b___0->w > 640) {
#line 534
            my_b___0->w = (unsigned short )(640 - (int )my_b___0->x);
          }
#line 534
          if ((int )my_b___0->y + (int )my_b___0->h > 480) {
#line 534
            my_b___0->h = (unsigned short )(480 - (int )my_b___0->y);
          }
        }
#line 534
        if (my_d___0) {
#line 534
          if ((int )my_d___0->x < 0) {
#line 534
            my_d___0->x = (short)0;
          }
#line 534
          if ((int )my_d___0->y < 0) {
#line 534
            my_d___0->y = (short)0;
          }
#line 534
          if ((int )my_d___0->x + (int )my_d___0->w > 640) {
#line 534
            my_d___0->w = (unsigned short )(640 - (int )my_d___0->x);
          }
#line 534
          if ((int )my_d___0->y + (int )my_d___0->h > 480) {
#line 534
            my_d___0->h = (unsigned short )(480 - (int )my_d___0->y);
          }
        }
#line 534
        tmp___0 = SDL_UpperBlit(*(cs->color + this_color), my_b___0, screen___0, my_d___0);
#line 534
        if (! (tmp___0 == (int __attribute__((__visibility__("default")))  )0)) {
#line 534
          Panic("draw_play_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
                "SDL_UpperBlit(cs->color[this_color],my_b,screen,my_d) == 0", 534);
        }
#line 535
        if ((int )pp->special == -1) {
#line 537
          if (j == 0) {
#line 537
            tmp___1 = 0;
          } else {
#line 537
            tmp___1 = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * (j - 1) + i));
          }
#line 537
          that_precolor = tmp___1;
#line 541
          if (that_precolor == 0) {
            goto _L;
          } else {
#line 541
            if ((int )pp->colormap[that_precolor] != this_color) {
              _L: /* CIL Label */ 
#line 543
              dstrect.x = (short )(x + i * w___1);
#line 544
              dstrect.y = (short )(y + j * h___1);
#line 545
              dstrect.h = (unsigned short )(edge[0])->h;
#line 546
              dstrect.w = (unsigned short )(edge[0])->w;
#line 547
              my_b___1 = (SDL_Rect *)((void *)0);
#line 547
              my_d___1 = & dstrect;
#line 547
              if (my_b___1) {
#line 547
                if ((int )my_b___1->x < 0) {
#line 547
                  my_b___1->x = (short)0;
                }
#line 547
                if ((int )my_b___1->y < 0) {
#line 547
                  my_b___1->y = (short)0;
                }
#line 547
                if ((int )my_b___1->x + (int )my_b___1->w > 640) {
#line 547
                  my_b___1->w = (unsigned short )(640 - (int )my_b___1->x);
                }
#line 547
                if ((int )my_b___1->y + (int )my_b___1->h > 480) {
#line 547
                  my_b___1->h = (unsigned short )(480 - (int )my_b___1->y);
                }
              }
#line 547
              if (my_d___1) {
#line 547
                if ((int )my_d___1->x < 0) {
#line 547
                  my_d___1->x = (short)0;
                }
#line 547
                if ((int )my_d___1->y < 0) {
#line 547
                  my_d___1->y = (short)0;
                }
#line 547
                if ((int )my_d___1->x + (int )my_d___1->w > 640) {
#line 547
                  my_d___1->w = (unsigned short )(640 - (int )my_d___1->x);
                }
#line 547
                if ((int )my_d___1->y + (int )my_d___1->h > 480) {
#line 547
                  my_d___1->h = (unsigned short )(480 - (int )my_d___1->y);
                }
              }
#line 547
              tmp___2 = SDL_UpperBlit(edge[0], my_b___1, screen___0, my_d___1);
#line 547
              if (! (tmp___2 == (int __attribute__((__visibility__("default")))  )0)) {
#line 547
                Panic("draw_play_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
                      "SDL_UpperBlit(edge[0],my_b,screen,my_d) == 0", 548);
              }
            }
          }
#line 552
          if (i == 0) {
#line 552
            that_precolor = 0;
          } else {
#line 552
            that_precolor = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + (i - 1)));
          }
#line 554
          if (that_precolor == 0) {
            goto _L___0;
          } else {
#line 554
            if ((int )pp->colormap[that_precolor] != this_color) {
              _L___0: /* CIL Label */ 
#line 556
              dstrect.x = (short )(x + i * w___1);
#line 557
              dstrect.y = (short )(y + j * h___1);
#line 558
              dstrect.h = (unsigned short )(edge[1])->h;
#line 559
              dstrect.w = (unsigned short )(edge[1])->w;
#line 560
              my_b___2 = (SDL_Rect *)((void *)0);
#line 560
              my_d___2 = & dstrect;
#line 560
              if (my_b___2) {
#line 560
                if ((int )my_b___2->x < 0) {
#line 560
                  my_b___2->x = (short)0;
                }
#line 560
                if ((int )my_b___2->y < 0) {
#line 560
                  my_b___2->y = (short)0;
                }
#line 560
                if ((int )my_b___2->x + (int )my_b___2->w > 640) {
#line 560
                  my_b___2->w = (unsigned short )(640 - (int )my_b___2->x);
                }
#line 560
                if ((int )my_b___2->y + (int )my_b___2->h > 480) {
#line 560
                  my_b___2->h = (unsigned short )(480 - (int )my_b___2->y);
                }
              }
#line 560
              if (my_d___2) {
#line 560
                if ((int )my_d___2->x < 0) {
#line 560
                  my_d___2->x = (short)0;
                }
#line 560
                if ((int )my_d___2->y < 0) {
#line 560
                  my_d___2->y = (short)0;
                }
#line 560
                if ((int )my_d___2->x + (int )my_d___2->w > 640) {
#line 560
                  my_d___2->w = (unsigned short )(640 - (int )my_d___2->x);
                }
#line 560
                if ((int )my_d___2->y + (int )my_d___2->h > 480) {
#line 560
                  my_d___2->h = (unsigned short )(480 - (int )my_d___2->y);
                }
              }
#line 560
              tmp___3 = SDL_UpperBlit(edge[1], my_b___2, screen___0, my_d___2);
#line 560
              if (! (tmp___3 == (int __attribute__((__visibility__("default")))  )0)) {
#line 560
                Panic("draw_play_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
                      "SDL_UpperBlit(edge[1],my_b,screen,my_d) == 0", 561);
              }
            }
          }
#line 565
          if (j == (pp->base)->dim - 1) {
#line 565
            that_precolor = 0;
          } else {
#line 565
            that_precolor = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * (j + 1) + i));
          }
#line 567
          if (that_precolor == 0) {
            goto _L___1;
          } else {
#line 567
            if ((int )pp->colormap[that_precolor] != this_color) {
              _L___1: /* CIL Label */ 
#line 569
              dstrect.x = (short )(x + i * w___1);
#line 570
              dstrect.y = (short )((y + (j + 1) * h___1) - (edge[2])->h);
#line 571
              dstrect.h = (unsigned short )(edge[2])->h;
#line 572
              dstrect.w = (unsigned short )(edge[2])->w;
#line 573
              my_b___3 = (SDL_Rect *)((void *)0);
#line 573
              my_d___3 = & dstrect;
#line 573
              if (my_b___3) {
#line 573
                if ((int )my_b___3->x < 0) {
#line 573
                  my_b___3->x = (short)0;
                }
#line 573
                if ((int )my_b___3->y < 0) {
#line 573
                  my_b___3->y = (short)0;
                }
#line 573
                if ((int )my_b___3->x + (int )my_b___3->w > 640) {
#line 573
                  my_b___3->w = (unsigned short )(640 - (int )my_b___3->x);
                }
#line 573
                if ((int )my_b___3->y + (int )my_b___3->h > 480) {
#line 573
                  my_b___3->h = (unsigned short )(480 - (int )my_b___3->y);
                }
              }
#line 573
              if (my_d___3) {
#line 573
                if ((int )my_d___3->x < 0) {
#line 573
                  my_d___3->x = (short)0;
                }
#line 573
                if ((int )my_d___3->y < 0) {
#line 573
                  my_d___3->y = (short)0;
                }
#line 573
                if ((int )my_d___3->x + (int )my_d___3->w > 640) {
#line 573
                  my_d___3->w = (unsigned short )(640 - (int )my_d___3->x);
                }
#line 573
                if ((int )my_d___3->y + (int )my_d___3->h > 480) {
#line 573
                  my_d___3->h = (unsigned short )(480 - (int )my_d___3->y);
                }
              }
#line 573
              tmp___4 = SDL_UpperBlit(edge[2], my_b___3, screen___0, my_d___3);
#line 573
              if (! (tmp___4 == (int __attribute__((__visibility__("default")))  )0)) {
#line 573
                Panic("draw_play_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
                      "SDL_UpperBlit(edge[2],my_b,screen,my_d) == 0", 574);
              }
            }
          }
#line 578
          if (i == (pp->base)->dim - 1) {
#line 578
            that_precolor = 0;
          } else {
#line 578
            that_precolor = (int )*((pp->base)->bitmap[rot] + ((pp->base)->dim * j + (i + 1)));
          }
#line 580
          if (that_precolor == 0) {
            goto _L___2;
          } else {
#line 580
            if ((int )pp->colormap[that_precolor] != this_color) {
              _L___2: /* CIL Label */ 
#line 582
              dstrect.x = (short )((x + (i + 1) * w___1) - (edge[3])->w);
#line 583
              dstrect.y = (short )(y + j * h___1);
#line 584
              dstrect.h = (unsigned short )(edge[3])->h;
#line 585
              dstrect.w = (unsigned short )(edge[3])->w;
#line 586
              my_b___4 = (SDL_Rect *)((void *)0);
#line 586
              my_d___4 = & dstrect;
#line 586
              if (my_b___4) {
#line 586
                if ((int )my_b___4->x < 0) {
#line 586
                  my_b___4->x = (short)0;
                }
#line 586
                if ((int )my_b___4->y < 0) {
#line 586
                  my_b___4->y = (short)0;
                }
#line 586
                if ((int )my_b___4->x + (int )my_b___4->w > 640) {
#line 586
                  my_b___4->w = (unsigned short )(640 - (int )my_b___4->x);
                }
#line 586
                if ((int )my_b___4->y + (int )my_b___4->h > 480) {
#line 586
                  my_b___4->h = (unsigned short )(480 - (int )my_b___4->y);
                }
              }
#line 586
              if (my_d___4) {
#line 586
                if ((int )my_d___4->x < 0) {
#line 586
                  my_d___4->x = (short)0;
                }
#line 586
                if ((int )my_d___4->y < 0) {
#line 586
                  my_d___4->y = (short)0;
                }
#line 586
                if ((int )my_d___4->x + (int )my_d___4->w > 640) {
#line 586
                  my_d___4->w = (unsigned short )(640 - (int )my_d___4->x);
                }
#line 586
                if ((int )my_d___4->y + (int )my_d___4->h > 480) {
#line 586
                  my_d___4->h = (unsigned short )(480 - (int )my_d___4->y);
                }
              }
#line 586
              tmp___5 = SDL_UpperBlit(edge[3], my_b___4, screen___0, my_d___4);
#line 586
              if (! (tmp___5 == (int __attribute__((__visibility__("default")))  )0)) {
#line 586
                Panic("draw_play_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
                      "SDL_UpperBlit(edge[3],my_b,screen,my_d) == 0", 586);
              }
            }
          }
        }
      }
#line 525
      i ++;
    }
#line 524
    j ++;
  }
#line 592
  if (o_x < x) {
#line 592
    dstrect.x = (short )o_x;
  } else {
#line 592
    dstrect.x = (short )x;
  }
#line 593
  if ((int )dstrect.x > 0) {
#line 593
    dstrect.x = dstrect.x;
  } else {
#line 593
    dstrect.x = (short)0;
  }
#line 595
  if (o_x + (o_pp->base)->dim * cs->w > x + (pp->base)->dim * cs->w) {
#line 595
    tmp___6 = o_x + (o_pp->base)->dim * cs->w;
  } else {
#line 595
    tmp___6 = x + (pp->base)->dim * cs->w;
  }
#line 595
  dstrect.w = (unsigned short )(tmp___6 - (int )dstrect.x);
#line 597
  if ((int )dstrect.w < screen___0->w - (int )dstrect.x) {
#line 597
    dstrect.w = dstrect.w;
  } else {
#line 597
    dstrect.w = (unsigned short )(screen___0->w - (int )dstrect.x);
  }
#line 599
  if (o_y < y) {
#line 599
    dstrect.y = (short )o_y;
  } else {
#line 599
    dstrect.y = (short )y;
  }
#line 600
  if ((int )dstrect.y > 0) {
#line 600
    dstrect.y = dstrect.y;
  } else {
#line 600
    dstrect.y = (short)0;
  }
#line 601
  if (o_y + (o_pp->base)->dim * cs->h > y + (pp->base)->dim * cs->h) {
#line 601
    tmp___7 = o_y + (o_pp->base)->dim * cs->h;
  } else {
#line 601
    tmp___7 = y + (pp->base)->dim * cs->h;
  }
#line 601
  dstrect.h = (unsigned short )(tmp___7 - (int )dstrect.y);
#line 603
  if ((int )dstrect.h < screen___0->h - (int )dstrect.y) {
#line 603
    dstrect.h = dstrect.h;
  } else {
#line 603
    dstrect.h = (unsigned short )(screen___0->h - (int )dstrect.y);
  }
#line 605
  my_c = & dstrect;
#line 605
  if (! my_c) {
#line 605
    Panic("draw_play_piece", "piece.c", (char *)"Failed assertion \"%s\" on line %d",
          "my_c", 605);
  }
#line 605
  if (my_c) {
#line 605
    if ((int )my_c->x < 0) {
#line 605
      my_c->x = (short)0;
    }
#line 605
    if ((int )my_c->y < 0) {
#line 605
      my_c->y = (short)0;
    }
#line 605
    if ((int )my_c->x + (int )my_c->w > 640) {
#line 605
      my_c->w = (unsigned short )(640 - (int )my_c->x);
    }
#line 605
    if ((int )my_c->y + (int )my_c->h > 480) {
#line 605
      my_c->h = (unsigned short )(480 - (int )my_c->y);
    }
  }
#line 605
  SDL_UpdateRects(screen___0, 1, & dstrect);
#line 607
  return;
}
}
#line 1 "sound.o"
#pragma merger(0,"/tmp/cil-mDh9Oms1.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 335 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 152 "/usr/include/SDL/SDL_audio.h"
extern int __attribute__((__visibility__("default")))  SDL_OpenAudio(SDL_AudioSpec *desired ,
                                                                     SDL_AudioSpec *obtained ) ;
#line 171
extern void __attribute__((__visibility__("default")))  SDL_PauseAudio(int pause_on ) ;
#line 190
extern SDL_AudioSpec __attribute__((__visibility__("default")))  *SDL_LoadWAV_RW(SDL_RWops *src ,
                                                                                 int freesrc ,
                                                                                 SDL_AudioSpec *spec ,
                                                                                 Uint8 **audio_buf ,
                                                                                 Uint32 *audio_len ) ;
#line 230
extern void __attribute__((__visibility__("default")))  SDL_MixAudio(Uint8 *dst ,
                                                                     Uint8 const   *src ,
                                                                     Uint32 len ,
                                                                     int volume ) ;
#line 238
extern void __attribute__((__visibility__("default")))  SDL_LockAudio(void) ;
#line 239
extern void __attribute__((__visibility__("default")))  SDL_UnlockAudio(void) ;
#line 72 "/usr/include/SDL/SDL.h"
extern int __attribute__((__visibility__("default")))  SDL_InitSubSystem(Uint32 flags ) ;
#line 33 "sound.c"
samples_to_be_played current  ;
#line 35 "sound.c"
char *sound_name[7]  = {      (char *)"thud",      (char *)"clear1",      (char *)"clear4",      (char *)"levelup", 
        (char *)"leveldown",      (char *)"garbage1",      (char *)"clock"};
#line 42 "sound.c"
static void fill_audio(void *udata , Uint8 *stream , int len ) 
{ int i ;
  int diff ;
  int to_play ;

  {
#line 47
  i = 0;
#line 47
  while (i < 32) {
#line 48
    if (current.sample[i].in_use) {
#line 49
      if (current.sample[i].delay >= len) {
#line 50
        current.sample[i].delay -= len;
      } else {
#line 51
        if (current.sample[i].delay > 0) {
#line 51
          if (current.sample[i].delay < len) {
#line 54
            diff = len - current.sample[i].delay;
#line 55
            if ((Uint32 )diff + current.sample[i].pos >= current.sample[i].len) {
#line 56
              diff = (int )(current.sample[i].len - current.sample[i].pos);
#line 57
              current.sample[i].in_use = 0;
            }
#line 59
            current.sample[i].delay = 0;
#line 60
            SDL_MixAudio(stream + current.sample[i].delay, (Uint8 const   *)current.sample[i].audio_data,
                         (unsigned int )diff, 128);
#line 62
            current.sample[i].audio_data += diff;
#line 63
            current.sample[i].pos += (Uint32 )diff;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 66
          to_play = len;
#line 67
          if (! (current.sample[i].delay == 0)) {
#line 67
            Panic("fill_audio", "sound.c", (char *)"Failed assertion \"%s\" on line %d",
                  "current.sample[i].delay == 0", 67);
          }
#line 68
          if ((Uint32 )to_play + current.sample[i].pos >= current.sample[i].len) {
#line 69
            to_play = (int )(current.sample[i].len - current.sample[i].pos);
#line 70
            current.sample[i].in_use = 0;
          }
#line 72
          SDL_MixAudio(stream, (Uint8 const   *)current.sample[i].audio_data, (unsigned int )to_play,
                       128);
#line 74
          current.sample[i].audio_data += to_play;
#line 75
          current.sample[i].pos += (Uint32 )to_play;
        }
      }
    }
#line 47
    i ++;
  }
#line 78
  return;
}
}
#line 86 "sound.c"
void play_sound_unless_already_playing(sound_style *ss , int which , int delay ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 91
  if (ss->WAV[which].audio_len == 0U) {
#line 92
    if (0) {
#line 92
      __s1_len = strlen((char const   *)ss->name);
#line 92
      __s2_len = strlen("No Sound");
#line 92
      if (! ((unsigned int )((void const   *)(ss->name + 1)) - (unsigned int )((void const   *)ss->name) == 1U)) {
        goto _L___0;
      } else {
#line 92
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 92
          if (! ((unsigned int )((void const   *)("No Sound" + 1)) - (unsigned int )((void const   *)"No Sound") == 1U)) {
#line 92
            tmp___8 = 1;
          } else {
#line 92
            if (__s2_len >= 4U) {
#line 92
              tmp___8 = 1;
            } else {
#line 92
              tmp___8 = 0;
            }
          }
        } else {
#line 92
          tmp___8 = 0;
        }
      }
#line 92
      if (tmp___8) {
#line 92
        tmp___4 = __builtin_strcmp((char const   *)ss->name, "No Sound");
      } else {
#line 92
        tmp___7 = __builtin_strcmp((char const   *)ss->name, "No Sound");
#line 92
        tmp___4 = tmp___7;
      }
    } else {
#line 92
      tmp___7 = __builtin_strcmp((char const   *)ss->name, "No Sound");
#line 92
      tmp___4 = tmp___7;
    }
#line 92
    if (tmp___4) {
#line 93
      printf((char const   * __restrict  )"%-14.14s| ", "play_sound_unless_already_playing");
#line 93
      printf((char const   * __restrict  )"No [%s] sound in Sound Style [%s]\n", sound_name[which],
             ss->name);
#line 93
      fflush(stdout);
    }
#line 95
    return;
  }
#line 98
  i = 0;
#line 98
  while (i < 32) {
#line 100
    if (current.sample[i].in_use != 0) {
#line 100
      if (0) {
#line 100
        __s1_len___0 = strlen((char const   *)current.sample[i].filename);
#line 100
        __s2_len___0 = strlen((char const   *)ss->WAV[which].filename);
#line 100
        if (! ((unsigned int )((void const   *)(current.sample[i].filename + 1)) - (unsigned int )((void const   *)current.sample[i].filename) == 1U)) {
          goto _L___2;
        } else {
#line 100
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
#line 100
            if (! ((unsigned int )((void const   *)(ss->WAV[which].filename + 1)) - (unsigned int )((void const   *)ss->WAV[which].filename) == 1U)) {
#line 100
              tmp___18 = 1;
            } else {
#line 100
              if (__s2_len___0 >= 4U) {
#line 100
                tmp___18 = 1;
              } else {
#line 100
                tmp___18 = 0;
              }
            }
          } else {
#line 100
            tmp___18 = 0;
          }
        }
#line 100
        if (tmp___18) {
#line 100
          tmp___14 = __builtin_strcmp((char const   *)current.sample[i].filename,
                                      (char const   *)ss->WAV[which].filename);
        } else {
#line 100
          tmp___17 = __builtin_strcmp((char const   *)current.sample[i].filename,
                                      (char const   *)ss->WAV[which].filename);
#line 100
          tmp___14 = tmp___17;
        }
      } else {
#line 100
        tmp___17 = __builtin_strcmp((char const   *)current.sample[i].filename, (char const   *)ss->WAV[which].filename);
#line 100
        tmp___14 = tmp___17;
      }
#line 100
      if (! tmp___14) {
#line 102
        return;
      }
    }
#line 98
    i ++;
  }
#line 105
  i = 0;
#line 105
  while (i < 32) {
#line 106
    if (current.sample[i].in_use == 0) {
#line 108
      SDL_LockAudio();
#line 109
      current.sample[i].in_use = 1;
#line 110
      current.sample[i].delay = delay;
#line 111
      current.sample[i].len = ss->WAV[which].audio_len;
#line 112
      current.sample[i].pos = 0U;
#line 113
      current.sample[i].audio_data = ss->WAV[which].audio_buf;
#line 114
      current.sample[i].filename = ss->WAV[which].filename;
#line 115
      SDL_UnlockAudio();
#line 119
      return;
    }
#line 105
    i ++;
  }
#line 122
  printf((char const   * __restrict  )"%-14.14s| ", "play_sound_unless_already_playing");
#line 122
  printf((char const   * __restrict  )"No room in the mixer for sound %d\n", which);
#line 122
  fflush(stdout);
#line 123
  return;
}
}
#line 130 "sound.c"
void stop_playing_sound(sound_style *ss , int which ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 135
  i = 0;
#line 135
  while (i < 32) {
#line 137
    if (current.sample[i].in_use != 0) {
#line 137
      if (0) {
#line 137
        __s1_len = strlen((char const   *)current.sample[i].filename);
#line 137
        __s2_len = strlen((char const   *)ss->WAV[which].filename);
#line 137
        if (! ((unsigned int )((void const   *)(current.sample[i].filename + 1)) - (unsigned int )((void const   *)current.sample[i].filename) == 1U)) {
          goto _L___0;
        } else {
#line 137
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 137
            if (! ((unsigned int )((void const   *)(ss->WAV[which].filename + 1)) - (unsigned int )((void const   *)ss->WAV[which].filename) == 1U)) {
#line 137
              tmp___8 = 1;
            } else {
#line 137
              if (__s2_len >= 4U) {
#line 137
                tmp___8 = 1;
              } else {
#line 137
                tmp___8 = 0;
              }
            }
          } else {
#line 137
            tmp___8 = 0;
          }
        }
#line 137
        if (tmp___8) {
#line 137
          tmp___4 = __builtin_strcmp((char const   *)current.sample[i].filename, (char const   *)ss->WAV[which].filename);
        } else {
#line 137
          tmp___7 = __builtin_strcmp((char const   *)current.sample[i].filename, (char const   *)ss->WAV[which].filename);
#line 137
          tmp___4 = tmp___7;
        }
      } else {
#line 137
        tmp___7 = __builtin_strcmp((char const   *)current.sample[i].filename, (char const   *)ss->WAV[which].filename);
#line 137
        tmp___4 = tmp___7;
      }
#line 137
      if (! tmp___4) {
#line 139
        current.sample[i].in_use = 0;
      }
    }
#line 135
    i ++;
  }
#line 141
  return;
}
}
#line 150 "sound.c"
void play_sound(sound_style *ss , int which , int delay ) 
{ int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 155
  if (ss->WAV[which].audio_len == 0U) {
#line 156
    if (0) {
#line 156
      __s1_len = strlen((char const   *)ss->name);
#line 156
      __s2_len = strlen("No Sound");
#line 156
      if (! ((unsigned int )((void const   *)(ss->name + 1)) - (unsigned int )((void const   *)ss->name) == 1U)) {
        goto _L___0;
      } else {
#line 156
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 156
          if (! ((unsigned int )((void const   *)("No Sound" + 1)) - (unsigned int )((void const   *)"No Sound") == 1U)) {
#line 156
            tmp___8 = 1;
          } else {
#line 156
            if (__s2_len >= 4U) {
#line 156
              tmp___8 = 1;
            } else {
#line 156
              tmp___8 = 0;
            }
          }
        } else {
#line 156
          tmp___8 = 0;
        }
      }
#line 156
      if (tmp___8) {
#line 156
        tmp___4 = __builtin_strcmp((char const   *)ss->name, "No Sound");
      } else {
#line 156
        tmp___7 = __builtin_strcmp((char const   *)ss->name, "No Sound");
#line 156
        tmp___4 = tmp___7;
      }
    } else {
#line 156
      tmp___7 = __builtin_strcmp((char const   *)ss->name, "No Sound");
#line 156
      tmp___4 = tmp___7;
    }
#line 156
    if (tmp___4) {
#line 157
      printf((char const   * __restrict  )"%-14.14s| ", "play_sound");
#line 157
      printf((char const   * __restrict  )"No [%s] sound in Sound Style [%s]\n", sound_name[which],
             ss->name);
#line 157
      fflush(stdout);
    }
#line 159
    return;
  }
#line 163
  i = 0;
#line 163
  while (i < 32) {
#line 164
    if (current.sample[i].in_use == 0) {
#line 166
      SDL_LockAudio();
#line 167
      current.sample[i].in_use = 1;
#line 168
      current.sample[i].delay = delay;
#line 169
      current.sample[i].len = ss->WAV[which].audio_len;
#line 170
      current.sample[i].pos = 0U;
#line 171
      current.sample[i].audio_data = ss->WAV[which].audio_buf;
#line 172
      current.sample[i].filename = ss->WAV[which].filename;
#line 173
      SDL_UnlockAudio();
#line 177
      return;
    }
#line 163
    i ++;
  }
#line 180
  printf((char const   * __restrict  )"%-14.14s| ", "play_sound");
#line 180
  printf((char const   * __restrict  )"No room in the mixer for sound %d\n", which);
#line 180
  fflush(stdout);
#line 181
  return;
}
}
#line 188 "sound.c"
void stop_all_playing(void) 
{ int i ;

  {
#line 192
  i = 0;
#line 192
  while (i < 32) {
#line 193
    current.sample[i].in_use = 0;
#line 192
    i ++;
  }
#line 194
  return;
}
}
#line 201 "sound.c"
void play_all_sounds(sound_style *ss ) 
{ int i ;
  int delay ;

  {
#line 205
  delay = 0;
#line 207
  i = 0;
#line 207
  while (i < 7) {
#line 208
    if (i == 6) {
      goto __Cont;
    }
#line 209
    play_sound(ss, i, delay);
#line 210
    delay = (int )((Uint32 )delay + (ss->WAV[i].audio_len + 6144U));
    __Cont: /* CIL Label */ 
#line 207
    i ++;
  }
#line 212
  return;
}
}
#line 218 "sound.c"
static sound_style *load_sound_style(char const   *filename ) 
{ sound_style *retval ;
  char buf[2048] ;
  FILE *fin ;
  FILE *tmp ;
  int ok ;
  int count ;
  void *tmp___0 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___14 ;
  int i ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___18 ;
  char *tmp___20 ;
  char *p ;
  char *tmp___22 ;
  char __attribute__((__visibility__("default")))  *tmp___23 ;
  SDL_RWops __attribute__((__visibility__("default")))  *tmp___24 ;
  SDL_AudioSpec __attribute__((__visibility__("default")))  *tmp___25 ;
  char *tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 224
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rt");
#line 224
  fin = tmp;
#line 226
  count = 0;
#line 228
  if (! fin) {
#line 229
    printf((char const   * __restrict  )"%-14.14s| ", "load_sound_style");
#line 229
    printf((char const   * __restrict  )"fopen(%s)\n", filename);
#line 229
    fflush(stdout);
#line 230
    return ((sound_style *)((void *)0));
  }
#line 232
  tmp___0 = calloc(sizeof(sound_style ), 1U);
#line 232
  retval = (sound_style *)tmp___0;
#line 232
  if (! retval) {
#line 232
    Panic("load_sound_style", "sound.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval",
          sizeof(sound_style ));
  }
#line 235
  fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 236
  tmp___4 = __builtin_strchr(buf, '\n');
#line 236
  if (tmp___4) {
#line 237
    tmp___2 = __builtin_strchr(buf, '\n');
#line 237
    *tmp___2 = (char)0;
  }
#line 238
  tmp___14 = __strdup((char const   *)(buf));
#line 238
  retval->name = tmp___14;
#line 240
  while (1) {
#line 240
    tmp___38 = feof(fin);
#line 240
    if (tmp___38) {
#line 240
      break;
    }
#line 242
    while (1) {
#line 243
      fgets((char * __restrict  )(buf), (int )sizeof(buf), (FILE * __restrict  )fin);
#line 242
      tmp___15 = feof(fin);
#line 242
      if (tmp___15) {
#line 242
        break;
      } else {
#line 242
        if (! ((int )buf[0] == 10)) {
#line 242
          if (! ((int )buf[0] == 35)) {
#line 242
            break;
          }
        }
      }
    }
#line 246
    tmp___16 = feof(fin);
#line 246
    if (tmp___16) {
#line 246
      break;
    }
#line 247
    tmp___20 = __builtin_strchr(buf, '\n');
#line 247
    if (tmp___20) {
#line 248
      tmp___18 = __builtin_strchr(buf, '\n');
#line 248
      *tmp___18 = (char)0;
    }
#line 250
    ok = 0;
#line 252
    i = 0;
#line 252
    while (i < 7) {
#line 253
      tmp___36 = strlen((char const   *)sound_name[i]);
#line 253
      tmp___37 = strncasecmp((char const   *)(buf), (char const   *)sound_name[i],
                             tmp___36);
#line 253
      if (! tmp___37) {
#line 254
        tmp___22 = __builtin_strchr(buf, ' ');
#line 254
        p = tmp___22;
#line 255
        if (! p) {
#line 256
          printf((char const   * __restrict  )"%-14.14s| ", "load_sound_style");
#line 256
          printf((char const   * __restrict  )"malformed input line [%s] in [%s]\n",
                 buf, filename);
#line 256
          fflush(stdout);
#line 258
          return ((sound_style *)((void *)0));
        }
#line 260
        p ++;
#line 261
        tmp___24 = SDL_RWFromFile((char const   *)p, "rb");
#line 261
        tmp___25 = SDL_LoadWAV_RW((SDL_RWops *)tmp___24, 1, & retval->WAV[i].spec,
                                  & retval->WAV[i].audio_buf, & retval->WAV[i].audio_len);
#line 261
        if (! tmp___25) {
#line 264
          tmp___23 = SDL_GetError();
#line 264
          Panic("load_sound_style", "sound.c", (char *)"Couldn\'t open %s [%s] in [%s]: %s",
                sound_name[i], p, filename, tmp___23);
        }
#line 267
        tmp___35 = __strdup(filename);
#line 267
        retval->WAV[i].filename = tmp___35;
#line 268
        count ++;
#line 269
        ok = 1;
      }
#line 252
      i ++;
    }
#line 271
    if (! ok) {
#line 272
      printf((char const   * __restrict  )"%-14.14s| ", "load_sound_style");
#line 272
      printf((char const   * __restrict  )"unknown sound name [%s] in [%s]\nvalid names:",
             buf, filename);
#line 272
      fflush(stdout);
#line 274
      i = 0;
#line 274
      while (i < 7) {
#line 275
        printf((char const   * __restrict  )" %s", sound_name[i]);
#line 274
        i ++;
      }
#line 276
      printf((char const   * __restrict  )"\n");
#line 277
      return ((sound_style *)((void *)0));
    }
  }
#line 281
  printf((char const   * __restrict  )"%-14.14s| ", "load_sound_style");
#line 281
  printf((char const   * __restrict  )"Sound Style [%s] loaded (%d/%d sounds).\n",
         retval->name, count, 7);
#line 281
  fflush(stdout);
#line 284
  return (retval);
}
}
#line 292 "sound.c"
static int sound_Select(struct dirent  const  *d ) 
{ char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
#line 295
  tmp = strstr((char const   *)(d->d_name), ".Sound");
#line 295
  if (tmp) {
#line 295
    tmp___0 = strlen((char const   *)(d->d_name));
#line 295
    tmp___1 = strstr((char const   *)(d->d_name), ".Sound");
#line 295
    if ((int )tmp___0 == (tmp___1 - (char *)(d->d_name)) + 6) {
#line 298
      return (1);
    } else {
#line 300
      return (0);
    }
  } else {
#line 300
    return (0);
  }
}
}
#line 308 "sound.c"
sound_styles load_sound_styles(int sound_wanted ) 
{ sound_styles retval ;
  SDL_AudioSpec wanted ;
  DIR *my_dir ;
  int i ;
  char __attribute__((__visibility__("default")))  *tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  char __attribute__((__visibility__("default")))  *tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;
  struct dirent *this_file ;
  struct dirent *tmp___3 ;
  int tmp___4 ;
  int j ;
  void *tmp___5 ;
  char filespec[1024] ;
  struct dirent *this_file___0 ;
  struct dirent *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
#line 314
  i = 0;
#line 316
  memset((void *)(& retval), 0, sizeof(retval));
#line 319
  if (! sound_wanted) {
    goto nosound;
  }
#line 321
  tmp___0 = SDL_InitSubSystem(16U);
#line 321
  if (tmp___0) {
#line 322
    printf((char const   * __restrict  )"%-14.14s| ", "load_sound_styles");
#line 322
    tmp = SDL_GetError();
#line 322
    printf((char const   * __restrict  )"Couldn\'t initialize audio subsystem: %s\n",
           tmp);
#line 322
    fflush(stdout);
    goto nosound;
  }
#line 326
  memset((void *)(& current), 0, sizeof(current));
#line 328
  wanted.freq = 11025;
#line 329
  wanted.format = (unsigned short)8;
#line 330
  wanted.channels = (unsigned char)1;
#line 331
  wanted.samples = (unsigned short)512;
#line 332
  wanted.callback = & fill_audio;
#line 333
  wanted.userdata = (void *)0;
#line 335
  tmp___2 = SDL_OpenAudio(& wanted, (SDL_AudioSpec *)((void *)0));
#line 335
  if (tmp___2 < (int __attribute__((__visibility__("default")))  )0) {
#line 336
    printf((char const   * __restrict  )"%-14.14s| ", "load_sound_styles");
#line 336
    tmp___1 = SDL_GetError();
#line 336
    printf((char const   * __restrict  )"Couldn\'t open audio: %s\n", tmp___1);
#line 336
    fflush(stdout);
    goto nosound;
  }
#line 340
  my_dir = opendir("sounds");
#line 341
  if (my_dir) {
#line 342
    while (1) {
#line 343
      tmp___3 = readdir(my_dir);
#line 343
      this_file = tmp___3;
#line 344
      if (! this_file) {
#line 344
        break;
      }
#line 345
      tmp___4 = sound_Select((struct dirent  const  *)this_file);
#line 345
      if (tmp___4) {
#line 346
        i ++;
      }
    }
#line 348
    closedir(my_dir);
  } else {
#line 350
    printf((char const   * __restrict  )"%-14.14s| ", "load_sound_styles");
#line 350
    printf((char const   * __restrict  )"Cannot read directory [sounds/]: atris-sounds not found!\n");
#line 350
    fflush(stdout);
    goto nosound;
  }
#line 353
  my_dir = opendir("sounds");
#line 354
  if (my_dir) {
#line 355
    if (i >= 0) {
#line 357
      tmp___5 = calloc(sizeof(*(retval.style)) * (unsigned int )i + 1U, 1U);
#line 357
      retval.style = (sound_style **)tmp___5;
#line 357
      if (! retval.style) {
#line 357
        Panic("load_sound_styles", "sound.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.style",
              sizeof(*(retval.style)) * (unsigned int )i + 1U);
      }
#line 358
      retval.num_style = i + 1;
#line 359
      j = 0;
#line 360
      while (j < i) {
#line 362
        tmp___6 = readdir(my_dir);
#line 362
        this_file___0 = tmp___6;
#line 363
        tmp___7 = sound_Select((struct dirent  const  *)this_file___0);
#line 363
        if (! tmp___7) {
#line 363
          continue;
        }
#line 364
        sprintf((char * __restrict  )(filespec), (char const   * __restrict  )"sounds/%s",
                this_file___0->d_name);
#line 365
        *(retval.style + j) = load_sound_style((char const   *)(filespec));
#line 366
        tmp___8 = strstr((char const   *)(*(retval.style + j))->name, "Default");
#line 366
        if (tmp___8) {
#line 367
          retval.choice = j;
        }
#line 368
        j ++;
      }
#line 370
      closedir(my_dir);
#line 371
      tmp___9 = calloc(sizeof(sound_style ), 1U);
#line 371
      *(retval.style + i) = (sound_style *)tmp___9;
#line 371
      if (! *(retval.style + i)) {
#line 371
        Panic("load_sound_styles", "sound.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.style[i]",
              sizeof(sound_style ));
      }
#line 372
      (*(retval.style + i))->name = (char *)"No Sound";
#line 373
      SDL_PauseAudio(0);
#line 374
      return (retval);
    } else {
#line 376
      Panic("load_sound_styles", "sound.c", (char *)"No sound styles [sounds/*.Sound] found.\n");
    }
  } else {
#line 379
    Panic("load_sound_styles", "sound.c", (char *)"Cannot read directory [sounds/]");
  }
#line 381
  printf((char const   * __restrict  )"%-14.14s| ", "load_sound_styles");
#line 381
  printf((char const   * __restrict  )"No sound styles [sounds/*.Sound] found.\n");
#line 381
  fflush(stdout);
  nosound: 
#line 385
  retval.num_style = 1;
#line 386
  tmp___10 = malloc(sizeof(*(retval.style)));
#line 386
  retval.style = (sound_style **)tmp___10;
#line 386
  if (! retval.style) {
#line 386
    Panic("load_sound_styles", "sound.c", (char *)"Out of Memory:\n\tcannot allocate %d bytes for retval.style",
          sizeof(*(retval.style)));
  }
#line 387
  tmp___11 = calloc(sizeof(sound_style ), 1U);
#line 387
  *(retval.style + 0) = (sound_style *)tmp___11;
#line 387
  if (! *(retval.style + 0)) {
#line 387
    Panic("load_sound_styles", "sound.c", (char *)"Out of Memory:\n\tcannot callocate %d bytes for retval.style[0]",
          sizeof(sound_style ));
  }
#line 388
  (*(retval.style + 0))->name = (char *)"No Sound";
#line 389
  return (retval);
}
}
#line 1 "xflame.o"
#pragma merger(0,"/tmp/cil-2BmQGsze.i","-g,-O2,-Wall,-Wimplicit,-Wsign-compare,-Wpointer-arith")
#line 371 "/usr/include/SDL/SDL_video.h"
extern int __attribute__((__visibility__("default")))  SDL_Flip(SDL_Surface *screen ) ;
#line 533
extern int __attribute__((__visibility__("default")))  SDL_LockSurface(SDL_Surface *surface ) ;
#line 534
extern void __attribute__((__visibility__("default")))  SDL_UnlockSurface(SDL_Surface *surface ) ;
#line 66 "xflame.c"
int powerof(unsigned int n ) 
{ int p ;

  {
#line 71
  if (n <= 1U) {
#line 71
    p = 0;
  } else {
#line 72
    if (n <= 2U) {
#line 72
      p = 1;
    } else {
#line 73
      if (n <= 4U) {
#line 73
        p = 2;
      } else {
#line 74
        if (n <= 8U) {
#line 74
          p = 3;
        } else {
#line 75
          if (n <= 16U) {
#line 75
            p = 4;
          } else {
#line 76
            if (n <= 32U) {
#line 76
              p = 5;
            } else {
#line 77
              if (n <= 64U) {
#line 77
                p = 6;
              } else {
#line 78
                if (n <= 128U) {
#line 78
                  p = 7;
                } else {
#line 79
                  if (n <= 256U) {
#line 79
                    p = 8;
                  } else {
#line 80
                    if (n <= 512U) {
#line 80
                      p = 9;
                    } else {
#line 81
                      if (n <= 1024U) {
#line 81
                        p = 10;
                      } else {
#line 82
                        if (n <= 2048U) {
#line 82
                          p = 11;
                        } else {
#line 83
                          if (n <= 4096U) {
#line 83
                            p = 12;
                          } else {
#line 84
                            if (n <= 8192U) {
#line 84
                              p = 13;
                            } else {
#line 85
                              if (n <= 16384U) {
#line 85
                                p = 14;
                              } else {
#line 86
                                if (n <= 32768U) {
#line 86
                                  p = 15;
                                } else {
#line 87
                                  if (n <= 65536U) {
#line 87
                                    p = 16;
                                  } else {
#line 88
                                    if (n <= 131072U) {
#line 88
                                      p = 17;
                                    } else {
#line 89
                                      if (n <= 262144U) {
#line 89
                                        p = 18;
                                      } else {
#line 90
                                        if (n <= 524288U) {
#line 90
                                          p = 19;
                                        } else {
#line 91
                                          if (n <= 1048576U) {
#line 91
                                            p = 20;
                                          } else {
#line 92
                                            if (n <= 2097152U) {
#line 92
                                              p = 21;
                                            } else {
#line 93
                                              if (n <= 4194304U) {
#line 93
                                                p = 22;
                                              } else {
#line 94
                                                if (n <= 8388608U) {
#line 94
                                                  p = 23;
                                                } else {
#line 95
                                                  if (n <= 16777216U) {
#line 95
                                                    p = 24;
                                                  } else {
#line 96
                                                    if (n <= 33554432U) {
#line 96
                                                      p = 25;
                                                    } else {
#line 97
                                                      if (n <= 67108864U) {
#line 97
                                                        p = 26;
                                                      } else {
#line 98
                                                        if (n <= 134217728U) {
#line 98
                                                          p = 27;
                                                        } else {
#line 99
                                                          if (n <= 268435456U) {
#line 99
                                                            p = 28;
                                                          } else {
#line 100
                                                            if (n <= 536870912U) {
#line 100
                                                              p = 29;
                                                            } else {
#line 101
                                                              if (n <= 1073741824U) {
#line 101
                                                                p = 30;
                                                              } else {
#line 102
                                                                if (n <= 2147483648U) {
#line 102
                                                                  p = 31;
                                                                } else {
#line 103
                                                                  p = 32;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 104
  return (p);
}
}
#line 107 "xflame.c"
static void SetFlamePalette(struct globaldata *gb , int f___0 , int *ctab___0 ) 
{ int r ;
  int g___0 ;
  int b ;
  int i ;
  SDL_Color cmap[300] ;
  Uint32 __attribute__((__visibility__("default")))  tmp ;

  {
#line 115
  b = 0;
#line 115
  g___0 = b;
#line 115
  r = g___0;
#line 116
  i = 0;
#line 116
  while (1) {
#line 116
    if (! (r != 255)) {
#line 116
      if (! (g___0 != 255)) {
#line 116
        if (! (b != 255)) {
#line 116
          break;
        }
      }
    }
#line 118
    r = i * 3;
#line 119
    g___0 = (i - 80) * 3;
#line 120
    b = (i - 160) * 3;
#line 121
    if (r < 0) {
#line 121
      r = 0;
    }
#line 122
    if (r > 255) {
#line 122
      r = 255;
    }
#line 123
    if (g___0 < 0) {
#line 123
      g___0 = 0;
    }
#line 124
    if (g___0 > 255) {
#line 124
      g___0 = 255;
    }
#line 125
    if (b < 0) {
#line 125
      b = 0;
    }
#line 126
    if (b > 255) {
#line 126
      b = 255;
    }
#line 127
    cmap[i].r = (unsigned char )r;
#line 128
    cmap[i].g = (unsigned char )g___0;
#line 129
    cmap[i].b = (unsigned char )b;
#line 116
    i ++;
  }
#line 131
  SDL_SetColors(gb->screen, cmap, 0, i);
#line 134
  i = 0;
#line 134
  while (i < 300) {
#line 136
    r = i * 3;
#line 137
    g___0 = (i - 80) * 3;
#line 138
    b = (i - 160) * 3;
#line 139
    if (r < 0) {
#line 139
      r = 0;
    }
#line 140
    if (r > 255) {
#line 140
      r = 255;
    }
#line 141
    if (g___0 < 0) {
#line 141
      g___0 = 0;
    }
#line 142
    if (g___0 > 255) {
#line 142
      g___0 = 255;
    }
#line 143
    if (b < 0) {
#line 143
      b = 0;
    }
#line 144
    if (b > 255) {
#line 144
      b = 255;
    }
#line 145
    tmp = SDL_MapRGB((SDL_PixelFormat const   *)(gb->screen)->format, (unsigned char )r,
                     (unsigned char )g___0, (unsigned char )b);
#line 145
    *(ctab___0 + i) = (int )tmp;
#line 134
    i ++;
  }
#line 147
  return;
}
}
#line 149 "xflame.c"
static void XFSetRandomFlameBase(int *f___0 , int w___1 , int ws___0 , int h___1 ) 
{ int x ;
  int y ;
  int *ptr ;
  Uint16 tmp ;

  {
#line 157
  SeedRandom(0U);
#line 158
  y = h___1 - 1;
#line 159
  x = 0;
#line 159
  while (x < w___1) {
#line 161
    ptr = (f___0 + (y << ws___0)) + x;
#line 162
    tmp = FastRandom((unsigned short)300);
#line 162
    *ptr = (int )tmp;
#line 159
    x ++;
  }
#line 164
  return;
}
}
#line 166 "xflame.c"
static void XFModifyFlameBase(int *f___0 , int w___1 , int ws___0 , int h___1 ) 
{ int x ;
  int y ;
  int *ptr ;
  int val ;
  Uint16 tmp ;

  {
#line 172
  y = h___1 - 1;
#line 173
  x = 0;
#line 173
  while (x < w___1) {
#line 175
    ptr = (f___0 + (y << ws___0)) + x;
#line 176
    tmp = FastRandom((unsigned short)5);
#line 176
    *ptr += (int )tmp - 2;
#line 177
    val = *ptr;
#line 178
    if (val > 300) {
#line 178
      *ptr = 0;
    }
#line 179
    if (val < 0) {
#line 179
      *ptr = 0;
    }
#line 173
    x ++;
  }
#line 181
  return;
}
}
#line 183 "xflame.c"
static void XFProcessFlame(int *f___0 , int w___1 , int ws___0 , int h___1 , int *ff ) 
{ int x ;
  int y ;
  int *ptr ;
  int *p ;
  int tmp ;
  int val ;

  {
#line 189
  y = h___1 - 1;
#line 189
  while (y >= 2) {
#line 191
    x = 1;
#line 191
    while (x < w___1 - 1) {
#line 193
      ptr = (f___0 + (y << ws___0)) + x;
#line 194
      val = *ptr;
#line 195
      if (val > 300) {
#line 195
        *ptr = 300;
      }
#line 196
      val = *ptr;
#line 197
      if (val > 0) {
#line 199
        tmp = val * 78 >> 8;
#line 200
        p = ptr - (2 << ws___0);
#line 201
        *p += tmp >> 1;
#line 202
        p = ptr - (1 << ws___0);
#line 203
        *p += tmp;
#line 204
        tmp = val * 26 >> 8;
#line 205
        p = (ptr - (1 << ws___0)) - 1;
#line 206
        *p += tmp;
#line 207
        p = (ptr - (1 << ws___0)) + 1;
#line 208
        *p += tmp;
#line 209
        p = ptr - 1;
#line 210
        *p += tmp >> 1;
#line 211
        p = ptr + 1;
#line 212
        *p += tmp >> 1;
#line 213
        p = (ff + (y << ws___0)) + x;
#line 214
        *p = val;
#line 215
        if (y < h___1 - 1) {
#line 215
          *ptr = val * 68 >> 8;
        }
      }
#line 191
      x ++;
    }
#line 189
    y --;
  }
#line 219
  return;
}
}
#line 221 "xflame.c"
static void XFDrawFlameBLOK(struct globaldata *g___0 , int *f___0 , int w___1 , int ws___0 ,
                            int h___1 , int *ctab___0 ) 
{ int x ;
  int y ;
  int *ptr ;
  int xx ;
  int yy ;
  int cl ;
  int cl1 ;
  int cl2 ;
  int cl3 ;
  int cl4 ;
  unsigned char *cptr ;
  unsigned char *im ;
  unsigned char *p ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
#line 229
  tmp = SDL_LockSurface(g___0->screen);
#line 229
  if (tmp < (int __attribute__((__visibility__("default")))  )0) {
#line 230
    return;
  }
#line 233
  im = (unsigned char *)(g___0->screen)->pixels;
#line 234
  y = 0;
#line 234
  while (y < h___1 - 1) {
#line 236
    x = 0;
#line 236
    while (x < w___1 - 1) {
#line 238
      xx = x << 1;
#line 239
      yy = y << 1;
#line 240
      ptr = (f___0 + (y << ws___0)) + x;
#line 241
      cl = *ptr;
#line 241
      cl1 = cl;
#line 242
      ptr = ((f___0 + (y << ws___0)) + x) + 1;
#line 243
      cl2 = *ptr;
#line 244
      ptr = ((f___0 + ((y + 1) << ws___0)) + x) + 1;
#line 245
      cl3 = *ptr;
#line 246
      ptr = (f___0 + ((y + 1) << ws___0)) + x;
#line 247
      cl4 = *ptr;
#line 248
      cptr = (im + yy * (int )(g___0->screen)->pitch) + xx;
#line 249
      *cptr = (unsigned char )*(ctab___0 + cl % 300);
#line 250
      p = cptr + 1;
#line 251
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl2) >> 1) % 300);
#line 252
      p = (cptr + 1) + (int )(g___0->screen)->pitch;
#line 253
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl3) >> 1) % 300);
#line 254
      p = cptr + (int )(g___0->screen)->pitch;
#line 255
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl4) >> 1) % 300);
#line 236
      x ++;
    }
#line 234
    y ++;
  }
#line 258
  SDL_UnlockSurface(g___0->screen);
#line 261
  SDL_Flip(g___0->screen);
#line 262
  return;
}
}
#line 264 "xflame.c"
static void XFUpdate(struct globaldata *g___0 ) 
{ int i ;

  {
#line 267
  if (((g___0->screen)->flags & 1073741824U) == 1073741824U) {
#line 268
    SDL_Flip(g___0->screen);
  } else {
#line 272
    i = 0;
#line 272
    while (i < g___0->nrects) {
#line 273
      SDL_UpperBlit(flame_layer, g___0->rects + i, screen, g___0->rects + i);
#line 275
      SDL_UpperBlit(widget_layer, g___0->rects + i, screen, g___0->rects + i);
#line 272
      i ++;
    }
#line 278
    SDL_UpdateRects(screen, g___0->nrects, g___0->rects);
  }
#line 280
  return;
}
}
#line 282 "xflame.c"
static void XFDrawFlameLACE(struct globaldata *g___0 , int *f___0 , int w___1 , int ws___0 ,
                            int h___1 , int *ctab___0 ) 
{ int x ;
  int y ;
  int *ptr ;
  int xx ;
  int yy ;
  int cl ;
  int cl1 ;
  int cl2 ;
  int cl3 ;
  int cl4 ;
  unsigned char *cptr ;
  unsigned char *im ;
  unsigned char *p ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
#line 292
  tmp = SDL_LockSurface(g___0->screen);
#line 292
  if (tmp < (int __attribute__((__visibility__("default")))  )0) {
#line 293
    return;
  }
#line 296
  im = (unsigned char *)(g___0->screen)->pixels;
#line 297
  y = 0;
#line 297
  while (y < h___1 - 1) {
#line 299
    x = 0;
#line 299
    while (x < w___1 - 1) {
#line 301
      xx = x << 1;
#line 302
      yy = y << 1;
#line 303
      ptr = (f___0 + (y << ws___0)) + x;
#line 304
      cl = *ptr;
#line 304
      cl1 = cl;
#line 305
      ptr = ((f___0 + (y << ws___0)) + x) + 1;
#line 306
      cl2 = *ptr;
#line 307
      ptr = ((f___0 + ((y + 1) << ws___0)) + x) + 1;
#line 308
      cl3 = *ptr;
#line 309
      ptr = (f___0 + ((y + 1) << ws___0)) + x;
#line 310
      cl4 = *ptr;
#line 311
      cptr = (im + yy * (int )(g___0->screen)->pitch) + xx;
#line 312
      *cptr = (unsigned char )*(ctab___0 + cl % 300);
#line 313
      p = cptr + 1;
#line 314
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl2) >> 1) % 300);
#line 315
      p = (cptr + 1) + (int )(g___0->screen)->pitch;
#line 316
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl3) >> 1) % 300);
#line 317
      p = cptr + (int )(g___0->screen)->pitch;
#line 318
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl4) >> 1) % 300);
#line 299
      x ++;
    }
#line 297
    y ++;
  }
#line 321
  SDL_UnlockSurface(g___0->screen);
#line 324
  w___1 <<= 1;
#line 325
  h___1 <<= 1;
#line 326
  g___0->nrects = 0;
#line 327
  y = 0;
#line 327
  while (y < h___1 - 1) {
#line 329
    (g___0->rects + g___0->nrects)->x = (short)0;
#line 330
    (g___0->rects + g___0->nrects)->y = (short )y;
#line 331
    (g___0->rects + g___0->nrects)->w = (unsigned short )w___1;
#line 332
    (g___0->rects + g___0->nrects)->h = (unsigned short)1;
#line 333
    (g___0->nrects) ++;
#line 327
    y += 4;
  }
#line 335
  XFUpdate(g___0);
#line 337
  g___0->nrects = 0;
#line 338
  y = 2;
#line 338
  while (y < h___1 - 1) {
#line 340
    (g___0->rects + g___0->nrects)->x = (short)0;
#line 341
    (g___0->rects + g___0->nrects)->y = (short )y;
#line 342
    (g___0->rects + g___0->nrects)->w = (unsigned short )w___1;
#line 343
    (g___0->rects + g___0->nrects)->h = (unsigned short)1;
#line 344
    (g___0->nrects) ++;
#line 338
    y += 4;
  }
#line 346
  XFUpdate(g___0);
#line 348
  g___0->nrects = 0;
#line 349
  y = 1;
#line 349
  while (y < h___1 - 1) {
#line 351
    (g___0->rects + g___0->nrects)->x = (short)0;
#line 352
    (g___0->rects + g___0->nrects)->y = (short )y;
#line 353
    (g___0->rects + g___0->nrects)->w = (unsigned short )w___1;
#line 354
    (g___0->rects + g___0->nrects)->h = (unsigned short)1;
#line 355
    (g___0->nrects) ++;
#line 349
    y += 4;
  }
#line 357
  XFUpdate(g___0);
#line 359
  g___0->nrects = 0;
#line 360
  y = 3;
#line 360
  while (y < h___1 - 1) {
#line 362
    (g___0->rects + g___0->nrects)->x = (short)0;
#line 363
    (g___0->rects + g___0->nrects)->y = (short )y;
#line 364
    (g___0->rects + g___0->nrects)->w = (unsigned short )w___1;
#line 365
    (g___0->rects + g___0->nrects)->h = (unsigned short)1;
#line 366
    (g___0->nrects) ++;
#line 360
    y += 4;
  }
#line 368
  XFUpdate(g___0);
#line 369
  return;
}
}
#line 371 "xflame.c"
static void XFDrawFlame(struct globaldata *g___0 , int *f___0 , int w___1 , int ws___0 ,
                        int h___1 , int *ctab___0 ) 
{ int x ;
  int y ;
  int *ptr ;
  int xx ;
  int yy ;
  int cl ;
  int cl1 ;
  int cl2 ;
  int cl3 ;
  int cl4 ;
  unsigned char *cptr ;
  unsigned char *im ;
  unsigned char *p ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
#line 381
  tmp = SDL_LockSurface(g___0->screen);
#line 381
  if (tmp < (int __attribute__((__visibility__("default")))  )0) {
#line 382
    return;
  }
#line 385
  im = (unsigned char *)(g___0->screen)->pixels;
#line 386
  y = 0;
#line 386
  while (y < h___1 - 1) {
#line 388
    x = 0;
#line 388
    while (x < w___1 - 1) {
#line 390
      xx = x << 1;
#line 391
      yy = y << 1;
#line 392
      ptr = (f___0 + (y << ws___0)) + x;
#line 393
      cl = *ptr;
#line 393
      cl1 = cl;
#line 394
      ptr = ((f___0 + (y << ws___0)) + x) + 1;
#line 395
      cl2 = *ptr;
#line 396
      ptr = ((f___0 + ((y + 1) << ws___0)) + x) + 1;
#line 397
      cl3 = *ptr;
#line 398
      ptr = (f___0 + ((y + 1) << ws___0)) + x;
#line 399
      cl4 = *ptr;
#line 400
      cptr = (im + yy * (int )(g___0->screen)->pitch) + xx;
#line 401
      *cptr = (unsigned char )*(ctab___0 + cl % 300);
#line 402
      p = cptr + 1;
#line 403
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl2) >> 1) % 300);
#line 404
      p = (cptr + 1) + (int )(g___0->screen)->pitch;
#line 405
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl3) >> 1) % 300);
#line 406
      p = cptr + (int )(g___0->screen)->pitch;
#line 407
      *p = (unsigned char )*(ctab___0 + ((cl1 + cl4) >> 1) % 300);
#line 388
      x ++;
    }
#line 386
    y ++;
  }
#line 410
  SDL_UnlockSurface(g___0->screen);
#line 413
  w___1 <<= 1;
#line 414
  h___1 <<= 1;
#line 415
  g___0->nrects = 0;
#line 416
  y = 0;
#line 416
  while (y < h___1 - 1) {
#line 418
    (g___0->rects + g___0->nrects)->x = (short)0;
#line 419
    (g___0->rects + g___0->nrects)->y = (short )y;
#line 420
    (g___0->rects + g___0->nrects)->w = (unsigned short )w___1;
#line 421
    (g___0->rects + g___0->nrects)->h = (unsigned short)1;
#line 422
    (g___0->nrects) ++;
#line 416
    y += 2;
  }
#line 424
  XFUpdate(g___0);
#line 426
  g___0->nrects = 0;
#line 427
  y = 1;
#line 427
  while (y < h___1 - 1) {
#line 429
    (g___0->rects + g___0->nrects)->x = (short)0;
#line 430
    (g___0->rects + g___0->nrects)->y = (short )y;
#line 431
    (g___0->rects + g___0->nrects)->w = (unsigned short )w___1;
#line 432
    (g___0->rects + g___0->nrects)->h = (unsigned short)1;
#line 433
    (g___0->nrects) ++;
#line 427
    y += 2;
  }
#line 435
  XFUpdate(g___0);
#line 436
  return;
}
}
#line 439 "xflame.c"
static int *flame  ;
#line 439 "xflame.c"
static int flamesize  ;
#line 439 "xflame.c"
static int ws  ;
#line 439 "xflame.c"
static int flamewidth  ;
#line 439 "xflame.c"
static int flameheight  ;
#line 439 "xflame.c"
static int *flame2  ;
#line 440 "xflame.c"
static struct globaldata *g  ;
#line 441 "xflame.c"
static int w___0  ;
#line 441 "xflame.c"
static int h___0  ;
#line 441 "xflame.c"
static int f  ;
#line 441 "xflame.c"
static int *ctab  ;
#line 445 "xflame.c"
void atris_run_flame(void) 
{ 

  {
#line 448
  if (! Options.flame_wanted) {
#line 448
    return;
  }
#line 451
  XFModifyFlameBase(flame, w___0 >> 1, ws, h___0 >> 1);
#line 453
  XFProcessFlame(flame, w___0 >> 1, ws, h___0 >> 1, flame2);
#line 456
  if (f & 32) {
#line 458
    XFDrawFlameBLOK(g, flame2, w___0 >> 1, ws, h___0 >> 1, ctab);
  } else {
#line 460
    if (f & 64) {
#line 463
      XFDrawFlameLACE(g, flame2, w___0 >> 1, ws, h___0 >> 1, ctab);
    } else {
#line 467
      XFDrawFlame(g, flame2, w___0 >> 1, ws, h___0 >> 1, ctab);
    }
  }
#line 469
  return;
}
}
#line 471 "xflame.c"
static int Xflame(struct globaldata *_g , int _w , int _h , int _f , int *_ctab ) 
{ void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 474
  g = _g;
#line 474
  w___0 = _w;
#line 474
  h___0 = _h;
#line 474
  f = _f;
#line 474
  ctab = _ctab;
#line 480
  flamewidth = w___0 >> 1;
#line 481
  flameheight = h___0 >> 1;
#line 482
  ws = powerof((unsigned int )flamewidth);
#line 483
  flamesize = (int )((unsigned int )((1 << ws) * flameheight) * sizeof(int ));
#line 485
  tmp = malloc((unsigned int )flamesize);
#line 485
  flame = (int *)tmp;
#line 487
  if (! flame) {
#line 487
    return (0);
  }
#line 488
  memset((void *)flame, 0, (unsigned int )flamesize);
#line 490
  tmp___0 = malloc((unsigned int )flamesize);
#line 490
  flame2 = (int *)tmp___0;
#line 492
  if (! flame2) {
#line 492
    return (0);
  }
#line 493
  memset((void *)flame2, 0, (unsigned int )flamesize);
#line 494
  if (f & 32) {
#line 496
    g->rects = (SDL_Rect *)((void *)0);
  } else {
#line 498
    if (f & 64) {
#line 501
      tmp___1 = malloc((unsigned int )(h___0 >> 2) * sizeof(SDL_Rect ));
#line 501
      g->rects = (SDL_Rect *)tmp___1;
#line 503
      if (! g->rects) {
#line 503
        return (0);
      }
    } else {
#line 508
      tmp___2 = malloc((unsigned int )(h___0 >> 1) * sizeof(SDL_Rect ));
#line 508
      g->rects = (SDL_Rect *)tmp___2;
#line 510
      if (! g->rects) {
#line 510
        return (0);
      }
    }
  }
#line 513
  XFSetRandomFlameBase(flame, w___0 >> 1, ws, h___0 >> 1);
#line 521
  return (0);
}
}
#line 524 "xflame.c"
static struct globaldata glob  ;
#line 525 "xflame.c"
static int flags  ;
#line 526 "xflame.c"
static int colortab[300]  ;
#line 530 "xflame.c"
void atris_xflame_setup(void) 
{ 

  {
#line 535
  memset((void *)(& glob), 0, sizeof(glob));
#line 539
  glob.flags |= 536870912U;
#line 540
  glob.screen = flame_layer;
#line 542
  SetFlamePalette(& glob, flags, colortab);
#line 543
  Xflame(& glob, (glob.screen)->w, (glob.screen)->h, flags, colortab);
#line 544
  return;
}
}
